<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>SinFiltro - Arena Vehicular (MVP) â€” Con Textura Satelital</title>
<meta name="description" content="SinFiltro â€” MVP vehicular con textura satelital (tiles), colisiones suaves y optimizaciÃ³n para mÃ³vil." />
<style>
  html,body{height:100%;margin:0;background:#05060a;color:#eaf7ff;font-family:Inter,system-ui;overflow:hidden;-webkit-font-smoothing:antialiased}
  #canvasHolder{width:100%;height:100%;position:fixed;left:0;top:0}
  /* UI similar a tu versiÃ³n aprobada */
  #overlayUI{position:fixed;inset:0;pointer-events:none;z-index:60}
  .topBar{position:fixed;left:12px;right:12px;top:12px;display:flex;justify-content:space-between;align-items:center;pointer-events:auto;z-index:80}
  .logo{font-weight:700;padding:8px 12px;border-radius:10px;background:rgba(255,255,255,0.02)}
  .miniBtns{display:flex;gap:8px}
  .icon{padding:8px;border-radius:10px;background:rgba(255,255,255,0.02);cursor:pointer}
  .joy{ position:fixed; left:18px; bottom:18px; width:110px; height:110px; border-radius:60px; background:rgba(255,255,255,0.03); display:flex; align-items:center; justify-content:center; pointer-events:auto; z-index:70 }
  .stick{ width:48px; height:48px; border-radius:50%; background:rgba(255,255,255,0.08); transform:translate(0,0) }
  .btnFire{ position:fixed; right:20px; bottom:34px; width:72px; height:72px; border-radius:50%; background:linear-gradient(135deg,#00d1ff,#8a6eff); color:#001; font-weight:700; font-size:28px; display:flex; align-items:center; justify-content:center; pointer-events:auto; z-index:70; box-shadow:0 12px 40px rgba(0,0,0,0.5) }
  .viewer{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.85);z-index:90}
  .viewer img{max-width:90%;height:auto;border-radius:12px}
  @media(max-width:420px){ .joy{width:96px;height:96px} .stick{width:42px;height:42px} .btnFire{width:64px;height:64px} }
  /* small loader */
  #tileLoader{position:fixed;left:12px;bottom:12px;padding:8px 10px;border-radius:10px;background:rgba(0,0,0,0.45);z-index:80;font-size:13px;color:#cfeefc;pointer-events:none}
</style>
</head>
<body>
  <div id="canvasHolder" aria-hidden="true"></div>

  <!-- UI -->
  <div id="overlayUI">
    <div class="topBar">
      <div class="logo" id="logoBtn">SinFiltro â€” Arena</div>
      <div class="miniBtns">
        <div class="icon" id="btnMenu">â˜°</div>
        <div class="icon" id="btnStart">â–¶</div>
      </div>
    </div>

    <div class="joy" id="joy">
      <div class="stick" id="stick"></div>
    </div>

    <div class="btnFire" id="btnFire">ðŸ”«</div>
  </div>

  <div id="viewer" role="dialog" aria-hidden="true">
    <div style="text-align:center">
      <img id="viewerImg" src="" alt="preview"><br><br>
      <button id="closeViewer" style="padding:8px 12px;border-radius:8px">Cerrar</button>
    </div>
  </div>

  <div id="tileLoader">Tiles: <span id="tileCount">0</span></div>

  <!-- three.js -->
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

<script>
/*
  SinFiltro â€” MVP with satellite tiles on ground
  Notes:
  - Default center coordinates (lat/lon) are placeholders (adjust to the exact Playa Azul / Jardines de Morelos coords if you want)
  - Uses ESRI World Imagery tiles (public). Replace tile URL with another provider if you have API keys.
  - Loads a small tile grid (tileGrid x tileGrid) to keep mobile performance good.
*/

/* -------------------- Settings you can tweak -------------------- */
const MAP_CENTER = { lat: 19.5560, lon: -99.0580 }; // default center (adjust if you give me exact coords)
const MAP_ZOOM = 16;          // tile zoom (higher = more detail, more tiles)
const TILE_GRID = 3;         // stitches TILE_GRID x TILE_GRID tiles (odd number recommended, e.g. 3)
const TILE_PROVIDER = (z,x,y) => `https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/${z}/${y}/${x}`;
// NOTE: Esri World_Imagery uses {z}/{y}/{x} ordering for this URL
/* ---------------------------------------------------------------- */

const canvasHolder = document.getElementById('canvasHolder');
const tileCountEl = document.getElementById('tileCount');
let loadedTiles = 0, totalTiles = TILE_GRID*TILE_GRID;

(async function init(){
  // Three.js setup
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x05060a, 0.002);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;
  canvasHolder.appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
  camera.position.set(0,6,10);

  // Lights
  const dir = new THREE.DirectionalLight(0xffffff, 0.9); dir.position.set(5,10,7); scene.add(dir);
  scene.add(new THREE.AmbientLight(0xffffff, 0.25));

  // Ground placeholder until tiles load
  const baseMat = new THREE.MeshStandardMaterial({color:0x0b1220, metalness:0.1, roughness:0.95});
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(800,800, 1,1), baseMat);
  ground.rotation.x = -Math.PI/2; ground.position.y = 0; scene.add(ground);

  // Player car (kept as in your MVP)
  const car = new THREE.Group();
  const body = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.7,4.2), new THREE.MeshStandardMaterial({color:0xff5555, metalness:0.4, roughness:0.6}));
  body.position.y = 0.7; car.add(body);
  const wheelGeo = new THREE.CylinderGeometry(0.35,0.35,0.5,8); const wheelMat = new THREE.MeshStandardMaterial({color:0x111111});
  for(let i=0;i<4;i++){
    const w = new THREE.Mesh(wheelGeo, wheelMat); w.rotation.z = Math.PI/2; w.position.y = 0.25;
    w.position.x = (i%2===0)?-1:1; w.position.z = (i<2)?1.2:-1.2; car.add(w);
  }
  car.position.y = 0; car.position.z = 0; scene.add(car);

  // few props for orientation
  const boxMat = new THREE.MeshStandardMaterial({color:0x13232f});
  for(let i=0;i<40;i++){
    const h = 1 + Math.random()*2;
    const b = new THREE.Mesh(new THREE.BoxGeometry(1+Math.random()*2, h,1+Math.random()*2), boxMat);
    b.position.set((Math.random()-0.5)*200, h/2, (Math.random()-0.5)*200);
    scene.add(b);
  }

  // a simple bot
  const bot = car.clone(); bot.children[0].material = new THREE.MeshStandardMaterial({color:0x55aaff}); bot.position.set(8,0,-6); scene.add(bot);

  // camera follow variables
  const camOffset = new THREE.Vector3(0,4,10);
  const state = {forward:0, turn:0, speed:0, maxSpeed:0.8, rotSpeed:0.04};
  let lastTime = performance.now();
  const bullets = [];

  // --- Tile stitching: fetch tiles and compose canvas ---
  // helper: lon/lat -> tile x,y at zoom
  function lonLatToTile(lon, lat, zoom){
    const xtile = Math.floor((lon + 180) / 360 * Math.pow(2, zoom));
    const ytile = Math.floor((1 - Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180)) / Math.PI) / 2 * Math.pow(2, zoom));
    return {x: xtile, y: ytile};
  }

  // Build tile grid coords centered on MAP_CENTER
  const centerTile = lonLatToTile(MAP_CENTER.lon, MAP_CENTER.lat, MAP_ZOOM);
  const half = Math.floor(TILE_GRID/2);
  const tilePromises = [];
  const tileSize = 512; // tile pixel size for stitching (512 ok for Esri)
  const canvasW = tileSize * TILE_GRID;
  const canvasH = tileSize * TILE_GRID;
  const stitchCanvas = document.createElement('canvas');
  stitchCanvas.width = canvasW; stitchCanvas.height = canvasH;
  const stitchCtx = stitchCanvas.getContext('2d');

  // load tiles (progressive)
  for(let dx=-half; dx<=half; dx++){
    for(let dy=-half; dy<=half; dy++){
      const tx = centerTile.x + dx;
      const ty = centerTile.y + dy;
      const z = MAP_ZOOM;
      const url = TILE_PROVIDER(z, tx, ty);
      // fetch as image
      const p = new Promise((res)=>{
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = ()=> {
          // draw on canvas at correct position
          const sx = (dx + half) * tileSize;
          const sy = (dy + half) * tileSize;
          stitchCtx.drawImage(img, sx, sy, tileSize, tileSize);
          loadedTiles++; tileCountEl.textContent = loadedTiles + ' / ' + totalTiles;
          res(true);
        };
        img.onerror = ()=> {
          // draw placeholder (dark)
          stitchCtx.fillStyle = '#122'; stitchCtx.fillRect((dx+half)*tileSize, (dy+half)*tileSize, tileSize, tileSize);
          loadedTiles++; tileCountEl.textContent = loadedTiles + ' / ' + totalTiles;
          res(false);
        };
        img.src = url;
      });
      tilePromises.push(p);
    }
  }

  // When tiles loaded (or timeouts), create a texture and apply to ground
  const tileTimeout = new Promise((res)=> setTimeout(()=> res(false), 6000)); // fallback
  await Promise.race([Promise.all(tilePromises), tileTimeout]);

  // optional: downscale the stitched canvas for performance (reduce resolution for mobile)
  const MAX_TEX_SIZE = 2048; // clamp
  let finalCanvas = stitchCanvas;
  if(stitchCanvas.width > MAX_TEX_SIZE){
    const scale = MAX_TEX_SIZE / stitchCanvas.width;
    const c2 = document.createElement('canvas');
    c2.width = Math.floor(stitchCanvas.width * scale);
    c2.height = Math.floor(stitchCanvas.height * scale);
    c2.getContext('2d').drawImage(stitchCanvas,0,0,c2.width,c2.height);
    finalCanvas = c2;
  }

  const tex = new THREE.CanvasTexture(finalCanvas);
  tex.encoding = THREE sRGBEncoding ?? THREE.sRGBEncoding; // fallback if older three
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(1,1);

  // Create ground plane sized to match tile coverage in world units
  // We'll map the tile canvas to an approximate world area â€” each tile ~ (meters per tile) at zoom.
  // Approx meters-per-pixel formula (at equator): 156543.03392 * cos(lat) / 2^z
  const latRad = MAP_CENTER.lat * Math.PI/180;
  const metersPerTile = (156543.03392 * Math.cos(latRad)) / Math.pow(2, MAP_ZOOM) * tileSize;
  // worldScale converts meters -> world units (we want ground to be reasonable)
  const worldScale = 0.03; // tweak for play scale (smaller => less geometry size)
  const groundMeters = metersPerTile * TILE_GRID;
  const groundWorld = groundMeters * worldScale;

  // remove previous ground and replace with textured ground
  scene.remove(ground);
  const groundGeom = new THREE.PlaneGeometry(groundWorld, groundWorld);
  const groundMat = new THREE.MeshStandardMaterial({map:tex, metalness:0.0, roughness:0.9});
  const texturedGround = new THREE.Mesh(groundGeom, groundMat);
  texturedGround.rotation.x = -Math.PI/2; texturedGround.position.y = 0;
  scene.add(texturedGround);

  // set camera offset relative to new scale
  camera.position.set(0, 4* (1 + worldScale), 9* (1 + worldScale));

  // Create "soft" collision boundaries around the stitched tile area (invisible boxes)
  // Center car at origin maps to tile center; compute extents:
  const halfExt = groundWorld/2 - 6 * worldScale; // leave small margin
  // four boxes along edges (invisible, but will push car back)
  const collisionBoxes = [];
  const colMat = new THREE.MeshBasicMaterial({visible:false});
  const thickness = 2 * worldScale;
  // north
  const north = new THREE.Mesh(new THREE.BoxGeometry(groundWorld + 4*thickness, 2, thickness), colMat);
  north.position.set(0,1, -halfExt - thickness/2); scene.add(north); collisionBoxes.push(north);
  // south
  const south = new THREE.Mesh(new THREE.BoxGeometry(groundWorld + 4*thickness, 2, thickness), colMat);
  south.position.set(0,1, halfExt + thickness/2); scene.add(south); collisionBoxes.push(south);
  // west
  const west = new THREE.Mesh(new THREE.BoxGeometry(thickness, 2, groundWorld + 4*thickness), colMat);
  west.position.set(-halfExt - thickness/2,1,0); scene.add(west); collisionBoxes.push(west);
  // east
  const east = west.clone(); east.position.set(halfExt + thickness/2,1,0); scene.add(east); collisionBoxes.push(east);

  // Movement & gameplay as before (kept)
  function spawnBullet(origin, dir){
    const g = new THREE.SphereGeometry(0.12, 8,8);
    const m = new THREE.MeshStandardMaterial({emissive:0xffcc77, color:0x222222});
    const b = new THREE.Mesh(g,m);
    b.position.copy(origin);
    b.userData.dir = dir.clone();
    b.userData.speed = 2.2;
    scene.add(b); bullets.push(b);
  }

  // input: joystick handling (same as prior)
  const joy = document.getElementById('joy'), stickEl = document.getElementById('stick');
  let touchId = null, baseX=0, baseY=0;
  let stick = {x:0,y:0};
  function resetStick(){ stick={x:0,y:0}; stickEl.style.transform = `translate(0px,0px)`; }
  joy.addEventListener('touchstart', e=>{ e.preventDefault(); const t=e.changedTouches[0]; touchId=t.identifier; baseX=t.clientX; baseY=t.clientY; }, {passive:false});
  joy.addEventListener('touchmove', e=>{ e.preventDefault(); for(const t of e.changedTouches){ if(t.identifier===touchId){ const dx=t.clientX-baseX, dy=t.clientY-baseY; const max=36; const nx=Math.max(-1,Math.min(1,dx/max)); const ny=Math.max(-1,Math.min(1,dy/max)); stick.x=nx; stick.y=-ny; stickEl.style.transform=`translate(${nx*28}px,${-ny*28}px)`; } } }, {passive:false});
  joy.addEventListener('touchend', e=>{ for(const t of e.changedTouches) if(t.identifier===touchId){ touchId=null; resetStick(); } }, {passive:false});
  // pointer/mouse for desktop
  let md=false;
  joy.addEventListener('pointerdown', e=>{ md=true; baseX=e.clientX; baseY=e.clientY; joy.setPointerCapture && joy.setPointerCapture(e.pointerId); });
  joy.addEventListener('pointermove', e=>{ if(!md) return; const dx=e.clientX-baseX, dy=e.clientY-baseY; const max=36; const nx=Math.max(-1,Math.min(1,dx/max)); const ny=Math.max(-1,Math.min(1,dy/max)); stick.x=nx; stick.y=-ny; stickEl.style.transform=`translate(${nx*28}px,${-ny*28}px)`; });
  joy.addEventListener('pointerup', e=>{ md=false; resetStick(); });

  // fire button
  const fireBtn = document.getElementById('btnFire');
  fireBtn.addEventListener('touchstart', e=>{ e.preventDefault(); doFire(); }, {passive:false});
  fireBtn.addEventListener('mousedown', ()=> doFire());
  function doFire(){
    const dir = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion).normalize();
    const origin = car.position.clone().add(new THREE.Vector3(0,1, -2).applyQuaternion(car.quaternion));
    spawnBullet(origin, dir);
  }

  // simple bot movement
  let botAngle = 0;

  // collision check helper: push car back softly
  function resolveCollisions(entity){
    // test bounding sphere vs boxes and push back softly
    const pos = entity.position;
    for(const box of collisionBoxes){
      const boxBox = new THREE.Box3().setFromObject(box);
      // simple sphere-box check
      const radius = 1.6; // comfortable radius for car
      if(boxBox.distanceToPoint(pos) < 0.1){
        // push away towards center
        const dir = new THREE.Vector3(0,0,0).subVectors(pos, new THREE.Vector3(0,0,0)).setY(0).normalize();
        if(dir.lengthSq() < 0.01) dir.set(1,0,0);
        // apply soft push
        pos.add(dir.multiplyScalar(0.08));
        // reduce speed a bit
        state.speed *= 0.6;
      }
    }
  }

  // rendering loop
  let last = performance.now();
  function animate(){
    const now = performance.now();
    const dt = Math.min(50, now - last) / 16.666;
    last = now;

    // input state to physics
    state.forward = Math.max(-1, Math.min(1, stick.y));
    state.turn = Math.max(-1, Math.min(1, stick.x));
    if(state.forward > 0.05) state.speed += 0.02 * state.forward * dt;
    else if(state.forward < -0.05) state.speed -= 0.03 * (-state.forward) * dt;
    else state.speed *= 0.98;
    state.speed = Math.max(-state.maxSpeed, Math.min(state.maxSpeed, state.speed));
    car.rotation.y += -state.turn * state.rotSpeed * (0.9 + Math.abs(state.speed)) * dt;
    const forwardVec = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion);
    car.position.add(forwardVec.multiplyScalar(state.speed * dt * 0.8));

    // soft collision
    resolveCollisions(car);

    // camera follow (smooth)
    const desiredCam = car.position.clone().add(new THREE.Vector3(0,4,10).applyQuaternion(car.quaternion));
    camera.position.lerp(desiredCam, 0.12);
    camera.lookAt(car.position.clone().add(new THREE.Vector3(0,1.5,0)));

    // bot movement
    botAngle += 0.002 * dt * 30;
    bot.position.x = Math.cos(botAngle) * 8;
    bot.position.z = Math.sin(botAngle) * 8;
    bot.lookAt(car.position);

    // bullets update
    for(let i=bullets.length-1;i>=0;i--){
      const b = bullets[i];
      b.position.add(b.userData.dir.clone().multiplyScalar(b.userData.speed * dt));
      if(b.position.distanceTo(bot.position) < 1.4){
        scene.remove(b); bullets.splice(i,1);
        const hit = new THREE.Mesh(new THREE.SphereGeometry(0.25,6,6), new THREE.MeshStandardMaterial({emissive:0xff5522, color:0x111111}));
        hit.position.copy(bot.position); scene.add(hit);
        setTimeout(()=> scene.remove(hit), 500);
        continue;
      }
      if(b.position.length() > 2000){ scene.remove(b); bullets.splice(i,1); }
    }

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }
  requestAnimationFrame(animate);

  // UI small interactions kept
  document.getElementById('btnMenu').addEventListener('click', ()=> alert('Menu demo: ajustes / perfil / monetizaciÃ³n (placeholders)'));
  document.getElementById('btnStart').addEventListener('click', ()=> alert('Iniciar partida demo: 1v1 / 4v4 (placeholder)'));
  document.getElementById('logoBtn').addEventListener('click', ()=> {
    const v = document.getElementById('viewer');
    document.getElementById('viewerImg').src = stitchCanvas.toDataURL();
    v.style.display = 'flex'; v.setAttribute('aria-hidden','false');
  });
  document.getElementById('closeViewer').addEventListener('click', ()=> { const v=document.getElementById('viewer'); v.style.display='none'; v.setAttribute('aria-hidden','true'); });

  // ensure canvas doesn't block pointer gestures for UI
  renderer.domElement.style.touchAction = 'none';

  // expose some debug logs
  console.log('Tiles stitched (approx):', TILE_GRID, 'zoom', MAP_ZOOM, 'groundWorld size (units):', groundWorld);

})().catch(err=>{ console.error(err); alert('Error inicializando escena: '+err.message); });

</script>
</body>
</html>
