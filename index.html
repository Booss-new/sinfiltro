<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>SinFiltro - Arena Vehicular (Playas - Mapbox)</title>
<meta name="description" content="SinFiltro - Arena Vehicular (MVP) con Mapbox Terrain/Satellite - optimizado m√≥vil" />
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=Poppins:wght@500;700&display=swap" rel="stylesheet">
<style>
  :root{--bg:#05060a;--text:#eaf7ff;--muted:#9fb0bf;--accent1:#00d1ff;--accent2:#8a6eff}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#05060a,#071226);color:var(--text);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;}
  /* canvas full */
  #canvasHolder{position:fixed;inset:0;z-index:0}
  /* UI overlay (keeps your premium look) */
  #overlayUI{position:fixed;inset:0;pointer-events:none;z-index:30}
  .topBar{position:fixed;left:12px;right:12px;top:12px;display:flex;justify-content:space-between;align-items:center;pointer-events:auto;z-index:40}
  .logo{font-family:Poppins,system-ui;font-weight:700;padding:8px 12px;border-radius:10px;background:rgba(255,255,255,0.02);cursor:pointer}
  .miniBtns{display:flex;gap:8px}
  .icon{padding:8px;border-radius:10px;background:rgba(255,255,255,0.02);cursor:pointer}
  .joy{position:fixed;left:18px;bottom:18px;width:110px;height:110px;border-radius:60px;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;pointer-events:auto;z-index:35}
  .stick{width:48px;height:48px;border-radius:50%;background:rgba(255,255,255,0.08);transform:translate(0,0)}
  .btnFire{position:fixed;right:20px;bottom:34px;width:72px;height:72px;border-radius:50%;background:linear-gradient(135deg,var(--accent1),var(--accent2));color:#001;display:flex;align-items:center;justify-content:center;pointer-events:auto;z-index:35;box-shadow:0 12px 40px rgba(0,0,0,0.5);font-weight:700}
  /* mini map */
  #miniMap{position:fixed;right:12px;bottom:110px;width:120px;height:120px;border-radius:10px;background:rgba(0,0,0,0.45);overflow:hidden;z-index:36;pointer-events:auto;border:1px solid rgba(255,255,255,0.04)}
  #miniMap canvas{width:100%;height:100%;display:block}
  /* status */
  #status{position:fixed;left:12px;bottom:12px;padding:8px 10px;border-radius:10px;background:rgba(0,0,0,0.45);font-size:12px;color:var(--muted);z-index:36;pointer-events:none}
  /* viewer */
  #viewer{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:linear-gradient(180deg,rgba(0,0,0,0.9),rgba(0,0,0,0.95));z-index:60}
  #viewer .card{width:92%;max-width:900px;border-radius:12px;overflow:hidden;background:#000;padding:12px}
  /* small controls */
  .control-bar{position:fixed;left:12px;top:86px;display:flex;gap:8px;z-index:36;pointer-events:auto}
  .small-btn{padding:8px 10px;border-radius:10px;background:rgba(255,255,255,0.02);cursor:pointer;border:1px solid rgba(255,255,255,0.02)}
  /* responsive tweaks */
  @media(max-width:420px){ .joy{width:96px;height:96px} .stick{width:42px;height:42px} .btnFire{width:64px;height:64px} #miniMap{width:96px;height:96px} }
</style>
</head>
<body>
  <div id="canvasHolder" aria-hidden="true"></div>

  <div id="overlayUI">
    <div class="topBar" role="banner">
      <div style="display:flex;align-items:center;gap:12px;">
        <button id="btnMenu" class="icon" aria-label="menu">‚ò∞</button>
        <button id="brandBtn" class="logo" aria-label="inicio">SinFiltro</button>
      </div>
      <div style="display:flex;align-items:center;gap:8px;">
        <button id="toggleStyle" class="icon" title="Alternar sat√©lite/normal">üó∫Ô∏è</button>
        <button id="themeBtn" class="icon" title="Modo">üåó</button>
      </div>
    </div>

    <div class="control-bar" aria-hidden="true">
      <button id="recenterBtn" class="small-btn">Recentrar</button>
      <div id="fps" class="small-btn">FPS: --</div>
    </div>

    <div id="miniMap" title="Mini mapa"><canvas id="miniCanvas" width="256" height="256"></canvas></div>

    <div id="status">Estado: <span id="statusText">En carretera</span></div>

    <div class="joy" id="joy" aria-hidden="false" title="Joystick">
      <div class="stick" id="stick"></div>
    </div>

    <button id="btnFire" class="btnFire" aria-label="disparar">üî´</button>
  </div>

  <div id="viewer" role="dialog" aria-hidden="true">
    <div class="card">
      <div id="viewerInner"></div>
      <div style="display:flex;gap:8px;justify-content:center;margin-top:12px">
        <button id="closeViewer" class="small-btn">Cerrar</button>
      </div>
    </div>
  </div>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

<script>
/*
  SinFiltro - Mapbox terrain (Option A)
  - Replace MAPBOX_TOKEN with your Mapbox token
  - Center coordinates default approx near Ecatepec/Jardines de Morelos (adjust below)
*/

const MAPBOX_TOKEN = 'YOUR_MAPBOX_ACCESS_TOKEN_HERE'; // <<--- REPLACE THIS
// Center (lat, lon) - adjust to precise Playas Azul coordinates if you want
let MAP_CENTER = { lat: 19.5735, lon: -99.0590 };

// Tile settings
const TILE_ZOOM = 16; // tile zoom used for detail (16~17 good for street-level)
const TILE_SIZE = 512; // request @2x if needed by adding @2x in URL

// Map style templates
const STYLE_SAT = 'mapbox.satellite';
const STYLE_STREET = 'mapbox.streets';

// Utility: lat/lon to tile X/Y
function lon2tile(lon, z) { return Math.floor((lon + 180) / 360 * Math.pow(2, z)); }
function lat2tile(lat, z) {
  const rad = lat * Math.PI / 180;
  return Math.floor((1 - Math.log(Math.tan(rad) + 1/Math.cos(rad)) / Math.PI) / 2 * Math.pow(2, z));
}
function tile2bounds(x,y,z){
  const n = Math.pow(2,z);
  const lon1 = x / n * 360 - 180;
  const lon2 = (x+1) / n * 360 - 180;
  const lat1 = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))) * 180/Math.PI;
  const lat2 = Math.atan(Math.sinh(Math.PI * (1 - 2 * (y+1) / n))) * 180/Math.PI;
  return {minLon:lon1, maxLon:lon2, maxLat:lat1, minLat:lat2};
}

// Mapbox tile URL helper (raster tiles)
function mapboxTileURL(style, z, x, y){
  // style can be 'mapbox.satellite' or use styles API; using v4 endpoint (widely compatible)
  // NOTE: you may need to adjust for access or upgrade plan
  return `https://api.mapbox.com/v4/${style}/${z}/${x}/${y}@2x.jpg?access_token=${MAPBOX_TOKEN}`;
}

/* ---------- Three.js scene ---------- */
const holder = document.getElementById('canvasHolder');
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x05060a, 0.002);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.domElement.style.display = 'block';
holder.appendChild(renderer.domElement);

// Camera
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 5000);
camera.position.set(0, 8, 14);

// Lights
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(5,10,7); scene.add(dir);
scene.add(new THREE.AmbientLight(0xffffff, 0.25));

// Ground plane (we will replace parts with tiles)
const baseMat = new THREE.MeshStandardMaterial({color:0x0b1220, metalness:0.05, roughness:0.9});
const ground = new THREE.Mesh(new THREE.PlaneGeometry(1000,1000,1,1), baseMat);
ground.rotation.x = -Math.PI/2; ground.position.y = 0; scene.add(ground);

// Player car - keep same low-poly model as before
const car = new THREE.Group();
const body = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.7,4.2), new THREE.MeshStandardMaterial({color:0xff3333, metalness:0.4, roughness:0.6}));
body.position.y = 0.7; car.add(body);
const wheelGeo = new THREE.CylinderGeometry(0.35,0.35,0.5,8);
const wheelMat = new THREE.MeshStandardMaterial({color:0x111111});
for(let i=0;i<4;i++){
  const w = new THREE.Mesh(wheelGeo, wheelMat); w.rotation.z = Math.PI/2;
  w.position.y = 0.25; w.position.x = (i%2===0)?-1:1; w.position.z = (i<2)?1.2:-1.2; car.add(w);
}
car.position.set(0,0,0); scene.add(car);

// Small bot for demo
const bot = car.clone();
bot.children[0].material = new THREE.MeshStandardMaterial({color:0x55aaff});
bot.position.set(8,0,-6); scene.add(bot);

// camera follow offset
const camOffset = new THREE.Vector3(0,4,10);

// movement state
const state = {forward:0, turn:0, speed:0, maxSpeed:0.9, rotSpeed:0.04};
let lastTime = performance.now();

// bullets container
const bullets = [];

/* ---------- Tile manager: loads 3x3 tiles around center and maps onto small planes ---------- */
const tileGroup = new THREE.Group();
scene.add(tileGroup);
let currentStyle = STYLE_SAT; // start with satellite
let tileMeshes = {}; // key = z/x/y

function clearTiles(){
  for(const k in tileMeshes){ const m = tileMeshes[k]; tileGroup.remove(m); if(m.material && m.material.map) m.material.map.dispose(); if(m.geometry) m.geometry.dispose(); }
  tileMeshes = {};
}

// grid size for plane per tile in world units (meters approx) - tuned for gameplay
const TILE_WORLD_SIZE = 40; // each tile plane will be TILE_WORLD_SIZE units wide (tweak for scale)

/* compute tiles around center lat/lon */
function loadTilesForCenter(lat, lon, z=TILE_ZOOM){
  if(!MAPBOX_TOKEN || MAPBOX_TOKEN==='YOUR_MAPBOX_ACCESS_TOKEN_HERE'){
    // no token - skip loading tiles, keep base plane only
    return;
  }
  const centerX = lon2tile(lon, z);
  const centerY = lat2tile(lat, z);
  const radius = 1; // 3x3
  const promises = [];
  for(let dy=-radius; dy<=radius; dy++){
    for(let dx=-radius; dx<=radius; dx++){
      const tx = centerX + dx;
      const ty = centerY + dy;
      const key = `${z}/${tx}/${ty}`;
      if(tileMeshes[key]) continue; // already
      const url = mapboxTileURL(currentStyle, z, tx, ty);
      // create plane and apply texture once loaded
      const geom = new THREE.PlaneGeometry(TILE_WORLD_SIZE, TILE_WORLD_SIZE);
      const mat = new THREE.MeshBasicMaterial({color:0x111111});
      const plane = new THREE.Mesh(geom, mat);
      // position plane in world: map tile offsets map to world XY
      // compute offset: dx * TILE_WORLD_SIZE, dy * TILE_WORLD_SIZE (with Y flipped)
      plane.rotation.x = -Math.PI/2;
      plane.position.x = dx * TILE_WORLD_SIZE;
      plane.position.z = -dy * TILE_WORLD_SIZE;
      tileGroup.add(plane);
      tileMeshes[key] = plane;
      // load image
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.src = url;
      promises.push(new Promise((res,rej)=>{
        img.onload = ()=>{
          const tex = new THREE.Texture(img);
          tex.needsUpdate = true;
          tex.encoding = THREE.sRGBEncoding;
          plane.material.map = tex;
          plane.material.needsUpdate = true;
          res();
        };
        img.onerror = ()=>{ res(); };
      }));
    }
  }
  return Promise.all(promises);
}

/* shift tileGroup so that car sits at tile center.
   We'll place car at world origin and map tiles around it.
   For more accuracy you'd project lat/lon <-> meters (WebMercator), but for now relative positioning works.
*/
function recenterTilesToPlayer(){
  // tiles created centered around tileGroup origin. Keep player at (0,0).
  // optionally sync tile images based on player's lat/lon if doing real-world movement.
}

/* ---------- Mini-map drawing (2D canvas) ---------- */
const miniCanvas = document.getElementById('miniCanvas');
const miniCtx = miniCanvas.getContext('2d');
function drawMiniMap(){
  // draw simplified representation: use tile meshes textures as mini images if available
  miniCtx.fillStyle = '#001018';
  miniCtx.fillRect(0,0,miniCanvas.width, miniCanvas.height);
  // draw center dot
  miniCtx.fillStyle = '#fff';
  miniCtx.beginPath();
  miniCtx.arc(miniCanvas.width/2, miniCanvas.height/2, 4, 0, Math.PI*2);
  miniCtx.fill();
  // FPS area handled separately
}

/* ---------- Joystick handling (mobile) ---------- */
const joy = document.getElementById('joy'), stickEl = document.getElementById('stick');
let touchId = null, baseX=0, baseY=0;
let stick = {x:0,y:0};
function resetStick(){ stick={x:0,y:0}; stickEl.style.transform = `translate(0px,0px)`; }
joy.addEventListener('touchstart', e=>{ e.preventDefault(); const t = e.changedTouches[0]; touchId = t.identifier; baseX = t.clientX; baseY = t.clientY; }, {passive:false});
joy.addEventListener('touchmove', e=>{ e.preventDefault(); for(const t of e.changedTouches){ if(t.identifier === touchId){ const dx = t.clientX - baseX; const dy = t.clientY - baseY; const max = 36; const nx = Math.max(-1, Math.min(1, dx/max)); const ny = Math.max(-1, Math.min(1, dy/max)); stick.x = nx; stick.y = -ny; stickEl.style.transform = `translate(${nx*28}px,${-ny*28}px)`; } } }, {passive:false});
joy.addEventListener('touchend', e=>{ for(const t of e.changedTouches) if(t.identifier===touchId){ touchId=null; resetStick(); } }, {passive:false});
let md=false;
joy.addEventListener('pointerdown', e=>{ md=true; baseX=e.clientX; baseY=e.clientY; joy.setPointerCapture(e.pointerId); });
joy.addEventListener('pointermove', e=>{ if(!md) return; const dx=e.clientX-baseX, dy=e.clientY-baseY; const max=36; const nx=Math.max(-1,Math.min(1,dx/max)); const ny=Math.max(-1,Math.min(1,dy/max)); stick.x=nx; stick.y=-ny; stickEl.style.transform=`translate(${nx*28}px,${-ny*28}px)`; });
joy.addEventListener('pointerup', e=>{ md=false; resetStick(); });

/* fire button */
const fireBtn = document.getElementById('btnFire');
fireBtn.addEventListener('touchstart', e=>{ e.preventDefault(); doFire(); }, {passive:false});
fireBtn.addEventListener('mousedown', ()=> doFire());
function spawnBullet(origin, dir){
  const g = new THREE.SphereGeometry(0.12, 8,8);
  const m = new THREE.MeshStandardMaterial({emissive:0xffcc77, color:0x222222});
  const b = new THREE.Mesh(g,m);
  b.position.copy(origin);
  b.userData.dir = dir.clone();
  b.userData.speed = 2.2;
  scene.add(b); bullets.push(b);
}
function doFire(){
  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion).normalize();
  const origin = car.position.clone().add(new THREE.Vector3(0,1,-2).applyQuaternion(car.quaternion));
  spawnBullet(origin, dir);
}

/* ---------- Viewer controls ---------- */
const viewer = document.getElementById('viewer'), viewerInner = document.getElementById('viewerInner'), closeViewer = document.getElementById('closeViewer');
document.getElementById('brandBtn').addEventListener('click', ()=> {
  // show preview image in viewer (demo)
  viewerInner.innerHTML = `<img src="https://picsum.photos/800/420?random=${Math.floor(Math.random()*1000)}" style="width:100%;border-radius:8px">`;
  viewer.style.display = 'flex';
});
closeViewer.addEventListener('click', ()=> { viewer.style.display='none'; });

/* ---------- UI actions ---------- */
document.getElementById('toggleStyle').addEventListener('click', ()=>{
  currentStyle = (currentStyle === STYLE_SAT) ? STYLE_STREET : STYLE_SAT;
  clearTiles();
  // reload tiles immediately for chosen style
  loadTilesForCenter(MAP_CENTER.lat, MAP_CENTER.lon);
});
document.getElementById('recenterBtn').addEventListener('click', ()=> { // recenter camera/car
  car.position.set(0,0,0); car.rotation.set(0,0,0); camera.position.set(0,8,14); });
document.getElementById('btnMenu').addEventListener('click', ()=> { alert('Men√∫ demo: Ajustes, perfil y m√°s (placeholders)'); });
document.getElementById('themeBtn').addEventListener('click', ()=>{
  document.body.classList.toggle('light');
  document.getElementById('themeBtn').textContent = document.body.classList.contains('light')? '‚òÄÔ∏è' : 'üåó';
});

/* ---------- Load initial tiles (if token provided) ---------- */
if(MAPBOX_TOKEN && MAPBOX_TOKEN !== 'YOUR_MAPBOX_ACCESS_TOKEN_HERE'){
  loadTilesForCenter(MAP_CENTER.lat, MAP_CENTER.lon).then(()=>{ /* tiles loaded */ });
} else {
  // No token: show subtle hint on mini-map
  miniCtx.fillStyle = '#12202a';
  miniCtx.fillRect(0,0,miniCanvas.width, miniCanvas.height);
  miniCtx.fillStyle = '#c7d6df';
  miniCtx.font = '12px Inter, Arial';
  miniCtx.fillText('Mapbox token missing', 8, 20);
}

/* ---------- Animation loop ---------- */
const fpsEl = document.getElementById('fps');
let frames = 0, fpsTime = performance.now();
function animate(){
  const now = performance.now();
  const dtRaw = now - lastTime;
  const dt = Math.min(50, dtRaw) / 16.666; // normalized
  lastTime = now;

  // joystick -> state
  state.forward = Math.max(-1, Math.min(1, stick.y));
  state.turn = Math.max(-1, Math.min(1, stick.x));

  // physics-like
  if(state.forward > 0.05) state.speed += 0.02 * state.forward * dt;
  else if(state.forward < -0.05) state.speed -= 0.03 * (-state.forward) * dt;
  else state.speed *= 0.98;
  state.speed = Math.max(-state.maxSpeed, Math.min(state.maxSpeed, state.speed));

  car.rotation.y += -state.turn * state.rotSpeed * (0.9 + Math.abs(state.speed)) * dt;
  const forwardVec = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion);
  car.position.add(forwardVec.multiplyScalar(state.speed * dt * 0.8));

  // camera follow
  const desiredCam = car.position.clone().add(new THREE.Vector3(0,4,10).applyQuaternion(car.quaternion));
  camera.position.lerp(desiredCam, 0.12);
  camera.lookAt(car.position.clone().add(new THREE.Vector3(0,1.5,0)));

  // bot orbit
  if(bot){
    const t = now * 0.0006;
    bot.position.x = Math.cos(t) * 8 + Math.sin(t*0.4)*2;
    bot.position.z = Math.sin(t) * 8 + Math.cos(t*0.3)*2;
    bot.lookAt(car.position);
  }

  // bullets update
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.position.add(b.userData.dir.clone().multiplyScalar(b.userData.speed * dt));
    if(b.position.distanceTo(bot.position) < 1.4){
      scene.remove(b); bullets.splice(i,1);
      const hit = new THREE.Mesh(new THREE.SphereGeometry(0.25,6,6), new THREE.MeshStandardMaterial({emissive:0xff5522, color:0x111111}));
      hit.position.copy(bot.position);
      scene.add(hit);
      setTimeout(()=> scene.remove(hit), 500);
      continue;
    }
    if(b.position.length() > 2000){ scene.remove(b); bullets.splice(i,1); }
  }

  // render
  renderer.render(scene, camera);

  // update mini map (lightweight)
  drawMiniMap();

  // FPS counter update (every 500ms)
  frames++;
  if(now - fpsTime > 500){
    const fps = Math.round(frames * 1000 / (now - fpsTime));
    fpsEl.textContent = 'FPS: '+fps;
    frames = 0; fpsTime = now;
  }

  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

/* ---------- Performance & mobile notes ----------
 - Limit pixelRatio to 1.5 for mobile.
 - Load only 3x3 tiles around center.
 - Use simple plane geometries for tiles to keep GPU cost low.
 - If Mapbox token omitted, map tiles won't load but gameplay remains.
 - To improve realism: implement WebMercator projection to correlate tile resolution to world units.
 - For production: cache tiles, use compressed textures, and handle rate-limits.
-------------------------------------------------- */

 // ensure canvas doesn't swallow all touch gestures
 renderer.domElement.style.touchAction = 'none';

 // expose a small API in console for quick tests
 window.__sinFiltro = {
   loadTilesForCenter: (lat,lon,z)=> loadTilesForCenter(lat,lon,z),
   setCenter: (lat,lon)=> { MAP_CENTER = {lat,lon}; clearTiles(); loadTilesForCenter(lat,lon); },
   currentStyle: ()=> currentStyle
 };

</script>
</body>
</html>
