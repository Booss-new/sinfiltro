<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
<title>Car-Combat Prototype — SinFiltro Labs</title>
<meta name="description" content="Prototipo juego combate de carros - Three.js + Cannon-es. Controles táctiles, IA enemiga, disparos." />
<style>
  html,body{height:100%;margin:0;background:#0b0f16;overflow:hidden;font-family:Inter,Arial,Helvetica,sans-serif}
  #container{width:100%;height:100%;touch-action:none;position:relative}
  /* HUD */
  #hud{position:absolute;left:12px;right:12px;top:12px;display:flex;justify-content:space-between;align-items:center;z-index:20}
  .label{background:rgba(0,0,0,0.4);backdrop-filter:blur(6px);padding:8px 12px;border-radius:10px;color:#eaf7ff;font-weight:600;box-shadow:0 8px 24px rgba(0,0,0,0.6)}
  #score{min-width:120px;text-align:center}
  /* Buttons bottom */
  #controls{position:absolute;left:0;right:0;bottom:12px;display:flex;justify-content:space-between;padding:0 12px;z-index:30;pointer-events:none}
  .left-controls,.right-controls{display:flex;gap:12px;pointer-events:auto}
  .btn{width:64px;height:64px;border-radius:999px;background:linear-gradient(135deg,#00d1ff,#8a6eff);display:flex;align-items:center;justify-content:center;color:#001;font-weight:800;font-size:20px;box-shadow:0 12px 30px rgba(0,0,0,0.6);touch-action:manipulation}
  .small-btn{width:48px;height:48px;border-radius:10px;background:rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:center;color:#eaf7ff;font-weight:700}
  #fireBtn{background:linear-gradient(135deg,#ff6aa3,#ffb86b)}
  /* Center bottom action (big) */
  #centerAction{position:fixed;left:50%;transform:translateX(-50%);bottom:86px;z-index:29;pointer-events:auto}
  /* Simple overlays and messages */
  #message{position:absolute;left:50%;transform:translateX(-50%);top:60px;background:linear-gradient(90deg,#001,rgba(255,255,255,0.02));padding:8px 14px;border-radius:999px;color:#eaf7ff;font-weight:700;z-index:25}
  /* Simple start panel */
  #startPanel{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:20px;border-radius:16px;color:#eaf7ff;z-index:50;box-shadow:0 30px 80px rgba(0,0,0,0.7);text-align:center}
  #startPanel button{margin-top:12px;padding:12px 18px;border-radius:12px;border:none;background:linear-gradient(90deg,#00d1ff,#8a6eff);color:#001;font-weight:800;font-size:16px}
  /* Mobile friendly tweaks */
  @media(max-width:420px){ .btn{width:58px;height:58px;font-size:18px} .small-btn{width:44px;height:44px} #startPanel{width:86%;} }
</style>
</head>
<body>
  <div id="container"></div>

  <!-- HUD -->
  <div id="hud">
    <div class="label" id="healthLabel">Vida: 100</div>
    <div class="label" id="score">Enemigos: 0</div>
  </div>

  <!-- Message -->
  <div id="message">Prototipo: Combate de carros — SinFiltro</div>

  <!-- Controls -->
  <div id="controls">
    <div class="left-controls">
      <div id="leftBtn" class="btn">◀</div>
      <div id="rightBtn" class="btn">▶</div>
    </div>
    <div id="centerAction">
      <div id="accelBtn" class="btn">▲</div>
    </div>
    <div class="right-controls">
      <div id="brakeBtn" class="small-btn">▼</div>
      <div id="fireBtn" class="btn">⚡</div>
    </div>
  </div>

  <!-- Start panel -->
  <div id="startPanel">
    <h2>SinFiltro — Arena (Demo)</h2>
    <p style="color:#9fb0bf">Controles táctiles: mover, acelerar, frenar y disparar. Compatible con escritorio.</p>
    <button id="startBtn">Iniciar</button>
  </div>

<script type="module">
/*
  Prototipo: combate de carros
  - Three.js render
  - cannon-es para física
  - controles táctiles y teclado
  - proyectiles, colisiones, IA enemiga básica
*/

/* Imports (CDN modules) */
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js';
import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.module.js';

const container = document.getElementById('container');
const startPanel = document.getElementById('startPanel');
const startBtn = document.getElementById('startBtn');
const healthLabel = document.getElementById('healthLabel');
const scoreLabel = document.getElementById('score');
const message = document.getElementById('message');

let scene, camera, renderer, world, clock;
let player = null;
let enemies = [];
let projectiles = [];
let lastSpawn = 0;
let enemyCount = 0;
let running = false;

/* SETTINGS */
const ARENA_SIZE = 80; // arena half-size
const MAX_ENEMIES = 6;

/* Init Three + Cannon */
function initThreeCannon(){
  // Scene
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x071226);

  // Camera
  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 500);
  camera.position.set(0, 22, 28);

  // Renderer
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;
  container.appendChild(renderer.domElement);

  // Light
  const hemi = new THREE.HemisphereLight(0xffffff, 0x111122, 0.6);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.8);
  dir.position.set(5,10,7);
  scene.add(dir);

  // Ground visual
  const gGeom = new THREE.PlaneGeometry(ARENA_SIZE*2, ARENA_SIZE*2, 1,1);
  const gMat = new THREE.MeshStandardMaterial({color:0x071026, metalness:0.1, roughness:0.9});
  const ground = new THREE.Mesh(gGeom, gMat);
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  // Simple arena boundary visuals
  const wallMat = new THREE.MeshStandardMaterial({color:0x071226, metalness:0.2, roughness:0.8});
  for(let i=0;i<4;i++){
    const w = new THREE.Mesh(new THREE.BoxGeometry(ARENA_SIZE*2,4,1), wallMat);
    if(i%2===0){ w.scale.set(1,1,1); w.position.set(0,2,(i===0? -ARENA_SIZE: ARENA_SIZE)); }
    else { w.rotation.y = Math.PI/2; w.position.set((i===1? -ARENA_SIZE: ARENA_SIZE),2,0); }
    scene.add(w);
  }

  // Cannon world
  world = new CANNON.World({gravity: new CANNON.Vec3(0,-9.82,0)});
  world.broadphase = new CANNON.SAPBroadphase(world);
  world.solver.iterations = 6;

  // ground physics
  const groundBody = new CANNON.Body({mass:0, shape: new CANNON.Plane(), material: new CANNON.Material()});
  groundBody.quaternion.setFromEuler(-Math.PI/2,0,0);
  world.addBody(groundBody);

  clock = new THREE.Clock();
  window.addEventListener('resize', onResize);
}

/* Player creation */
function createPlayer(){
  // visual
  const carGroup = new THREE.Group();
  const bodyGeom = new THREE.BoxGeometry(2.2,0.9,4);
  const bodyMat = new THREE.MeshStandardMaterial({color:0x00d1ff, metalness:0.4, roughness:0.3});
  const bodyMesh = new THREE.Mesh(bodyGeom, bodyMat);
  bodyMesh.position.y = 0.7;
  carGroup.add(bodyMesh);

  // turret (visual)
  const turret = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.3,1.2), new THREE.MeshStandardMaterial({color:0xffdd57}));
  turret.position.set(0,1.05,0.6);
  carGroup.add(turret);

  scene.add(carGroup);

  // physics body
  const shape = new CANNON.Box(new CANNON.Vec3(1.1,0.45,2));
  const body = new CANNON.Body({mass: 120, shape, position: new CANNON.Vec3(0,1,0), linearDamping:0.4, angularDamping:0.8});
  world.addBody(body);

  player = { mesh: carGroup, body, turret, health: 100, speed: 0, maxSpeed: 14 };
}

/* Enemy spawning */
function spawnEnemy(){
  if(enemies.length >= MAX_ENEMIES) return;
  const i = Math.floor(Math.random()*poolModels.length);
  const x = (Math.random()*2-1) * (ARENA_SIZE-8);
  const z = (Math.random()*2-1) * (ARENA_SIZE-8);

  // visual
  const mat = new THREE.MeshStandardMaterial({color:0xff6a6a, metalness:0.3, roughness:0.5});
  const m = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.9,4), mat);
  m.position.set(x,0.7,z);
  scene.add(m);

  // physics
  const shape = new CANNON.Box(new CANNON.Vec3(1.1,0.45,2));
  const body = new CANNON.Body({mass:100, shape, position: new CANNON.Vec3(x,1,z), linearDamping:0.6});
  world.addBody(body);

  const enemy = { mesh:m, body, health: 60, cooldown: 0 };
  enemies.push(enemy);
  enemyCount++;
  scoreLabel.textContent = `Enemigos: ${enemyCount}`;
}

/* Basic poolModels placeholder (unused but left for extension) */
const poolModels = [0,1,2,3,4];

/* Projectile creation */
function shootProjectile(fromPos, dir, speed=40, owner='player'){
  // visual
  const sph = new THREE.Mesh(new THREE.SphereGeometry(0.18,8,8), new THREE.MeshStandardMaterial({color: owner==='player' ? 0xffdd57 : 0xff8a8a}));
  sph.position.copy(fromPos);
  scene.add(sph);

  // physics
  const shape = new CANNON.Sphere(0.18);
  const body = new CANNON.Body({mass:1, shape, position: new CANNON.Vec3(fromPos.x,fromPos.y,fromPos.z), linearDamping:0});
  body.collisionFilterGroup = 1;
  body.collisionFilterMask = 1;
  body.velocity.set(dir.x*speed, dir.y*speed, dir.z*speed);
  world.addBody(body);

  projectiles.push({mesh:sph, body, owner, ttl: 4});
}

/* Input handling */
const input = { left:false, right:false, accel:false, brake:false, fire:false };
function bindControls(){
  // Touch buttons
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const accelBtn = document.getElementById('accelBtn');
  const brakeBtn = document.getElementById('brakeBtn');
  const fireBtn = document.getElementById('fireBtn');

  function addTouch(el, prop){
    el.addEventListener('touchstart', e=>{ e.preventDefault(); input[prop]=true; }, {passive:false});
    el.addEventListener('touchend', e=>{ e.preventDefault(); input[prop]=false; }, {passive:false});
    el.addEventListener('mousedown', e=>{ input[prop]=true; });
    el.addEventListener('mouseup', e=>{ input[prop]=false; });
    el.addEventListener('mouseleave', e=>{ input[prop]=false; });
  }
  addTouch(leftBtn, 'left');
  addTouch(rightBtn, 'right');
  addTouch(accelBtn, 'accel');
  addTouch(brakeBtn, 'brake');
  addTouch(fireBtn, 'fire');

  // Keyboard for desktop
  window.addEventListener('keydown', e=>{
    if(e.key === 'a' || e.key === 'ArrowLeft') input.left = true;
    if(e.key === 'd' || e.key === 'ArrowRight') input.right = true;
    if(e.key === 'w' || e.key === 'ArrowUp') input.accel = true;
    if(e.key === 's' || e.key === 'ArrowDown') input.brake = true;
    if(e.key === ' ') input.fire = true;
  });
  window.addEventListener('keyup', e=>{
    if(e.key === 'a' || e.key === 'ArrowLeft') input.left = false;
    if(e.key === 'd' || e.key === 'ArrowRight') input.right = false;
    if(e.key === 'w' || e.key === 'ArrowUp') input.accel = false;
    if(e.key === 's' || e.key === 'ArrowDown') input.brake = false;
    if(e.key === ' ') input.fire = false;
  });
}

/* Simple AI: seek player and shoot sometimes */
function updateEnemies(dt){
  enemies.forEach((en, idx)=>{
    if(!player) return;
    en.cooldown -= dt;
    // vector to player
    const target = new CANNON.Vec3(player.body.position.x, 0, player.body.position.z);
    const toPlayer = target.vsub(en.body.position);
    const dist = toPlayer.length();
    // normalize
    const dir = toPlayer.scale(1/dist || 0);

    // apply force towards player (simple)
    const speed = 6;
    en.body.velocity.x = dir.x * speed;
    en.body.velocity.z = dir.z * speed;

    // occasionally shoot when in range
    if(dist < 25 && en.cooldown <= 0){
      en.cooldown = 1.2 + Math.random()*1.2;
      const pos = new THREE.Vector3(en.body.position.x, en.body.position.y + 0.6, en.body.position.z);
      const dir3 = new THREE.Vector3(dir.x, 0, dir.z);
      shootProjectile(pos, dir3, 28, 'enemy');
    }

    // if health <= 0, remove
    if(en.health <= 0){
      // explosion effect (simple)
      scene.remove(en.mesh);
      world.removeBody(en.body);
      enemies.splice(idx,1);
      enemyCount--;
      scoreLabel.textContent = `Enemigos: ${Math.max(enemyCount,0)}`;
    }
  });
}

/* Collision handling: projectiles hitting cars */
function handleCollisions(){
  // naive check: iterate projectiles vs enemies and player
  projectiles.forEach((p, pi)=>{
    // TTL and bounds check
    p.ttl -= clock.getDelta();
    if(p.ttl <= 0){
      scene.remove(p.mesh);
      world.removeBody(p.body);
      projectiles.splice(pi,1);
      return;
    }
    // keep mesh synced
    p.mesh.position.copy(p.body.position);

    // player hit by enemy projectile
    if(p.owner === 'enemy' && player){
      const d = p.body.position.distanceTo(player.body.position);
      if(d < 2.2){
        // damage
        player.health -= 8;
        player.body.velocity.scale(0.9, player.body.velocity);
        updateHealthUI();
        // remove projectile
        scene.remove(p.mesh);
        world.removeBody(p.body);
        projectiles.splice(pi,1);
        // check player death
        if(player.health <= 0){
          gameOver();
        }
        return;
      }
    }

    // enemy hit by player projectile
    if(p.owner === 'player'){
      enemies.forEach((en, ei)=>{
        const d = p.body.position.distanceTo(en.body.position);
        if(d < 2.2){
          en.health -= 18;
          // recoil
          en.body.applyImpulse(new CANNON.Vec3((p.body.velocity.x||0)*0.4,0,(p.body.velocity.z||0)*0.4), en.body.position);
          // remove projectile
          scene.remove(p.mesh);
          world.removeBody(p.body);
          projectiles.splice(pi,1);
          // maybe spawn small reward
        }
      });
    }
  });
}

/* Game step: physics + render */
function animate(){
  if(!running) return;
  const dt = Math.min(0.03, clock.getDelta());

  // Player controls
  if(player){
    // rotation
    const turnSpeed = 2.8;
    if(input.left) player.body.angularVelocity.y = 1.4;
    if(input.right) player.body.angularVelocity.y = -1.4;
    if(!input.left && !input.right) player.body.angularVelocity.y = 0;

    // forward/back
    const forward = new CANNON.Vec3(0,0,-1);
    const quat = player.body.quaternion;
    const worldForward = quat.vmult(forward);

    if(input.accel){
      // apply forward impulse
      player.body.velocity.x += worldForward.x * 0.6;
      player.body.velocity.z += worldForward.z * 0.6;
      // clamp speed
      const vx = player.body.velocity.x, vz = player.body.velocity.z;
      const sp = Math.sqrt(vx*vx + vz*vz);
      const max = player.maxSpeed;
      if(sp > max){
        player.body.velocity.scale(max/sp, player.body.velocity);
      }
    }
    if(input.brake){
      player.body.velocity.scale(0.88, player.body.velocity);
    }
    // fire (with cooldown)
    if(input.fire){
      if(!player._fireCooldown || player._fireCooldown <= 0){
        player._fireCooldown = 0.45;
        const pos = new THREE.Vector3(player.body.position.x, player.body.position.y + 0.6, player.body.position.z);
        // compute forward
        const forwardVec = new THREE.Vector3(0,0,-1).applyQuaternion(new THREE.Quaternion(player.body.quaternion.x, player.body.quaternion.y, player.body.quaternion.z, player.body.quaternion.w));
        shootProjectile(pos, forwardVec, 45, 'player');
      }
    }
    if(player._fireCooldown) player._fireCooldown -= dt;

    // sync mesh with physics
    player.mesh.position.copy(player.body.position);
    player.mesh.quaternion.copy(player.body.quaternion);

    // camera follow (smooth)
    const camTarget = new THREE.Vector3(player.body.position.x, player.body.position.y, player.body.position.z);
    const desiredCamPos = camTarget.clone().add(new THREE.Vector3(0, 10, 18).applyQuaternion(player.mesh.quaternion));
    camera.position.lerp(desiredCamPos, 0.12);
    camera.lookAt(camTarget);
  }

  // update physics
  world.fixedStep();

  // update enemies simple AI and sync visuals
  updateEnemies(dt);
  enemies.forEach(e => {
    e.mesh.position.copy(e.body.position);
    e.mesh.quaternion.copy(e.body.quaternion);
  });

  // update projectiles collisions and TTL
  handleCollisions();

  // physics world step
  world.step(1/60, dt, 3);

  // render
  renderer.render(scene, camera);

  // schedule next
  requestAnimationFrame(animate);
}

/* Utilities */
function updateHealthUI(){
  healthLabel.textContent = `Vida: ${Math.max(0, Math.round(player.health))}`;
}

/* Spawn loop */
function spawnLoop(){
  if(!running) return;
  const now = performance.now()/1000;
  if(enemies.length < MAX_ENEMIES && now - lastSpawn > 2.2){
    spawnEnemy();
    lastSpawn = now;
  }
  setTimeout(spawnLoop, 1000);
}

/* Game over */
function gameOver(){
  running = false;
  message.textContent = 'Has sido destruido — Reinicia para intentar otra vez';
  startPanel.style.display = 'block';
}

/* Start game */
function startGame(){
  if(running) return;
  // setup scene and player if not exists
  if(!scene) initThreeCannon();
  if(!player) createPlayer();
  // reset variables
  player.health = 100;
  updateHealthUI();
  enemyCount = enemies.length = 0;
  projectiles.forEach(p => { scene.remove(p.mesh); try{ world.removeBody(p.body) }catch(e){} });
  projectiles = [];
  // spawn few enemies
  for(let i=0;i<3;i++) spawnEnemy();
  running = true;
  clock.start();
  startPanel.style.display = 'none';
  message.textContent = 'En juego — ¡Buena suerte!';
  // start loops
  animate();
  spawnLoop();
}

/* Resize */
function onResize(){
  if(!renderer) return;
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

/* Bind UI for start */
startBtn.addEventListener('click', () => { startGame(); });

/* Bind simple UI controls (menu, etc) - demo placeholders */
document.getElementById('leftBtn').addEventListener('contextmenu', e=> e.preventDefault());

/* Bind controls and keyboard */
bindControls();

/* Safety: stop when tab hidden to save battery */
document.addEventListener('visibilitychange', ()=>{
  if(document.hidden) { running = false; }
});

/* Tell user to tap start on mobile */
message.textContent = 'Pulsa "Iniciar" para comenzar (recomendado Chrome móvil).';

/* Expose for debugging (optional) */
window.__sf_game = { startGame, scene, world };

</script>
</body>
</html>
