<!-- index.html â€” SinFiltro: Playa Azul (OpciÃ³n A) - Todo en 1 archivo -->
<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>SinFiltro â€” Playa Azul (OpciÃ³n A)</title>
<meta name="description" content="SinFiltro â€” demo mÃ³vil: vehÃ­culo jugable sobre calles de Playa Azul (baja escala). Joystick tÃ¡ctil, minimapa, satÃ©lite, constricciÃ³n a vÃ­as." />
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=Poppins:wght@600&display=swap" rel="stylesheet">
<style>
  :root{
    --bg-1:#05060a; --bg-2:#071226;
    --accent-cyan:#00d1ff; --accent-violet:#8a6eff;
    --muted:#9fb0bf; --glass: rgba(255,255,255,0.04);
    --radius:12px; --fast:160ms; --mid:260ms; --text:#eaf7ff;
  }
  html,body{height:100%;margin:0;padding:0;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;background:linear-gradient(180deg,var(--bg-1),var(--bg-2));color:var(--text);-webkit-font-smoothing:antialiased;overflow:hidden}
  /* Container for canvas */
  #holder{width:100%;height:100%;position:relative;touch-action:none}

  /* Top UI */
  .topbar{position:fixed;left:8px;right:8px;top:10px;height:60px;display:flex;align-items:center;justify-content:space-between;gap:8px;z-index:120;pointer-events:auto}
  .brand{display:flex;align-items:center;gap:10px}
  .logo{font-family:Poppins,Inter;font-weight:600;font-size:16px;background:linear-gradient(90deg,var(--accent-cyan),var(--accent-violet));-webkit-background-clip:text;color:transparent}
  .badge{background:rgba(255,255,255,0.02);padding:8px 10px;border-radius:10px}
  .controls{display:flex;gap:8px;align-items:center}
  .chip{padding:8px 10px;border-radius:10px;background:var(--glass);border:1px solid rgba(255,255,255,0.03);color:var(--muted);font-weight:600;cursor:pointer}

  /* Joystick */
  .joy{position:fixed;left:14px;bottom:18px;width:110px;height:110px;border-radius:999px;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;pointer-events:auto;z-index:110;box-shadow:0 12px 40px rgba(0,0,0,0.5)}
  .stick{width:46px;height:46px;border-radius:999px;background:rgba(255,255,255,0.06);display:block;transform:translate(0,0)}
  /* Fire */
  .fire{position:fixed;right:14px;bottom:26px;width:72px;height:72px;border-radius:999px;background:linear-gradient(135deg,var(--accent-cyan),var(--accent-violet));display:flex;align-items:center;justify-content:center;color:#001;font-weight:700;z-index:110;pointer-events:auto;box-shadow:0 20px 60px rgba(0,0,0,0.55)}
  /* Minimap / info */
  .minimap{position:fixed;right:12px;bottom:120px;width:110px;height:110px;border-radius:10px;background:rgba(0,0,0,0.5);z-index:110;display:flex;align-items:center;justify-content:center;pointer-events:auto;box-shadow:0 12px 30px rgba(0,0,0,0.6)}
  .fps{position:fixed;left:12px;bottom:120px;background:rgba(0,0,0,0.5);padding:6px 10px;border-radius:10px;font-weight:600;z-index:110}
  .info{position:fixed;left:12px;bottom:80px;background:rgba(0,0,0,0.45);padding:8px 10px;border-radius:10px;z-index:110;font-size:13px}
  #loading{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:130;background:rgba(0,0,0,0.6);padding:12px 16px;border-radius:10px;font-weight:700}
  /* viewer modal (image preview) */
  #viewer{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(0,0,0,0.9), rgba(0,0,0,0.95));z-index:220}
  #viewer img{width:90%;height:auto;border-radius:12px}
  /* responsive */
  @media(max-width:420px){ .joy{width:94px;height:94px} .stick{width:40px;height:40px} .fire{width:62px;height:62px} .minimap{width:86px;height:86px} }
</style>
</head>
<body>
  <div id="holder" aria-hidden="false"></div>

  <div class="topbar" role="toolbar" aria-label="Controles">
    <div class="brand">
      <div class="logo" id="brandBtn">SinFiltro</div>
      <div class="badge">Playa Azul â€” demo</div>
    </div>
    <div class="controls">
      <div id="btnToggleRoads" class="chip">Calles: ON</div>
      <div id="btnToggleSat" class="chip">SatÃ©lite: OFF</div>
      <div id="btnRecenter" class="chip">Re-cent.</div>
    </div>
  </div>

  <div id="loading">Cargando datos de mapaâ€¦</div>

  <div class="joy" id="joy"><div class="stick" id="stick" aria-hidden="true"></div></div>
  <div class="fire" id="fire" role="button" aria-label="Disparar">ðŸ”«</div>

  <div class="minimap" id="minimap" aria-hidden="false"></div>
  <div class="fps" id="fps">FPS: --</div>
  <div class="info" id="info">Modo demo â€” cargandoâ€¦</div>

  <div id="viewer" role="dialog" aria-hidden="true"><img id="viewerImg" alt="preview"><br><button id="closeViewer" style="margin-top:12px;padding:8px 12px;border-radius:8px">Cerrar</button></div>

  <!-- three.js -->
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script>
  (async function(){
    /* ----------------- Config / bbox -----------------
       BBOX around Playa Azul / Jardines de Morelos (approx) â€” small area so mobile handles it.
       Format: [south, west, north, east] (lat, lon)
    --------------------------------------------------*/
    const BBOX = [19.6032, -99.0028, 19.6070, -98.9982]; // tweak if needed
    const OVERPASS_URL = 'https://overpass-api.de/api/interpreter';
    const ESRI_TILE = 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}';

    /* -------------- Three.js scene minimal -------------- */
    const holder = document.getElementById('holder');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x05060a);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.6));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    holder.appendChild(renderer.domElement);
    // Ensure canvas doesn't block pointer gestures for UI
    renderer.domElement.style.touchAction = 'none';

    const camera = new THREE.PerspectiveCamera(58, innerWidth/innerHeight, 0.1, 5000);
    camera.position.set(0, 12, 24);

    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(6,12,8); scene.add(dir);
    scene.add(new THREE.AmbientLight(0xffffff, 0.25));

    /* ground base (plain) */
    const groundMat = new THREE.MeshStandardMaterial({color:0x0e1116, roughness:0.95, metalness:0.03});
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000,1,1), groundMat);
    ground.rotation.x = -Math.PI/2; ground.position.y = 0; scene.add(ground);

    /* ---------------- world transform ---------------- */
    const latCenter = (BBOX[0] + BBOX[2]) / 2;
    const lonCenter = (BBOX[1] + BBOX[3]) / 2;
    const EARTH_RADIUS = 6378137;
    function metersPerDegLat(){ return (Math.PI/180) * EARTH_RADIUS; }
    function metersPerDegLon(lat){ return (Math.PI/180) * EARTH_RADIUS * Math.cos(lat * Math.PI/180); }
    const mPerDegLat = metersPerDegLat();
    const mPerDegLon = metersPerDegLon(latCenter);
    const SCALE = 0.06; // shrink world to comfortable size for mobile
    function ll2xy(lat, lon){
      const dx = (lon - lonCenter) * mPerDegLon;
      const dz = (lat - latCenter) * mPerDegLat;
      return new THREE.Vector3(dx * SCALE, 0, -dz * SCALE);
    }

    /* --------------- Player vehicle --------------- */
    const car = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.7,4.2), new THREE.MeshStandardMaterial({color:0xff5757, metalness:0.35, roughness:0.5}));
    body.position.y = 0.7; car.add(body);
    const wheelGeo = new THREE.CylinderGeometry(0.35,0.35,0.5,8);
    const wheelMat = new THREE.MeshStandardMaterial({color:0x111111});
    for(let i=0;i<4;i++){
      const w = new THREE.Mesh(wheelGeo, wheelMat);
      w.rotation.z = Math.PI/2; w.position.y = 0.25;
      w.position.x = (i%2===0)?-1:1;
      w.position.z = (i<2)?1.2:-1.2;
      car.add(w);
    }
    car.position.set(0,0,0);
    scene.add(car);

    /* groups */
    const roadsGroup = new THREE.Group(); scene.add(roadsGroup);
    const buildingsGroup = new THREE.Group(); scene.add(buildingsGroup);

    /* storage for road polylines (Vector3 arrays) for soft constraint */
    const roadPolylines = [];

    /* ----------------- Overpass fetch & parsing ----------------- */
    function overpassQuery(bbox){
      const [s,w,n,e] = bbox;
      return `
        [out:json][timeout:25];
        (
          way["highway"](${s},${w},${n},${e});
          way["building"](${s},${w},${n},${e});
        );
        (._;>;);
        out body;
      `;
    }
    async function fetchOSM(){
      const q = overpassQuery(BBOX);
      const r = await fetch(OVERPASS_URL, {method:'POST', body:q});
      if(!r.ok) throw new Error('Overpass failed');
      return r.json();
    }
    function parseOverpass(osm){
      const nodes = new Map();
      const ways = [];
      for(const el of osm.elements){
        if(el.type === 'node') nodes.set(el.id, el);
      }
      for(const el of osm.elements){
        if(el.type === 'way'){
          ways.push({id: el.id, nodes: el.nodes, tags: el.tags || {}});
        }
      }
      return {nodes, ways};
    }

    /* ----------------- build roads (lightweight) ----------------- */
    function buildRoads(nodes, ways){
      // allowed highway types for demo (keeps number small)
      const keep = new Set(['motorway','trunk','primary','secondary','tertiary','unclassified','residential','service','living_street']);
      roadsGroup.clear?.(); while(roadsGroup.children.length) roadsGroup.remove(roadsGroup.children[0]);
      roadPolylines.length = 0;
      let segCount = 0, wayCount = 0;
      const mat = new THREE.MeshStandardMaterial({color:0x1b2028, roughness:0.95});
      for(const w of ways){
        if(!w.tags.highway) continue;
        if(!keep.has(w.tags.highway) && w.tags.highway!=='residential') continue;
        const pts = [];
        for(const nid of w.nodes){
          const n = nodes.get(nid);
          if(!n) continue;
          pts.push(ll2xy(n.lat, n.lon));
        }
        if(pts.length < 2) continue;
        // simplified
        const simple = pts; // can decimate if needed
        // create thin boxes per segment
        for(let i=0;i<simple.length-1;i++){
          const a = simple[i], b = simple[i+1];
          const seg = new THREE.Vector3().copy(b).sub(a);
          const len = seg.length();
          if(len < 0.01) continue;
          const mid = a.clone().add(b).multiplyScalar(0.5);
          const width = (w.tags.highway === 'motorway' || w.tags.highway === 'trunk') ? 3.2 : 1.8;
          const geom = new THREE.BoxGeometry(width, 0.02, Math.max(len,0.08));
          const mesh = new THREE.Mesh(geom, mat);
          mesh.position.copy(mid); mesh.position.y = 0.01;
          mesh.lookAt(b); mesh.rotateX(Math.PI/2);
          roadsGroup.add(mesh);
          segCount++;
        }
        roadPolylines.push(simple.map(p=> new THREE.Vector3(p.x,0,p.z)));
        wayCount++;
      }
      return {segCount, wayCount};
    }

    /* ----------------- build buildings (lightweight boxes) ----------------- */
    function buildBuildings(nodes, ways){
      buildingsGroup.clear?.(); while(buildingsGroup.children.length) buildingsGroup.remove(buildingsGroup.children[0]);
      let count=0;
      const matB = new THREE.MeshStandardMaterial({color:0x0f1620, roughness:0.95});
      for(const w of ways){
        if(!w.tags.building) continue;
        const pts=[]; for(const nid of w.nodes){ const n=nodes.get(nid); if(n) pts.push(ll2xy(n.lat,n.lon)); }
        if(pts.length<3) continue;
        let minx=1e9,minz=1e9,maxx=-1e9,maxz=-1e9;
        for(const p of pts){ minx=Math.min(minx,p.x); maxx=Math.max(maxx,p.x); minz=Math.min(minz,p.z); maxz=Math.max(maxz,p.z); }
        const wth = Math.max(0.8, (maxx-minx)); const lng = Math.max(0.8, (maxz-minz));
        const height = (w.tags['building:levels'] ? Math.max(2, +w.tags['building:levels']) : Math.floor(2 + Math.random()*3)) * 1.6;
        const g = new THREE.BoxGeometry(wth, height, lng);
        const b = new THREE.Mesh(g, matB);
        b.position.set((minx+maxx)/2, height/2, (minz+maxz)/2);
        buildingsGroup.add(b);
        count++;
      }
      return count;
    }

    /* ----------------- Lamps (visual) ----------------- */
    function addLampAt(pos){
      const stick = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,1.8,6), new THREE.MeshStandardMaterial({color:0x111111}));
      stick.position.copy(pos).add(new THREE.Vector3(0,0.9,0));
      scene.add(stick);
      const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.06,8,8), new THREE.MeshBasicMaterial({color:0xfff8d9}));
      bulb.position.copy(pos).add(new THREE.Vector3(0,1.65,0));
      scene.add(bulb);
    }

    /* ----------------- soft constrain to road ----------------- */
    function constrainToRoad(pos){
      let best = {dist: Infinity, nearest: null};
      for(const poly of roadPolylines){
        for(let i=0;i<poly.length-1;i++){
          const a = poly[i], b = poly[i+1];
          const ap = pos.clone().sub(a);
          const ab = b.clone().sub(a);
          const denom = ab.lengthSq();
          if(denom <= 0) continue;
          let t = ap.dot(ab) / denom;
          t = Math.max(0, Math.min(1, t));
          const proj = a.clone().add(ab.multiplyScalar(t));
          const d = proj.distanceTo(pos);
          if(d < best.dist){ best.dist = d; best.nearest = proj; }
        }
      }
      if(!best.nearest) return false;
      const maxLat = 1.8; // allowed lateral distance (scene units)
      if(best.dist > maxLat){
        const dir = best.nearest.clone().sub(pos).multiplyScalar(0.28);
        pos.add(dir);
        return true;
      }
      return false;
    }

    /* ----------------- Overpass load + build ----------------- */
    async function initMapData(){
      try{
        const raw = await fetchOSM();
        const {nodes, ways} = parseOverpass(raw);
        const roadsInfo = buildRoads(nodes, ways);
        const bcount = buildBuildings(nodes, ways);
        // add lamps sparsely along roads
        for(const poly of roadPolylines){
          for(let i=0;i<poly.length;i+=Math.max(2, Math.floor(poly.length/5))){
            addLampAt(poly[i].clone());
          }
        }
        document.getElementById('info').textContent = `Calles: ${roadPolylines.length} vÃ­as â€¢ segmentos: ${roadsInfo.segCount} â€¢ edificios: ${bcount}`;
        document.getElementById('tilesCount')?.textContent = roadPolylines.length;
        document.getElementById('loading').style.display = 'none';
        // place car on a road if possible
        if(roadPolylines.length && roadPolylines[0].length){
          const midIdx = Math.floor(roadPolylines[0].length/2);
          car.position.copy(roadPolylines[0][midIdx].clone());
        }
        updateMinimap(); // initial minimap draw
        return true;
      }catch(err){
        console.error(err);
        document.getElementById('loading').textContent = 'Error cargando mapa (Overpass). Prueba recargar.';
        return false;
      }
    }

    /* ----------------- minimap (canvas) ----------------- */
    const minimapEl = document.getElementById('minimap');
    const mmCanvas = document.createElement('canvas'); mmCanvas.width = mmCanvas.height = 256;
    minimapEl.innerHTML = ''; minimapEl.appendChild(mmCanvas);
    const mmCtx = mmCanvas.getContext('2d');
    function updateMinimap(){
      mmCtx.clearRect(0,0,256,256);
      mmCtx.fillStyle = '#07101a'; mmCtx.fillRect(0,0,256,256);
      // draw roads
      mmCtx.strokeStyle = '#bfe9ff'; mmCtx.lineWidth = 1.8;
      mmCtx.beginPath();
      const scale = 0.35;
      for(const poly of roadPolylines){
        if(poly.length<2) continue;
        for(let i=0;i<poly.length;i++){
          const p = poly[i]; const x = 128 + p.x*scale; const y = 128 + p.z*scale;
          if(i===0) mmCtx.moveTo(x,y); else mmCtx.lineTo(x,y);
        }
      }
      mmCtx.stroke();
      // player
      const px = 128 + car.position.x * scale; const py = 128 + car.position.z * scale;
      mmCtx.fillStyle = '#ff6666'; mmCtx.beginPath(); mmCtx.arc(px,py,4,0,Math.PI*2); mmCtx.fill();
    }

    /* ----------------- satellite tile (single tile approx) ----------------- */
    let satTexture = null, satEnabled = false;
    async function loadSatellite(){
      try{
        const z = 16;
        function lon2tile(lon,z){ return Math.floor((lon+180)/360*Math.pow(2,z)); }
        function lat2tile(lat,z){ return Math.floor((1-Math.log(Math.tan(lat*Math.PI/180)+1/Math.cos(lat*Math.PI/180))/Math.PI)/2 * Math.pow(2,z)); }
        const tx = lon2tile(lonCenter, z);
        const ty = lat2tile(latCenter, z);
        const url = ESRI_TILE.replace('{z}',z).replace('{x}',tx).replace('{y}',ty);
        const img = await new Promise((res,rej)=>{
          const i = new Image(); i.crossOrigin='anonymous'; i.onload = ()=> res(i); i.onerror = rej; i.src = url;
        });
        satTexture = new THREE.CanvasTexture(img);
        satTexture.encoding = THREE.sRGBEncoding;
        return true;
      }catch(e){
        console.warn('Satellite load failed', e);
        return false;
      }
    }
    function enableSatellite(on){
      if(on && satTexture){
        ground.material = new THREE.MeshBasicMaterial({map: satTexture});
        satEnabled = true; document.getElementById('btnToggleSat').textContent = 'SatÃ©lite: ON';
      } else {
        ground.material = groundMat; satEnabled = false; document.getElementById('btnToggleSat').textContent = 'SatÃ©lite: OFF';
      }
    }

    /* ----------------- joystick & controls ----------------- */
    const joy = document.getElementById('joy'), stickEl = document.getElementById('stick');
    let touchId = null, baseX=0, baseY=0;
    let stick = {x:0,y:0};
    function resetStick(){ stick={x:0,y:0}; stickEl.style.transform = `translate(0px,0px)`; }
    joy.addEventListener('touchstart', e=>{ e.preventDefault(); const t = e.changedTouches[0]; touchId = t.identifier; baseX=t.clientX; baseY=t.clientY; }, {passive:false});
    joy.addEventListener('touchmove', e=>{ e.preventDefault(); for(const t of e.changedTouches){ if(t.identifier===touchId){ const dx=t.clientX-baseX, dy=t.clientY-baseY; const max=36; const nx=Math.max(-1,Math.min(1,dx/max)); const ny=Math.max(-1,Math.min(1,dy/max)); stick.x = nx; stick.y = -ny; stickEl.style.transform = `translate(${nx*28}px,${-ny*28}px)`; } } }, {passive:false});
    joy.addEventListener('touchend', e=>{ for(const t of e.changedTouches){ if(t.identifier===touchId){ touchId=null; resetStick(); } } }, {passive:false});
    // pointer fallback (desktop)
    let md=false;
    joy.addEventListener('pointerdown', e=>{ md=true; baseX=e.clientX; baseY=e.clientY; joy.setPointerCapture(e.pointerId); });
    joy.addEventListener('pointermove', e=>{ if(!md) return; const dx=e.clientX-baseX, dy=e.clientY-baseY; const max=36; const nx=Math.max(-1,Math.min(1,dx/max)); const ny=Math.max(-1,Math.min(1,dy/max)); stick.x=nx; stick.y=-ny; stickEl.style.transform=`translate(${nx*28}px,${-ny*28}px)`; });
    joy.addEventListener('pointerup', e=>{ md=false; resetStick(); });

    // fire button
    const fireBtn = document.getElementById('fire');
    fireBtn.addEventListener('touchstart', e=>{ e.preventDefault(); doFire(); }, {passive:false});
    fireBtn.addEventListener('mousedown', doFire);
    const bullets = [];
    function spawnBullet(origin, dir){
      const g = new THREE.SphereGeometry(0.12,8,8);
      const m = new THREE.MeshStandardMaterial({emissive:0xffcc77, color:0x222222});
      const b = new THREE.Mesh(g,m);
      b.position.copy(origin); b.userData.dir = dir.clone(); b.userData.speed=2.6;
      scene.add(b); bullets.push(b);
    }
    function doFire(){
      const dir = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion).normalize();
      const origin = car.position.clone().add(new THREE.Vector3(0,1,-2).applyQuaternion(car.quaternion));
      spawnBullet(origin, dir);
    }

    /* --------------- UI actions --------------- */
    let roadsVisible = true;
    document.getElementById('btnToggleRoads').addEventListener('click', ()=> {
      roadsVisible = !roadsVisible; roadsGroup.visible = roadsVisible;
      document.getElementById('btnToggleRoads').textContent = `Calles: ${roadsVisible ? 'ON' : 'OFF'}`;
    });
    document.getElementById('btnRecenter').addEventListener('click', ()=> { car.position.set(0,0,0); car.rotation.set(0,0,0); camera.position.set(0,12,24); });
    document.getElementById('btnToggleSat').addEventListener('click', async ()=>{
      if(!satTexture){ document.getElementById('btnToggleSat').textContent = 'SatÃ©lite: Cargando...'; await loadSatellite(); }
      enableSatellite(!satEnabled);
    });
    document.getElementById('brandBtn').addEventListener('click', ()=> window.scrollTo({top:0,behavior:'smooth'}));

    /* --------------- render loop --------------- */
    const state = {forward:0, turn:0, speed:0, maxSpeed:0.9, rotSpeed:0.05};
    let last = performance.now(); let frames = 0, fpsNow = 0, fpsLast = performance.now();
    function animate(){
      const now = performance.now();
      const dt = Math.min(50, now - last) / 16.666; last = now;

      // joystick -> state
      state.forward = Math.max(-1, Math.min(1, stick.y));
      state.turn = Math.max(-1, Math.min(1, stick.x));
      // update speed / physics (lightweight)
      if(state.forward > 0.05) state.speed += 0.018 * state.forward * dt;
      else if(state.forward < -0.05) state.speed -= 0.03 * (-state.forward) * dt;
      else state.speed *= 0.96;
      state.speed = Math.max(-state.maxSpeed, Math.min(state.maxSpeed, state.speed));
      // rotation
      car.rotation.y += -state.turn * state.rotSpeed * (0.9 + Math.abs(state.speed)) * dt;
      // forward movement
      const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion);
      car.position.add(fwd.multiplyScalar(state.speed * dt * 0.82));

      // soft constrain to roads to keep vehicle on street
      constrainToRoad(car.position);

      // bullets update (lightweight)
      for(let i=bullets.length-1;i>=0;i--){
        const b = bullets[i];
        b.position.add(b.userData.dir.clone().multiplyScalar(b.userData.speed * dt));
        if(b.position.length() > 900){ scene.remove(b); bullets.splice(i,1); }
      }

      // camera follow
      const desired = car.position.clone().add(new THREE.Vector3(0,4,10).applyQuaternion(car.quaternion));
      camera.position.lerp(desired, 0.12);
      camera.lookAt(car.position.clone().add(new THREE.Vector3(0,1.2,0)));

      // minimap & render
      updateMinimap();
      renderer.render(scene, camera);

      // fps calc
      frames++; if(now - fpsLast >= 500){ fpsNow = Math.round((frames*1000)/(now-fpsLast)); frames=0; fpsLast = now; document.getElementById('fps').textContent = `FPS: ${fpsNow}`; }
      requestAnimationFrame(animate);
    }

    /* --------------- init --------------- */
    const ok = await initMapData();
    // preload satellite (optional)
    loadSatellite().then(()=>{/*cached*/}).catch(()=>{/*ignore*/});
    requestAnimationFrame(animate);

    // resize
    window.addEventListener('resize', ()=>{ renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); });

    // viewer example (click logo to preview image)
    const viewer = document.getElementById('viewer'), viewerImg = document.getElementById('viewerImg'), closeViewer = document.getElementById('closeViewer');
    document.getElementById('brandBtn').addEventListener('dblclick', ()=>{
      viewerImg.src = 'https://picsum.photos/900/420?random=7'; viewer.style.display='flex'; viewer.setAttribute('aria-hidden','false');
    });
    closeViewer.addEventListener('click', ()=>{ viewer.style.display='none'; viewer.setAttribute('aria-hidden','true'); });

    // expose small debug (optional) - remove in prod
    window.__sinFiltro = {roadCount: ()=> roadPolylines.length, roadsGroup, buildingsGroup};

  })();
  </script>
</body>
</html>
