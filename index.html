<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Juego de Combate 3D Pro</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #holder { position: absolute; width: 100%; height: 100%; top: 0; left: 0; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; font-size: 24px; z-index: 10; text-align: center;
        }
        #hud, #componentes {
            position: absolute; bottom: 10px; left: 10px; color: #fff; background: rgba(0, 0, 0, 0.6);
            padding: 8px 12px; border-radius: 5px; font-size: 16px; line-height: 1.5; z-index: 5;
            pointer-events: none;
        }
        #componentes { left: auto; right: 10px; }
        #fps { position: absolute; top: 10px; left: 10px; color: #fff; background: rgba(0, 0, 0, 0.6); padding: 5px; border-radius: 3px; z-index: 5; font-size: 14px; }
        .control-pad {
            position: absolute; bottom: 20px;
            width: 150px; height: 150px; border-radius: 50%;
            background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.3);
            display: flex; justify-content: center; align-items: center;
            touch-action: none;
        }
        #stick {
            width: 50px; height: 50px; border-radius: 50%; background: rgba(255, 255, 255, 0.5);
            transition: transform 0.05s;
            pointer-events: none;
        }
        #left-pad { left: 20px; }
        #right-buttons { position: absolute; right: 20px; bottom: 20px; display: flex; flex-direction: column; gap: 10px; }
        .action-button {
            width: 70px; height: 70px; border-radius: 50%; background: rgba(255, 0, 0, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.5); color: white;
            display: flex; justify-content: center; align-items: center;
            font-size: 14px; font-weight: bold; user-select: none;
            transition: opacity 0.3s;
        }
        #fire-button { background: rgba(0, 255, 0, 0.6); }
        #missile-button { background: rgba(0, 0, 255, 0.8); }
        .reloading {
            opacity: 0.4;
            pointer-events: none;
        }
        .reloading::after {
            content: attr(data-cooldown);
            position: absolute;
            font-size: 10px;
            bottom: 5px;
            color: #ccc;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="holder">
        <div id="loading">Cargando experiencia 3D...</div>
    </div>
    
    <div id="hud">
        SALUD: <span id="health-value">100</span>%<br>
        VELOCIDAD: <span id="speed-value">0.0</span> km/h<br>
        MISILES: <span id="missiles-value">3</span>
    </div>
    
    <div id="componentes">
        MOTOR: <span id="motor-health">100</span>%<br>
        CHASIS: <span id="chasis-health">100</span>%
    </div>

    <div id="left-pad" class="control-pad">
        <div id="stick"></div>
    </div>
    <div id="right-buttons">
        <div id="fire-button" class="action-button">FUEGO</div>
        <div id="missile-button" class="action-button" data-cooldown="Listo">MISIL</div>
    </div>
    <div id="fps">FPS: 0</div>


    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // =========================================================================
        // == CONFIGURACI√ìN GLOBAL                                                ==
        // =========================================================================

        const SHADOWS_ENABLED = true;
        const BLOOM_ENABLED = true; 
        const MISSILE_COOLDOWN_MS = 5000; // Recarga de 5 segundos

        // =========================================================================
        // == CLASE CARCONTROLLER (Representa el veh√≠culo)                         ==
        // =========================================================================

        class CarController extends THREE.Group {
            constructor(type = 'Porsche-Pro', isAI = false) { // Usamos 'Porsche-Pro' como tipo por defecto
                super();
                this.userData = {
                    health: 100,
                    maxHealth: 100,
                    speed: 0.0,
                    maxSpeed: 0.25,
                    rotSpeed: 0.05,
                    isDestroyed: false,
                    isAI: isAI,
                    gunOffsets: [new THREE.Vector3(0.5, 0.5, -2.5), new THREE.Vector3(-0.5, 0.5, -2.5)],
                    missileOffset: new THREE.Vector3(0, 1.1, -2.0), // Posici√≥n superior para el misil
                    missiles: 3,
                    maxMissiles: 3,
                    color: isAI ? 0x00ff00 : 0x2A4C8A // Azul oscuro metalizado
                };
                
                this.components = {
                    motor: 100,
                    chasis_frontal: 100,
                    ruedas_traseras: 100
                };

                // --- Geometr√≠a del Porsche Redondeado ---
                const bodyGeo = new THREE.BoxGeometry(2.0, 1.0, 4.0);
                const bodyMat = new THREE.MeshStandardMaterial({ 
                    color: this.userData.color, 
                    metalness: 0.8, 
                    roughness: 0.2 
                });
                
                // Simulaci√≥n de forma redondeada usando un cilindro y una caja
                const mainBody = new THREE.Mesh(bodyGeo, bodyMat);
                mainBody.position.y = 0.5;
                
                // Cilindro para la forma redondeada del techo (estilo Porsche)
                const domeGeo = new THREE.CylinderGeometry(1.0, 1.2, 3.0, 12, 1, true);
                const dome = new THREE.Mesh(domeGeo, bodyMat);
                dome.position.y = 1.0;
                dome.rotation.x = Math.PI / 2;
                dome.scale.z = 0.5; // Comprimir para que parezca un techo redondeado bajo
                
                // Usamos un Group para contener la geometr√≠a
                const visualBody = new THREE.Group();
                visualBody.add(mainBody);
                visualBody.add(dome);
                
                if(SHADOWS_ENABLED) { 
                    mainBody.castShadow = true; mainBody.receiveShadow = true; 
                    dome.castShadow = true; dome.receiveShadow = true; 
                }
                this.add(visualBody);


                const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 12);
                wheelGeo.rotateX(Math.PI / 2);
                const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.1, roughness: 0.9 });

                // Ruedas (simples)
                this.wheels = [];
                const wheelPositions = [
                    [1, 0.4, 1.5], [-1, 0.4, 1.5],
                    [1, 0.4, -1.5], [-1, 0.4, -1.5]
                ];
                for(const pos of wheelPositions) {
                    const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                    wheel.position.set(pos[0], pos[1], pos[2]);
                    if(SHADOWS_ENABLED) wheel.castShadow = true;
                    this.add(wheel);
                    this.wheels.push(wheel);
                }

                // Ajustes por tipo de veh√≠culo
                if (type === 'Porsche-Pro') {
                    this.userData.maxSpeed = 0.30;
                    this.userData.rotSpeed = 0.06;
                    this.userData.color = 0x2A4C8A;
                    bodyMat.color.setHex(0x2A4C8A);
                } else if (type === 'Drift-V') {
                    this.userData.maxSpeed = 0.35;
                    this.userData.rotSpeed = 0.08;
                    this.userData.color = 0xAA00AA;
                    bodyMat.color.setHex(0xAA00AA);
                } else if (type === 'Traffic') {
                    this.userData.maxSpeed = 0.20;
                    this.userData.rotSpeed = 0.04;
                    this.userData.color = 0xAAAAAA;
                    bodyMat.color.setHex(0xAAAAAA);
                }
            }

            getPhysicsModifier() {
                // Modificadores basados en el estado de los componentes
                let maxSpeedMod = this.components.motor / 100;
                let rotSpeedMod = 1.0;
                let turnPenalty = 0;

                if (this.components.ruedas_traseras < 50) {
                    rotSpeedMod *= 0.5; // Gira m√°s lento si las ruedas est√°n da√±adas
                    turnPenalty = 0.02; // Desviaci√≥n en la direcci√≥n
                }
                if (this.components.chasis_frontal < 50) {
                    maxSpeedMod *= 0.8;
                }

                return { maxSpeedMod, rotSpeedMod, turnPenalty };
            }

            update(dt) {
                // Simulaci√≥n de arrastre simple para veh√≠culos AI/Tr√°fico
                this.userData.speed *= 0.98;

                const physics = this.getPhysicsModifier();
                this.userData.speed = Math.max(-this.userData.maxSpeed * 0.5 * physics.maxSpeedMod, Math.min(this.userData.maxSpeed * physics.maxSpeedMod, this.userData.speed));

                const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(this.quaternion);
                this.position.add(fwd.multiplyScalar(this.userData.speed * dt * 0.82));
                
                // Animaci√≥n de ruedas (simple)
                for(const wheel of this.wheels) {
                    wheel.rotation.z += this.userData.speed * 2 * dt;
                }
            }
            
            destroy() {
                this.userData.isDestroyed = true;
                this.userData.speed = 0;
                // Cambio visual a destrozado
                this.children[0].children[0].material.color.setHex(0x333333); // MainBody
                this.children[0].children[1].material.color.setHex(0x333333); // Dome
                // Gira el coche y d√©jalo caer un poco
                this.rotation.z = Math.PI/10;
                this.position.y = 0.1;
            }
        }

        // =========================================================================
        // == CLASE MISSILE (Misil con seguimiento simple)                          ==
        // =========================================================================
        
        class Missile extends THREE.Group {
            constructor() {
                super();
                this.userData = {
                    dir: new THREE.Vector3(),
                    speed: 1.5,
                    damage: 50,
                    owner: null,
                    targetCar: null,
                    isFriendly: false,
                    _spawnTime: 0
                };

                const bodyGeo = new THREE.CylinderGeometry(0.1, 0.25, 1.5, 8);
                const bodyMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9, roughness: 0.1 });
                this.body = new THREE.Mesh(bodyGeo, bodyMat);
                this.body.rotation.x = Math.PI / 2; // Orientaci√≥n
                this.add(this.body);
                
                // Luz de Flama para efecto de rastro (CR√çTICO para el Bloom)
                this.userData.flameLight = new THREE.PointLight(0xffaa00, 30, 5); // Intensidad alta
                this.userData.flameLight.position.set(0, 0, 0.75);
                this.add(this.userData.flameLight);
                
                if(SHADOWS_ENABLED) this.body.castShadow = true;
                
                this.visible = false;
            }

            updateGuidance(dt) {
                if (!this.userData.targetCar || this.userData.targetCar.userData.isDestroyed) {
                    this.userData.speed *= 0.99; // Si pierde objetivo, pierde velocidad
                    return;
                }

                // L√≥gica simple de seguimiento proporcional (navegaci√≥n)
                const targetPos = this.userData.targetCar.position.clone();
                const currentDir = new THREE.Vector3(0, 0, -1).applyQuaternion(this.quaternion).normalize();
                const toTarget = targetPos.sub(this.position).normalize();

                // Interpola la direcci√≥n actual hacia la direcci√≥n del objetivo
                // El '0.05 * dt' controla la velocidad de giro (maniobrabilidad)
                const newDir = currentDir.lerp(toTarget, 0.05 * dt); 
                this.userData.dir.copy(newDir);
                
                // Alinea el misil a la nueva direcci√≥n
                const targetQuaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), newDir);
                this.quaternion.slerp(targetQuaternion, 0.2 * dt);
                
                // Acelera ligeramente hasta un m√°ximo
                this.userData.speed = Math.min(3.5, this.userData.speed + 0.02 * dt);
            }
        }


        // =========================================================================
        // == VARIABLES Y FUNCIONES DE GESTI√ìN DE POOLS                           ==
        // =========================================================================

        let renderer = null;
        let composer = null;
        let isFiring = false;
        let fireInterval = null;
        let OBSTACLES = [];

        let PLAYER_CAR = null;
        const AI_CARS = [];
        const TRAFFIC_CARS = [];
        const BULLET_COOLDOWN_MS = 160;
        const CITY_SIZE = 400;
        const halfCity = CITY_SIZE / 2;
        let missileCooldownTimer = 0;
        let bulletCooldownTimer = 0;


        const bulletPool = [];
        const activeBullets = [];
        const maxBullets = 120;
        
        const impactPool = [];
        const activeImpacts = [];
        const maxImpacts = 50;
        const IMPACT_DURATION = 200;

        const missilePool = [];
        const activeMissiles = [];
        const maxMissiles = 10;
        const MAX_MISSILES_PLAYER = 3;

        // --- Balas ---
        function getBullet() {
            const bullet = bulletPool.find(b => !b.visible);
            if (bullet) { 
                bullet.visible = true; 
                bullet.userData._spawnTime = performance.now(); 
                activeBullets.push(bullet); 
            }
            return bullet;
        }
        function releaseBullet(b) {
            b.visible = false;
            b.position.set(0, -9999, 0);
            b.userData.dir.set(0,0,0);
            const index = activeBullets.indexOf(b);
            if (index > -1) activeBullets.splice(index, 1);
        }
        function spawnBulletsFromCar(targetCar, dir, offsets = null, isFriendly = false){
            const offs = offsets || (targetCar.userData.gunOffsets || []);
            for(const off of offs){
                const b = getBullet();
                if(!b) break;
                const origin = targetCar.position.clone().add(off.clone().applyQuaternion(targetCar.quaternion));
                b.position.copy(origin);
                b.userData.dir.copy(dir);
                b.userData.isFriendly = isFriendly;
                b.userData.owner = targetCar;
            }
        }
        
        // --- Misiles ---
        function getMissile() {
            const missile = missilePool.find(m => !m.visible);
            if (missile) { 
                missile.visible = true; 
                missile.userData._spawnTime = performance.now(); 
                missile.userData.speed = 1.0;
                missile.userData.flameLight.visible = true;
                activeMissiles.push(missile); 
            }
            return missile;
        }
        function releaseMissile(m) {
            m.visible = false;
            m.position.set(0, -9999, 0);
            m.userData.dir.set(0,0,0);
            m.userData.targetCar = null;
            m.userData.flameLight.visible = false;
            const index = activeMissiles.indexOf(m);
            if (index > -1) activeMissiles.splice(index, 1);
        }
        function spawnMissileFromCar(targetCar, isFriendly = false, target = null) {
            if(!targetCar.userData.missileOffset) return false;

            const m = getMissile();
            if(!m) return false;

            const origin = targetCar.position.clone().add(targetCar.userData.missileOffset.clone().applyQuaternion(targetCar.quaternion));
            const dir = new THREE.Vector3(0,0,-1).applyQuaternion(targetCar.quaternion).normalize();

            m.position.copy(origin);
            m.userData.dir.copy(dir);
            m.userData.isFriendly = isFriendly;
            m.userData.owner = targetCar;
            m.userData.targetCar = target; // El objetivo puede ser null al inicio

            return true;
        }

        // --- Impactos ---
        function getImpact(){
            const impact = impactPool.find(b => !b.visible);
            if(impact){ 
                impact.visible = true; 
                impact.userData.spawnTime = performance.now();
                activeImpacts.push(impact); 
            }
            return impact;
        }
        function releaseImpact(impact) {
            impact.visible = false;
            impact.position.set(0, -9999, 0);
            impact.scale.setScalar(1.0);
            impact.userData.mat.opacity = 1.0;
            impact.userData.mat.emissiveIntensity = 10;
            
            const index = activeImpacts.indexOf(impact);
            if (index > -1) activeImpacts.splice(index, 1);
        }
        function createImpact(position, scale = 1.0, color = 0xff3333, intensity = 10){
            const impact = getImpact();
            if(impact){
                impact.position.copy(position);
                impact.userData.spawnTime = performance.now();
                impact.scale.setScalar(scale);
                
                impact.userData.mat.opacity = 1.0;
                impact.userData.mat.emissiveIntensity = intensity;
                impact.userData.mat.color.setHex(color);
                impact.userData.mat.emissive.setHex(color);
            }
        }
        function updateImpacts(now){
            for(let i = activeImpacts.length - 1; i >= 0; i--){
                const impact = activeImpacts[i];
                const age = now - impact.userData.spawnTime;
                
                if(age > IMPACT_DURATION){
                    releaseImpact(impact);
                } else {
                    // Desvanecimiento y escala
                    const alpha = 1.0 - (age / IMPACT_DURATION);
                    impact.userData.mat.opacity = alpha;
                    impact.scale.setScalar(1.0 + (1.0 - alpha) * 2.0); // Crece
                    impact.userData.mat.emissiveIntensity = alpha * 10;
                }
            }
        }


        // =========================================================================
        // == L√ìGICA DE IA Y JUEGO                                                ==
        // =========================================================================

        const TEMP_VECTOR = new THREE.Vector3();

        function updateAICars(dt, target) {
            for(const aiCar of AI_CARS) {
                if(aiCar.userData.isDestroyed) continue;

                // Simple persecuci√≥n
                const toTarget = target.position.clone().sub(aiCar.position);
                const distance = toTarget.length();
                toTarget.normalize();

                const currentFwd = new THREE.Vector3(0, 0, -1).applyQuaternion(aiCar.quaternion).normalize();
                const angle = currentFwd.angleTo(toTarget);

                // Gira
                if (angle > 0.1) {
                    const cross = new THREE.Vector3().crossVectors(currentFwd, toTarget);
                    aiCar.rotation.y += Math.sign(cross.y) * aiCar.userData.rotSpeed * 0.8 * dt;
                }

                // Acelera
                if (distance > 20) {
                    aiCar.userData.speed += 0.015 * dt;
                } else if (distance < 10) {
                    aiCar.userData.speed -= 0.01 * dt; // Reduce velocidad
                }

                // Disparo (simple)
                if (distance < 50 && angle < 0.2 && bulletCooldownTimer <= 0) {
                    spawnBulletsFromCar(aiCar, currentFwd, null, false);
                    bulletCooldownTimer = BULLET_COOLDOWN_MS;
                }
                
                // Misil (IA lo lanza m√°s r√°pido y con precisi√≥n)
                if(aiCar.userData.missiles > 0 && distance < 100 && Math.random() < 0.005) {
                    if(spawnMissileFromCar(aiCar, false, target)) {
                        aiCar.userData.missiles--;
                    }
                }

                aiCar.update(dt);
            }
        }

        function updateTrafficCars(dt) {
            for(const trafficCar of TRAFFIC_CARS) {
                if(trafficCar.userData.isDestroyed) continue;

                // L√≥gica de tr√°fico simple: mover hacia adelante y reorientar en el borde
                if (trafficCar.position.z < -halfCity || trafficCar.position.z > halfCity || trafficCar.position.x < -halfCity || trafficCar.position.x > halfCity) {
                    // Si llega al borde, gira 180 grados
                    trafficCar.rotation.y += Math.PI;
                    trafficCar.userData.speed = 0.1;
                } else {
                    trafficCar.userData.speed = Math.min(trafficCar.userData.maxSpeed, trafficCar.userData.speed + 0.005 * dt);
                }

                trafficCar.update(dt);
            }
        }

        function applyDamage(target, amount, component = 'chasis_frontal'){
            if(target.userData.isDestroyed) return;

            // Da√±o al componente
            if(target.components[component]){
                target.components[component] -= amount;
                if(target.components[component] < 0) target.components[component] = 0;
            }

            // Da√±o a la salud general
            target.userData.health -= amount;
            if(target.userData.health <= 0) {
                target.userData.health = 0;
                target.destroy();
                createImpact(target.position.clone(), 10.0, 0x000000, 0); // Gran impacto visual de destrucci√≥n
            }
        }

        function checkBulletToObstacleCollisions(position, size, damage = 0, isExplosion = false){
            for(const obstacle of OBSTACLES){
                if(
                    position.x + size.x/2 > obstacle.position.x - obstacle.size.x/2 &&
                    position.x - size.x/2 < obstacle.position.x + obstacle.size.x/2 &&
                    position.z + size.z/2 > obstacle.position.z - obstacle.size.z/2 &&
                    position.z - size.z/2 < obstacle.position.z + obstacle.size.z/2 
                ){
                    // Si es una explosi√≥n (misil), creamos un impacto grande, simulando que golpe√≥ el edificio/cobertura
                    if(isExplosion && damage > 0){
                        createImpact(position.clone(), 3.0, 0xFF7700, 5);
                    }
                    return true;
                }
            }
            return false;
        }

        // =========================================================================
        // == FUNCI√ìN DE INICIALIZACI√ìN PRINCIPAL (init)                          ==
        // =========================================================================

        function init() {
            (function(){
                const holder = document.getElementById('holder');
                const UI_COMP_EL = document.getElementById('componentes');
                const missileButton = document.getElementById('missile-button');
                
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x6e8ca0);
                scene.fog = null;

                // --- RENDERER ---
                try {
                    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    renderer.shadowMap.enabled = SHADOWS_ENABLED;
                    if(SHADOWS_ENABLED) renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                    renderer.domElement.style.position = 'absolute';
                    renderer.domElement.style.top = '0';
                    renderer.domElement.style.left = '0';
                    renderer.domElement.style.width = '100%';
                    renderer.domElement.style.height = '100%';
                    renderer.domElement.style.zIndex = '0';

                    holder.appendChild(renderer.domElement);
                    renderer.setClearColor(scene.background);

                    const loadingEl = document.getElementById('loading');
                    if (loadingEl) loadingEl.style.display = 'none';

                } catch (err) {
                    console.error('Error FATAL al crear el contexto WebGL:', err);
                    const loadingEl = document.getElementById('loading');
                    if (loadingEl) loadingEl.textContent = '¬°Error! WebGL no soportado o fall√≥ la inicializaci√≥n.';
                    return;
                }

                const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
                camera.position.set(0, 12, 24);

                if(BLOOM_ENABLED){
                    try{
                        composer = new EffectComposer(renderer);
                        composer.addPass(new RenderPass(scene, camera));
                        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.6, 0.85); 
                        bloomPass.renderToScreen = true;
                        composer.addPass(bloomPass);
                    } catch(e){
                        console.warn("Fallo al inicializar EffectComposer o Bloom. Renderizado simple activo.", e);
                        composer = null;
                    }
                }

                // --- Luces, Entorno y Suelo (Con M√°s Calles/Cobertura) ---
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
                dirLight.position.set(200, 400, 300);
                dirLight.castShadow = SHADOWS_ENABLED;
                if(SHADOWS_ENABLED){ dirLight.shadow.mapSize.width = 1024; dirLight.shadow.mapSize.height = 1024; }
                dirLight.shadow.camera.left = -CITY_SIZE; dirLight.shadow.camera.right = CITY_SIZE; dirLight.shadow.camera.top = CITY_SIZE; dirLight.shadow.camera.bottom = -CITY_SIZE;
                dirLight.shadow.bias = -0.0005;
                scene.add(dirLight);
                scene.add(new THREE.HemisphereLight(0xffffff, 0x080820, 1.0));
                scene.add(new THREE.AmbientLight(0xffffff, 0.5));
                const texLoader = new THREE.TextureLoader();
                const asphaltTex = texLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
                asphaltTex.wrapS = asphaltTex.wrapT = THREE.RepeatWrapping; asphaltTex.repeat.set(30, 30);
                const roadMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.9, metalness: 0.2, map: asphaltTex });
                const ground = new THREE.Mesh(new THREE.PlaneGeometry(CITY_SIZE, CITY_SIZE, 1, 1), roadMat);
                ground.rotation.x = -Math.PI/2; ground.position.y = 0;
                if(SHADOWS_ENABLED) ground.receiveShadow = true;
                scene.add(ground);
                const lineMat = new THREE.MeshBasicMaterial({color:0xffff00});
                const dashedLineGeo = new THREE.PlaneGeometry(0.2, 2);
                for(let i = -CITY_SIZE/2; i < CITY_SIZE/2; i += 6) {
                    const line = new THREE.Mesh(dashedLineGeo, lineMat);
                    line.position.set(0, 0.01, i); line.rotation.x = -Math.PI/2; scene.add(line);
                }
                const buildingTex = texLoader.load('https://threejs.org/examples/textures/brick_diffuse.jpg');
                buildingTex.wrapS = buildingTex.wrapT = THREE.RepeatWrapping; buildingTex.repeat.set(8,2);
                const WALL_THICKNESS = 10; const WALL_HEIGHT = 180;
                const arenaMat = new THREE.MeshStandardMaterial({map: buildingTex, roughness: 0.85, metalness: 0.25});
                function createWall(x, z, sizeX, sizeZ) {
                    const wall = new THREE.Mesh(new THREE.BoxGeometry(sizeX, WALL_HEIGHT, sizeZ), arenaMat);
                    wall.position.set(x, WALL_HEIGHT / 2 + 0.5, z);
                    if(SHADOWS_ENABLED){ wall.castShadow = true; wall.receiveShadow = true; }
                    scene.add(wall);
                    OBSTACLES.push({ position: wall.position.clone(), size: new THREE.Vector3(sizeX, WALL_HEIGHT, sizeZ) });
                }
                // Muros (l√≠mites del mapa)
                createWall(0, -CITY_SIZE/2 - WALL_THICKNESS/2, CITY_SIZE + WALL_THICKNESS * 2, WALL_THICKNESS);
                createWall(0, CITY_SIZE/2 + WALL_THICKNESS/2, CITY_SIZE + WALL_THICKNESS * 2, WALL_THICKNESS);
                createWall(CITY_SIZE/2 + WALL_THICKNESS/2, 0, WALL_THICKNESS, CITY_SIZE);
                createWall(-CITY_SIZE/2 - WALL_THICKNESS/2, 0, WALL_THICKNESS, CITY_SIZE);
                
                // Edificios y Cobertura (M√°s Calles/Obst√°culos T√°cticos)
                function createObstacle(x, z, type){
                    let geo, mat, size;
                    if(type === 'building'){ 
                        size = new THREE.Vector3(20, 30, 20); 
                        geo = new THREE.BoxGeometry(size.x, size.y, size.z); 
                        mat = new THREE.MeshStandardMaterial({color: 0x444488, metalness: 0.5, roughness: 0.5}); // Edificio oscuro/futurista
                    } else { 
                        size = new THREE.Vector3(4, 3, 10); 
                        geo = new THREE.BoxGeometry(size.x, size.y, size.z); 
                        mat = new THREE.MeshStandardMaterial({color: 0xcc9900, metalness: 0.2, roughness: 0.7}); 
                    }
                    const obstacle = new THREE.Mesh(geo, mat);
                    obstacle.position.set(x, size.y / 2, z);
                    if(SHADOWS_ENABLED){ obstacle.castShadow = true; obstacle.receiveShadow = true; }
                    scene.add(obstacle);
                    OBSTACLES.push({ position: obstacle.position.clone(), size: size });
                }
                createObstacle(50, 0, 'container'); createObstacle(-50, 0, 'container'); 
                createObstacle(0, 50, 'building'); // Edificio para cobertura
                createObstacle(0, -50, 'building'); // Edificio para cobertura
                createObstacle(70, 70, 'building');
                createObstacle(-70, -70, 'building');
                createObstacle(40, -40, 'container'); 
                createObstacle(-40, 40, 'container');

                // ---------- VEH√çCULOS ----------
                const car = new CarController('Porsche-Pro', false); // Porsche Redondeado para el jugador
                car.position.set(0, 0, 0);
                scene.add(car);
                PLAYER_CAR = car;

                const ai1 = new CarController('Sport', true);
                ai1.position.set(20, 0, 50); ai1.rotation.y = Math.PI; scene.add(ai1); AI_CARS.push(ai1);

                const ai2 = new CarController('Drift-V', true);
                ai2.position.set(-20, 0, -50); ai2.rotation.y = 0; scene.add(ai2); AI_CARS.push(ai2);

                for(let i = 0; i < 5; i++){
                    const traffic = new CarController('Traffic', true);
                    traffic.position.set((Math.random() < 0.5 ? 1 : -1) * 3, 0, Math.random() * CITY_SIZE*0.8 - CITY_SIZE*0.4);
                    traffic.rotation.y = Math.random() < 0.5 ? 0 : Math.PI;
                    traffic.userData.maxSpeed *= (0.8 + Math.random() * 0.4);
                    TRAFFIC_CARS.push(traffic);
                    scene.add(traffic);
                }

                const state = { forward: 0, turn: 0, turbo: false, speed: car.userData.speed, health: car.userData.health, ammo: car.userData.missiles };

                // Setup Pools
                function setupBulletPool() {
                    const bulletGeo = new THREE.SphereGeometry(0.18, 8, 8);
                    const bulletMat = new THREE.MeshBasicMaterial({ color: 0xff4444, emissive: 0xff0000, emissiveIntensity: 6 });
                    for (let i = 0; i < maxBullets; i++) {
                        const bullet = new THREE.Mesh(bulletGeo, bulletMat);
                        bullet.userData.dir = new THREE.Vector3();
                        bullet.userData.speed = 3.0;
                        bullet.userData.damage = 15;
                        bullet.userData.owner = null;
                        bullet.visible = false;
                        if(SHADOWS_ENABLED) bullet.castShadow = true;
                        scene.add(bullet);
                        bulletPool.push(bullet);
                    }
                }
                function setupMissilePool() {
                    for (let i = 0; i < maxMissiles; i++) {
                        const missile = new Missile();
                        missile.userData.owner = null;
                        missile.visible = false;
                        scene.add(missile);
                        missilePool.push(missile);
                    }
                }
                function setupImpactPool(){
                    const impactGeo = new THREE.SphereGeometry(0.2, 6, 6);
                    const impactMat = new THREE.MeshBasicMaterial({color:0xff3333, emissive: 0xff0000, transparent: true, opacity: 1.0, emissiveIntensity: 10});
                    for(let i=0; i<maxImpacts; i++){
                        const impact = new THREE.Mesh(impactGeo, impactMat.clone());
                        impact.userData.mat = impact.material;
                        impact.userData.spawnTime = 0;
                        impact.visible = false;
                        scene.add(impact);
                        impactPool.push(impact);
                    }
                }
                
                setupBulletPool();
                setupMissilePool();
                setupImpactPool();
                
                // ** === CORRECCI√ìN CR√çTICA DE FREEZE (Pre-compilaci√≥n) === **
                if(renderer){
                    console.log("Forzando pre-compilaci√≥n de shaders para evitar el 'freeze' inicial. üõ†Ô∏è");
                    const tempBullet = getBullet(); const tempMissile = getMissile(); const tempImpact = getImpact();
                    if(composer) { composer.render(); } else { renderer.compile(scene, camera); }
                    if(tempBullet) releaseBullet(tempBullet); if(tempMissile) releaseMissile(tempMissile); if(tempImpact) releaseImpact(tempImpact);
                    console.log("Pre-compilaci√≥n completa. El juego est√° listo para la acci√≥n fluida. üöÄ");
                }
                // ** === FIN DE CORRECCI√ìN CR√çTICA DE FREEZE === **

                function checkCollisions(dt){
                    const targetCars = [...AI_CARS, ...TRAFFIC_CARS];

                    // 1. Colisiones de Balas
                    for(let i=activeBullets.length-1;i>=0;i--){
                        const bullet = activeBullets[i];
                        let hit = false;
                        
                        // Si golpea un borde o un obst√°culo/edificio (COBERTURA)
                        if (Math.abs(bullet.position.x) > halfCity || Math.abs(bullet.position.z) > halfCity) { hit = true; }
                        else if (checkBulletToObstacleCollisions(bullet.position.clone(), new THREE.Vector3(0.2, 0.2, 0.2))) { hit = true; }
                        
                        else {
                            const currentTargets = [...targetCars];
                            if(!bullet.userData.isFriendly) currentTargets.push(PLAYER_CAR); 

                            for(const target of currentTargets){
                                if(target.userData.isDestroyed || target === bullet.userData.owner) continue;

                                if(target.position.distanceTo(bullet.position) < 3.0 && target.userData.health > 0){
                                    const dot = new THREE.Vector3().subVectors(target.position, bullet.position).normalize().dot(new THREE.Vector3(0,0,-1).applyQuaternion(target.quaternion));
                                    let componentHit = 'chasis_frontal';
                                    if (target.components.motor && dot < -0.5) { componentHit = 'motor'; }
                                    else if (target.components.ruedas_traseras && dot > -0.5 && dot < 0.5) { componentHit = 'ruedas_traseras'; }

                                    createImpact(bullet.position.clone());
                                    applyDamage(target, bullet.userData.damage, componentHit);
                                    hit = true;
                                    break;
                                }
                            }
                        }
                        if (hit){ releaseBullet(bullet); }
                    }
                    
                    // 2. Colisiones de Misiles (con Explosi√≥n y Detecci√≥n de Cobertura)
                    for(let i=activeMissiles.length-1;i>=0;i--){
                        const missile = activeMissiles[i];
                        let hit = false;
                        
                        // ** CORRECCI√ìN: Evitar auto-colisi√≥n inmediata (durante los primeros 300ms) **
                        if((performance.now() - missile.userData._spawnTime) < 300) continue; 

                        // Si golpea un borde o un obst√°culo/edificio (COBERTURA)
                        if (Math.abs(missile.position.x) > halfCity || Math.abs(missile.position.z) > halfCity) { hit = true; }
                        else if (checkBulletToObstacleCollisions(missile.position.clone(), new THREE.Vector3(0.5, 0.5, 1.0), missile.userData.damage, true)) { hit = true; } // 'true' para explosi√≥n
                        
                        else {
                            const currentTargets = [...targetCars];
                            if(!missile.userData.isFriendly) currentTargets.push(PLAYER_CAR); 

                            for(const target of currentTargets){
                                if(target.userData.isDestroyed || target === missile.userData.owner) continue;

                                // La distancia de colisi√≥n se aumenta para el misil (√°rea de efecto)
                                if(target.position.distanceTo(missile.position) < 5.0 && target.userData.health > 0){
                                    applyDamage(target, missile.userData.damage * 0.8, 'chasis_frontal');
                                    // Simula la explosi√≥n al golpear el coche
                                    createImpact(missile.position.clone(), 5.0, 0xFF7700, 15);
                                    hit = true;
                                    break;
                                }
                            }
                        }
                        if (hit){ releaseMissile(missile); }
                    }
                    
                    // Colisiones del Coche del Jugador con el Borde
                    if(Math.abs(car.position.x) > halfCity){
                        car.userData.speed *= -0.5;
                        car.position.x = car.position.x > 0 ? halfCity : -halfCity;
                        applyDamage(car, 5, 'chasis_frontal');
                    }
                    if(Math.abs(car.position.z) > halfCity){
                        car.userData.speed *= -0.5;
                        car.position.z = car.position.z > 0 ? halfCity : -halfCity;
                        applyDamage(car, 5, 'chasis_frontal');
                    }
                    state.health = car.userData.health;
                }

                function updateCamera(){
                    const desired = car.position.clone().add(new THREE.Vector3(0,4,12).applyQuaternion(car.quaternion));
                    camera.position.lerp(desired, 0.15);
                    camera.lookAt(car.position.clone().add(new THREE.Vector3(0,1.2,0)));
                }

                function updateHUD(now){
                    document.getElementById('health-value').textContent = Math.max(0, car.userData.health).toFixed(0);
                    document.getElementById('speed-value').textContent = (car.userData.speed * 100).toFixed(1);
                    document.getElementById('missiles-value').textContent = car.userData.missiles;

                    document.getElementById('motor-health').textContent = Math.max(0, car.components.motor).toFixed(0);
                    document.getElementById('chasis-health').textContent = Math.max(0, car.components.chasis_frontal).toFixed(0);
                    
                    // Actualizaci√≥n del bot√≥n de misil y recarga
                    if (missileCooldownTimer > 0) {
                        const remaining = (missileCooldownTimer / 1000).toFixed(1);
                        missileButton.classList.add('reloading');
                        missileButton.setAttribute('data-cooldown', remaining + 's');
                    } else if (car.userData.missiles <= 0) {
                        missileButton.classList.add('reloading');
                        missileButton.setAttribute('data-cooldown', 'AGOTADO');
                    } else {
                        missileButton.classList.remove('reloading');
                        missileButton.setAttribute('data-cooldown', 'Listo');
                    }
                }

                // --- Input (Joystick y Botones) ---
                const stick = { x: 0, y: 0 };
                const pad = document.getElementById('left-pad');
                const stickEl = document.getElementById('stick');
                let padRect = pad.getBoundingClientRect();
                const maxRadius = padRect.width / 2;

                function updateStick(x, y) {
                    const dx = x - padRect.left - maxRadius;
                    const dy = y - padRect.top - maxRadius;
                    const distance = Math.min(maxRadius, Math.sqrt(dx * dx + dy * dy));
                    const angle = Math.atan2(dy, dx);
                    
                    // Normalizar para el estado (de -1 a 1)
                    stick.x = Math.cos(angle) * (distance / maxRadius); // Gira
                    stick.y = -Math.sin(angle) * (distance / maxRadius); // Adelante/Atr√°s

                    // Mover visualmente el stick
                    stickEl.style.transform = `translate(${stick.x * (maxRadius - 25)}px, ${-stick.y * (maxRadius - 25)}px)`;
                }

                function resetStick() {
                    stick.x = 0; stick.y = 0;
                    stickEl.style.transform = `translate(0px, 0px)`;
                }

                pad.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if(e.touches.length > 0) updateStick(e.touches[0].clientX, e.touches[0].clientY);
                }, { passive: false });
                pad.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if(e.touches.length > 0) updateStick(e.touches[0].clientX, e.touches[0].clientY);
                }, { passive: false });
                pad.addEventListener('touchend', resetStick);
                
                window.addEventListener('resize', () => {
                    padRect = pad.getBoundingClientRect();
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    if(composer) composer.setSize(window.innerWidth, window.innerHeight);
                });

                // --- Botones de Acci√≥n ---
                function startFire() {
                    if (isFiring) return;
                    isFiring = true;
                    if(car.userData.isDestroyed) return;
                    
                    const fire = () => {
                        const currentFwd = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion).normalize();
                        spawnBulletsFromCar(car, currentFwd, null, true);
                    };
                    
                    // Dispara inmediatamente y luego usa el intervalo
                    fire(); 
                    fireInterval = setInterval(fire, BULLET_COOLDOWN_MS);
                }
                function stopFire() {
                    isFiring = false;
                    clearInterval(fireInterval);
                    fireInterval = null;
                }

                document.getElementById('fire-button').addEventListener('touchstart', startFire);
                document.getElementById('fire-button').addEventListener('touchend', stopFire);
                
                document.getElementById('missile-button').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if(car.userData.isDestroyed || car.userData.missiles <= 0 || missileCooldownTimer > 0) return;
                    
                    // L√≥gica para encontrar el objetivo m√°s cercano (enemigo m√°s cercano)
                    const target = AI_CARS.find(ai => !ai.userData.isDestroyed && ai.position.distanceTo(car.position) < 150);
                    
                    if(spawnMissileFromCar(car, true, target)) {
                        car.userData.missiles--;
                        missileCooldownTimer = MISSILE_COOLDOWN_MS;
                    }
                });

                // RENDER LOOP
                let last = performance.now(); 
                let frames = 0; 
                let lastFpsTime = performance.now();
                
                function animate(){
                    requestAnimationFrame(animate);

                    const now = performance.now();
                    const deltaTimeMs = now - last;
                    const clampedDeltaMs = Math.min(50, deltaTimeMs); 
                    const dt = clampedDeltaMs / 16.666; // Factor de tiempo (1.0 = 60 FPS)

                    last = now;
                    
                    // Cooldowns
                    if (missileCooldownTimer > 0) missileCooldownTimer -= clampedDeltaMs;
                    if (bulletCooldownTimer > 0) bulletCooldownTimer -= clampedDeltaMs;

                    // ** 1. L√≥gica del Jugador **
                    if(state.health > 0){
                        // Usar el stick para la entrada
                        state.forward = Math.max(-1, Math.min(1, stick.y));
                        state.turn = Math.max(-1, Math.min(1, stick.x));

                        const physicsMod = car.getPhysicsModifier();
                        let maxSpeed = car.userData.maxSpeed * physicsMod.maxSpeedMod; 

                        // Aceleraci√≥n/Desaceleraci√≥n (usando dt)
                        if(state.forward > 0.05) car.userData.speed += 0.018 * state.forward * dt;
                        else if(state.forward < -0.05) car.userData.speed -= 0.03 * (-state.forward) * dt;
                        else car.userData.speed *= 0.96; // Fricci√≥n

                        car.userData.speed = Math.max(-maxSpeed * 0.5, Math.min(maxSpeed, car.userData.speed));
                        state.speed = car.userData.speed;

                        // Rotaci√≥n (usando dt)
                        const currentSpeedFactor = Math.abs(car.userData.speed / car.userData.maxSpeed);
                        let rotationMultiplier = 1;
                        if(currentSpeedFactor > 0.6 && Math.abs(state.turn) > 0.4) rotationMultiplier = 0.5 + 0.5 * (1 - Math.abs(state.turn));

                        car.rotation.y += -state.turn * car.userData.rotSpeed * physicsMod.rotSpeedMod * (0.9 + currentSpeedFactor) * dt * rotationMultiplier;

                        // Movimiento (usando dt)
                        const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion);
                        car.position.add(fwd.multiplyScalar(car.userData.speed * dt * 0.82));
                        
                        // Rotaci√≥n de ruedas
                        for(const wheel of car.wheels) {
                            wheel.rotation.z += car.userData.speed * 2 * dt;
                        }
                    }
                    
                    // ** 2. L√≥gica de AI y Tr√°fico **
                    updateAICars(dt, PLAYER_CAR);
                    updateTrafficCars(dt);
                    
                    // ** 3. L√≥gica de Balas y Misiles **
                    for(let i = activeBullets.length - 1; i >= 0; i--){
                        const bullet = activeBullets[i];
                        bullet.position.addScaledVector(bullet.userData.dir, bullet.userData.speed * dt);
                        if(now - bullet.userData._spawnTime > 3000) releaseBullet(bullet);
                    }
                    
                    for(let i = activeMissiles.length - 1; i >= 0; i--){
                        const missile = activeMissiles[i];
                        missile.updateGuidance(dt); 
                        missile.position.addScaledVector(missile.userData.dir, missile.userData.speed * dt);
                        if(now - missile.userData._spawnTime > 5000) releaseMissile(missile);
                    }
                    
                    checkCollisions(dt); 

                    // ** 4. Actualizaciones de HUD/C√°mara/FPS **
                    updateImpacts(now);
                    updateCamera();
                    updateHUD(now);

                    if(composer){
                        composer.render();
                    } else {
                        renderer.render(scene, camera);
                    }

                    // FPS Counter
                    frames++;
                    if(now - (lastFpsTime || now) >= 1000){
                        lastFpsTime = now;
                        document.getElementById('fps').textContent = `FPS: ${frames}`;
                        frames = 0;
                    }
                }

                animate();
                
            })();
        }

        window.onload = init;
    </script>
</body>
</html>
