<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<title>MiniGTA 2.5D — Demo</title>
<style>
  /* Estilos mínimos para contener el canvas y HUD */
  html,body{height:100%;margin:0;background:#0a0f16;font-family:Inter,system-ui,Arial;color:#eaf7ff}
  #gameWrap{position:relative;height:100vh;overflow:hidden;display:flex;align-items:center;justify-content:center}
  canvas{display:block;background:linear-gradient(#0b1220,#071226);border-radius:10px}
  /* HUD */
  .hud{position:absolute;left:12px;top:12px;z-index:30;display:flex;flex-direction:column;gap:8px}
  .btn{background:rgba(255,255,255,0.04);padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);backdrop-filter:blur(6px);color:#eaf7ff;font-weight:600}
  .miniMap{position:absolute;right:12px;top:12px;width:140px;height:100px;border-radius:8px;overflow:hidden;border:1px solid rgba(255,255,255,0.05);background:rgba(0,0,0,0.6);z-index:30}
  .fps{position:absolute;left:12px;bottom:12px;background:rgba(0,0,0,0.45);padding:6px 8px;border-radius:6px;font-size:12px}
  /* Virtual joystick */
  .joyOuter{position:absolute;left:16px;bottom:16px;width:140px;height:140px;border-radius:50%;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;z-index:30;touch-action:none}
  .joyInner{width:56px;height:56px;border-radius:50%;background:linear-gradient(180deg,rgba(255,255,255,0.06),rgba(255,255,255,0.02));box-shadow:0 8px 20px rgba(0,0,0,0.6)}
  /* Pedal buttons */
  .pedals{position:absolute;right:16px;bottom:16px;display:flex;flex-direction:column;gap:10px;z-index:30}
  .pedal{width:64px;height:64px;border-radius:12px;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,0.03);font-weight:700;color:#eaf7ff}
  /* Responsive canvas size container */
  @media(min-width:900px){
    canvas{width:900px;height:600px}
  }
  @media(max-width:899px){
    canvas{width:100%;height:100%}
  }
</style>
</head>
<body>
<div id="gameWrap">
  <canvas id="game"></canvas>

  <div class="hud">
    <div class="btn" id="btnPause">Pausa</div>
    <div class="btn" id="btnReset">Reiniciar</div>
  </div>

  <div class="miniMap" id="miniMap"></div>

  <div class="fps" id="fps">FPS: --</div>

  <!-- Joystick (izquierda) -->
  <div class="joyOuter" id="joyOuter" aria-hidden="true">
    <div class="joyInner" id="joyInner"></div>
  </div>

  <!-- Pedales (derecha) -->
  <div class="pedals">
    <div class="pedal" id="btnAccel">▲</div>
    <div class="pedal" id="btnBrake">■</div>
  </div>
</div>

<script>
/*
  MiniGTA 2.5D (top-down) - Single-file demo
  - Canvas 2D rendering
  - Player car with simple physics
  - Keyboard controls + virtual joystick + pedals
  - NPC cars with waypoint wander
  - Camera follow + minimap
  - Collision by simple circle approximations
  - Optimized loop, lazy drawing, requestAnimationFrame
*/

/* ------------------ Config ------------------ */
const CONFIG = {
  worldWidth: 3000,
  worldHeight: 2000,
  npcCount: 20,
  targetFPS: 60,
  maxSpeed: 6.2,
  tileSize: 200, // used to draw roads/blocks
  debug: false
};

/* ------------------ Canvas & Context ------------------ */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha: false });
resizeCanvas();

window.addEventListener('resize', resizeCanvas);
function resizeCanvas(){
  // set canvas internal resolution to match displayed size for crispness
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.max(800, Math.floor(rect.width * devicePixelRatio));
  canvas.height = Math.max(600, Math.floor(rect.height * devicePixelRatio));
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}

/* ------------------ Utilities ------------------ */
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function randRange(a,b){ return a + Math.random()*(b-a); }
function lerp(a,b,t){ return a + (b-a)*t; }
function degToRad(d){ return d * Math.PI / 180; }
function radToDeg(r){ return r * 180 / Math.PI; }

/* ------------------ World & Camera ------------------ */
const world = {
  w: CONFIG.worldWidth,
  h: CONFIG.worldHeight,
  roads: [] // we can procedurally create road rectangles
};

const camera = {
  x: 0, y: 0,
  width: 0, height: 0,
  smooth: 0.12
};

function updateCamera(targetX, targetY){
  const vw = canvas.clientWidth;
  const vh = canvas.clientHeight;
  camera.width = vw; camera.height = vh;
  const desiredX = clamp(targetX - vw/2, 0, world.w - vw);
  const desiredY = clamp(targetY - vh/2, 0, world.h - vh);
  camera.x = lerp(camera.x, desiredX, camera.smooth);
  camera.y = lerp(camera.y, desiredY, camera.smooth);
}

/* ------------------ Player (car) ------------------ */
const player = {
  x: world.w/2,
  y: world.h/2,
  angle: 0, // radians, 0 = right
  speed: 0,
  radius: 14,
  width: 36, height: 18,
  accel: 0.18,
  brake: 0.35,
  friction: 0.02,
  turnSpeed: 0.035,
  color: '#00d1ff'
};

/* ------------------ NPCs ------------------ */
let npcs = [];
function createNPC(i){
  const k = {
    id: 'npc'+i,
    x: randRange(200, world.w-200),
    y: randRange(200, world.h-200),
    angle: randRange(0, Math.PI*2),
    speed: randRange(1.2, 3.2),
    color: ['#8a6eff','#ff5fb7','#ffd166'][i%3],
    radius: 14,
    width: 34,
    height: 16,
    target: null,
    changeTimer: randRange(1.2, 4.5)
  };
  k.target = { x: clamp(k.x + randRange(-400,400), 50, world.w-50), y: clamp(k.y + randRange(-300,300), 50, world.h-50) };
  return k;
}

/* ------------------ Generate simple city/grid (roads) ------------------ */
function buildCity(){
  // We'll create a grid of blocks with roads between
  const blockW = CONFIG.tileSize;
  const blockH = CONFIG.tileSize;
  const cols = Math.ceil(world.w / blockW);
  const rows = Math.ceil(world.h / blockH);
  world.roads = [];
  // create vertical & horizontal roads
  for(let c=0;c<cols;c++){
    const x = c * blockW + blockW/2;
    world.roads.push({ x: x, y: 0, w: Math.max(80, blockW/3), h: world.h }); // vertical road strip
  }
  for(let r=0;r<rows;r++){
    const y = r * blockH + blockH/2;
    world.roads.push({ x: 0, y: y, w: world.w, h: Math.max(80, blockH/3) }); // horizontal road strip
  }
}

/* ------------------ Input Handling ------------------ */
/* Keyboard */
const keys = {};
window.addEventListener('keydown', e=> { keys[e.key.toLowerCase()] = true; });
window.addEventListener('keyup', e=> { keys[e.key.toLowerCase()] = false; });

/* Joystick (touch) */
const joyOuter = document.getElementById('joyOuter');
const joyInner = document.getElementById('joyInner');
let joyState = { active:false, startX:0, startY:0, dx:0, dy:0, nx:0, ny:0 };

joyOuter.addEventListener('touchstart', e=>{
  const t = e.touches[0];
  joyState.active = true;
  const rect = joyOuter.getBoundingClientRect();
  joyState.startX = t.clientX - rect.left;
  joyState.startY = t.clientY - rect.top;
  joyState.dx = 0; joyState.dy = 0;
}, {passive:true});
joyOuter.addEventListener('touchmove', e=>{
  if(!joyState.active) return;
  const t = e.touches[0];
  const rect = joyOuter.getBoundingClientRect();
  joyState.dx = (t.clientX - rect.left) - joyState.startX;
  joyState.dy = (t.clientY - rect.top) - joyState.startY;
  // normalize to -1..1
  const maxR = rect.width/2 - 10;
  joyState.nx = clamp(joyState.dx / maxR, -1, 1);
  joyState.ny = clamp(joyState.dy / maxR, -1, 1);
  // move inner indicator
  joyInner.style.transform = `translate(${joyState.nx*40}px, ${joyState.ny*40}px)`;
  e.preventDefault();
}, {passive:false});
joyOuter.addEventListener('touchend', e=>{
  joyState.active = false; joyState.dx = 0; joyState.dy = 0; joyState.nx = 0; joyState.ny = 0;
  joyInner.style.transform = `translate(0,0)`;
});

/* Pedal buttons */
let pedalAccel = false, pedalBrake = false;
document.getElementById('btnAccel').addEventListener('touchstart', ()=> pedalAccel=true, {passive:true});
document.getElementById('btnAccel').addEventListener('touchend', ()=> pedalAccel=false, {passive:true});
document.getElementById('btnBrake').addEventListener('touchstart', ()=> pedalBrake=true, {passive:true});
document.getElementById('btnBrake').addEventListener('touchend', ()=> pedalBrake=false, {passive:true});
/* Also mouse click for desktop */
document.getElementById('btnAccel').addEventListener('mousedown', ()=> pedalAccel=true);
document.getElementById('btnAccel').addEventListener('mouseup', ()=> pedalAccel=false);
document.getElementById('btnBrake').addEventListener('mousedown', ()=> pedalBrake=true);
document.getElementById('btnBrake').addEventListener('mouseup', ()=> pedalBrake=false);

/* Buttons: Pause/Reset */
let paused = false;
document.getElementById('btnPause').addEventListener('click', ()=> { paused = !paused; document.getElementById('btnPause').textContent = paused ? 'Reanudar' : 'Pausa'; });
document.getElementById('btnReset').addEventListener('click', resetPlayer);

/* ------------------ Physics & Movement ------------------ */
function updatePlayer(dt){
  // Controls: keyboard arrows/WASD, joystick, pedals
  const forward = keys['arrowup'] || keys['w'] || pedalAccel || false;
  const backward = keys['arrowdown'] || keys['s'] || pedalBrake || false;
  const left = keys['arrowleft'] || keys['a'] || (joyState.nx < -0.35);
  const right = keys['arrowright'] || keys['d'] || (joyState.nx > 0.35);

  // joystick vertical controls acceleration/brake too
  const joyForward = (joyState.ny < -0.35);
  const joyBack = (joyState.ny > 0.35);

  let acc = 0;
  if(forward || joyForward) acc += player.accel;
  if(backward || joyBack) acc -= player.brake;

  // apply acceleration into speed in local forward direction
  player.speed += acc * dt * 60; // scale by frame
  // apply friction
  player.speed *= (1 - player.friction * dt * 60);
  // clamp
  player.speed = clamp(player.speed, -CONFIG.maxSpeed/1.6, CONFIG.maxSpeed);

  // turning when moving - scale with speed magnitude
  const turning = (left ? -1 : 0) + (right ? 1 : 0);
  // if joystick used, override turning with nx sign for finer control
  if(Math.abs(joyState.nx) > 0.12) {
    // turning proportional
    const sign = Math.sign(joyState.nx);
    player.angle += sign * 0.04 * dt * 60 * Math.min(1, Math.abs(joyState.nx));
  } else {
    player.angle += turning * player.turnSpeed * dt * 60 * (0.5 + Math.abs(player.speed)/CONFIG.maxSpeed);
  }

  // update position
  player.x += Math.cos(player.angle) * player.speed * dt * 60;
  player.y += Math.sin(player.angle) * player.speed * dt * 60;

  // stay in bounds
  player.x = clamp(player.x, 16, world.w - 16);
  player.y = clamp(player.y, 16, world.h - 16);
}

/* ------------------ NPC AI ------------------ */
function updateNPC(n, dt){
  // move toward target
  const dx = n.target.x - n.x;
  const dy = n.target.y - n.y;
  const dist = Math.hypot(dx,dy);
  if(dist < 40 || (n.changeTimer -= dt) < 0){
    // pick a new target
    n.target.x = clamp(n.x + randRange(-600,600), 40, world.w-40);
    n.target.y = clamp(n.y + randRange(-500,500), 40, world.h-40);
    n.changeTimer = randRange(2.2,5.5);
  } else {
    const desired = Math.atan2(dy,dx);
    // rotate slowly towards desired
    let diff = desired - n.angle;
    diff = ((diff + Math.PI) % (Math.PI*2)) - Math.PI;
    n.angle += clamp(diff, -0.03, 0.03);
    // move forward
    n.x += Math.cos(n.angle) * n.speed * dt * 60;
    n.y += Math.sin(n.angle) * n.speed * dt * 60;
    // keep in bounds
    n.x = clamp(n.x, 20, world.w-20);
    n.y = clamp(n.y, 20, world.h-20);
  }
}

/* ------------------ Collisions (simple circles) ------------------ */
function checkCollisions(){
  // player vs NPCs
  for(let i=0;i<npcs.length;i++){
    const n = npcs[i];
    const dx = n.x - player.x, dy = n.y - player.y;
    const d = Math.hypot(dx,dy);
    if(d < n.radius + player.radius){
      // simple collision response: separate and reduce speed
      const overlap = n.radius + player.radius - d + 0.5;
      const nx = dx / (d || 1), ny = dy / (d || 1);
      player.x -= nx * overlap * 0.6;
      player.y -= ny * overlap * 0.6;
      // bounce back a bit
      player.speed *= -0.2;
      n.x += nx * overlap * 0.4;
      n.y += ny * overlap * 0.4;
    }
  }
}

/* ------------------ Rendering ------------------ */
function worldToScreen(wx,wy){
  // convert world coordinates to screen using camera
  return { sx: wx - camera.x, sy: wy - camera.y };
}

function drawBackground(){
  // draw blocks (darker) and roads (lighter)
  ctx.fillStyle = '#071226';
  ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);

  // draw road strips
  ctx.save();
  ctx.translate(-camera.x, -camera.y);
  ctx.globalCompositeOperation = 'source-over';
  // subtle grid of blocks
  const bs = CONFIG.tileSize;
  for(let gx=0; gx<world.w; gx+=bs){
    for(let gy=0; gy<world.h; gy+=bs){
      // block rect
      ctx.fillStyle = '#06121a';
      ctx.fillRect(gx, gy, bs-40, bs-40);
    }
  }
  // roads
  ctx.fillStyle = '#0b1b28';
  world.roads.forEach(r=>{
    ctx.fillRect(r.x - r.w/2, r.y - r.h/2, r.w, r.h);
  });
  ctx.restore();
}

function drawCar(x,y,angle,w,h,color, opts = {}){
  ctx.save();
  ctx.translate(x - camera.x, y - camera.y);
  ctx.rotate(angle);
  // body
  ctx.fillStyle = color;
  roundRect(ctx, -w/2, -h/2, w, h, 4);
  ctx.fill();
  // windows highlight
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  roundRect(ctx, -w/4, -h/2+2, w/2, h/2, 2);
  ctx.fill();
  ctx.restore();
}

/* helper rounded rect */
function roundRect(ctx, x, y, w, h, r){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
}

/* draw NPCs and player */
function renderScene(){
  // background
  drawBackground();

  // draw NPCs (behind roads? we just draw)
  npcs.forEach(n=>{
    drawCar(n.x, n.y, n.angle, n.width, n.height, n.color);
  });

  // draw player
  drawCar(player.x, player.y, player.angle, player.width, player.height, player.color);
}

/* HUD: minimap */
const miniCanvas = document.createElement('canvas');
miniCanvas.width = 280; miniCanvas.height = 200;
const miniCtx = miniCanvas.getContext('2d');
document.getElementById('miniMap').appendChild(miniCanvas);

function renderMiniMap(){
  const mmw = miniCanvas.width, mmh = miniCanvas.height;
  miniCtx.clearRect(0,0,mmw,mmh);
  // background
  miniCtx.fillStyle = '#021018';
  miniCtx.fillRect(0,0,mmw,mmh);
  const scaleX = mmw / world.w, scaleY = mmh / world.h;
  // draw roads (approx)
  miniCtx.fillStyle = '#12323a';
  world.roads.forEach(r=>{
    miniCtx.fillRect((r.x - r.w/2)*scaleX, (r.y - r.h/2)*scaleY, r.w*scaleX, r.h*scaleY);
  });
  // draw npcs
  npcs.forEach(n=>{
    miniCtx.fillStyle = n.color;
    miniCtx.fillRect(n.x*scaleX - 2, n.y*scaleY - 2, 4,4);
  });
  // player
  miniCtx.fillStyle = '#00d1ff';
  miniCtx.fillRect(player.x*scaleX - 3, player.y*scaleY - 3, 6,6);
}

/* ------------------ Game loop ------------------ */
let lastTime = performance.now();
let fpsCounter = { frames:0, last: performance.now(), value:0 };

function loop(now){
  if(paused){ lastTime = now; requestAnimationFrame(loop); return; }
  const dt = Math.min(0.05, (now - lastTime) / 1000);
  lastTime = now;

  // update
  updatePlayer(dt);
  for(let n of npcs) updateNPC(n, dt);
  checkCollisions();
  updateCamera(player.x, player.y);

  // render
  ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);
  renderScene();
  renderMiniMap();

  // fps
  fpsCounter.frames++;
  if(now - fpsCounter.last > 500){
    fpsCounter.value = Math.round((fpsCounter.frames*1000) / (now - fpsCounter.last));
    fpsCounter.frames = 0;
    fpsCounter.last = now;
    document.getElementById('fps').textContent = `FPS: ${fpsCounter.value}`;
  }

  requestAnimationFrame(loop);
}

/* ------------------ Init & helpers ------------------ */
function init(){
  buildCity();
  // spawn NPCs
  npcs = [];
  for(let i=0;i<CONFIG.npcCount;i++) npcs.push(createNPC(i));
  // position player in center roads
  player.x = world.w/2 + randRange(-200,200);
  player.y = world.h/2 + randRange(-100,100);
  player.angle = randRange(0, Math.PI*2);
  player.speed = 0;
  camera.x = player.x - canvas.clientWidth / 2;
  camera.y = player.y - canvas.clientHeight / 2;
  requestAnimationFrame(loop);
}

/* reset player */
function resetPlayer(){
  player.x = world.w/2; player.y = world.h/2; player.angle = 0; player.speed = 0;
}

/* seed for reproducible behavior if needed (not strictly necessary) */
// Math.seedrandom && Math.seedrandom('sinfiltro'); // optional if seedrandom included

/* ------------------ Drag scrolling for horizontal rows (not needed here but demo) ------------------ */
/* (Kept for compatibility with your earlier web app concepts) */

/* ------------------ Start game ------------------ */
init();

/* Expose some for console testing (optional) */
window.__miniGTA = { player, npcs, world, camera, init };

/* ------------------ Notes & Next Steps (ideas to extend) ------------------
 - Añadir colisiones por rectángulos rotados si se desea precisión
 - Reemplazar shapes por sprites / tiles para estética
 - Añadir disparos, armas y efectos particles (canvas or WebGL)
 - Multijugador simple: usar WebSocket / WebRTC para posición de players
 - Guardado local de vehículos, upgrades, skins
 - Mejorar IA: pathfinding A* sobre navmesh/grid
 - Optimización: chunking/visible region for thousands of entities
----------------------------------------------------------------------- */
</script>
</body>
</html>
