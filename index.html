<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Arena de Combate 3D (v1.1 - Avocado Ajustado)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: #fff; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #info {
            position: absolute; top: 10px; left: 10px; padding: 10px;
            background-color: rgba(0, 0, 0, 0.7); border-radius: 5px;
            max-width: 300px; font-size: 14px;
        }
        #info h3 { margin-top: 0; color: #cc00cc; }
        .stat { margin-bottom: 5px; }
        .gauge-container { width: 100%; height: 10px; background-color: #333; border-radius: 3px; margin-top: 2px; }
        .gauge { height: 100%; border-radius: 3px; transition: width 0.1s; }
        #health-gauge { background-color: #00ff00; }
        #ammo-gauge { background-color: #00aaff; }
        #componentes-list { margin-top: 10px; border-top: 1px solid #333; padding-top: 5px; }
        .comp-item { display: flex; justify-content: space-between; font-size: 12px; margin-top: 3px; }
        .ok { color: #00ff00; }
        .danado { color: #ffaa00; }
        .critico { color: #ff5500; }
        .destruido { color: #ff0000; font-weight: bold; }
        #loading-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.9); display: flex;
            justify-content: center; align-items: center; z-index: 1000;
            font-size: 20px;
        }
    </style>
</head>
<body>
    <div id="loading-overlay">Cargando Modelo 3D: Avocado.glb...</div>
    <div id="info">
        <h3>Drift-V - Estado de Combate</h3>
        <div class="stat">
            Vida: <span id="health-value">100</span>%
            <div class="gauge-container"><div id="health-gauge" class="gauge"></div></div>
        </div>
        <div class="stat">
            Munición: <span id="ammo-value">12</span>
            <div class="gauge-container"><div id="ammo-gauge" class="gauge"></div></div>
        </div>
        <div class="stat">Velocidad: <span id="speed-value">0.0</span> km/h</div>
        <h4>Componentes:</h4>
        <div id="componentes-list">
            </div>
    </div>
    
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
        import { EffectComposer } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
        
        // =========================================================================
        // == CONFIGURACIÓN GLOBAL Y CARGA DE MODELO (GLTF)                     ==
        // =========================================================================
        
        // La ruta asume que Avocado.glb está en la misma carpeta que el HTML.
        const DRIFT_V_MODEL_PATH = 'Avocado.glb'; 

        const MAX_ENEMIES = 4;
        const MAX_TRAFFIC = 6;
        const MAP_SIZE = 100;
        const SHADOWS_ENABLED = true;
        const BLOOM_ENABLED = true;
        
        let gameReady = false; 

        const clock = new THREE.Clock();
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        if(SHADOWS_ENABLED){
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
        }

        let composer;
        if(BLOOM_ENABLED){
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
        } else {
            composer = { render: (delta) => renderer.render(scene, camera) };
        }


        // =========================================================================
        // == VEHICLE STATS (Estadísticas Compartidas)                          ==
        // =========================================================================
        const VEHICLE_STATS = {
            'Muscle Car': { color: 0x880000, width: 2.8, length: 5.0, height: 1.0, health: 100, maxSpeed: 1.2, rotSpeed: 0.040, maxAmmo: 15, geometry: 'Box' },
            'Sport': { color: 0x223388, width: 2.2, length: 4.0, height: 0.8, health: 80, maxSpeed: 1.4, rotSpeed: 0.055, maxAmmo: 10, geometry: 'Box' },
            'Pickup': { color: 0x336633, width: 3.2, length: 5.5, height: 1.2, health: 150, maxSpeed: 0.9, rotSpeed: 0.030, maxAmmo: 20, geometry: 'Box' },
            'Drift-V': { color: 0xcc00cc, width: 2.0, length: 4.5, height: 0.9, health: 90, maxSpeed: 1.6, rotSpeed: 0.065, geometry: 'GLTF', gltfUrl: DRIFT_V_MODEL_PATH, maxAmmo: 12 },
            'Traffic': { color: 0xaaaaaa, width: 2.5, length: 4.5, height: 1.0, health: 50, maxSpeed: 0.7, rotSpeed: 0.020, maxAmmo: 0, geometry: 'Box' }
        };
        
        let loadedDriftVModel = null;


        // =========================================================================
        // == CLASE CARCONTROLLER (Con soporte para GLTF)                        ==
        // =========================================================================

        class CarController extends THREE.Group {
            constructor(type, isAI) {
                super();
                const stats = VEHICLE_STATS[type];

                this.userData.isAI = isAI;
                this.userData.type = type;
                this.userData.maxHealth = stats.health;
                this.userData.health = stats.health;
                this.userData.maxAmmo = stats.maxAmmo;
                this.userData.ammo = stats.maxAmmo;
                this.userData.maxSpeed = stats.maxSpeed;
                this.userData.rotSpeed = stats.rotSpeed;
                this.userData.speed = 0;
                this.userData.isDestroyed = false;
                this.userData.aiState = 'roam'; 
                this.userData.target = null; 
                this.userData.timeSinceLastShot = 0; 
                this.userData.fireRate = 0.5;
                this.userData.nextRoamPoint = null;
                this.userData.bodyParts = [];

                this.userData.gunOffsets = [];

                this.componentes = {
                    motor: { vida: 100, max: 100, estado: 'OK', efecto: 'Potencia' },
                    ruedas_traseras: { vida: 100, max: 100, estado: 'OK', efecto: 'Tracción' },
                    sistema_punteria: { vida: 100, max: 100, estado: 'OK', efecto: 'Precisión' },
                    chasis_frontal: { vida: 100, max: 100, estado: 'OK', efecto: 'Blindaje' }
                };
                if (type === 'Traffic') {
                    this.componentes = { chasis: { vida: 100, max: 100, estado: 'OK', efecto: 'Estructura' } };
                    this.userData.isTraffic = true;
                } else {
                    this.userData.isTraffic = false;
                }

                if (stats.geometry !== 'GLTF' || loadedDriftVModel) {
                    this.buildMesh(stats);
                }

                if(isAI && stats.geometry !== 'GLTF'){
                    const hbMat = new THREE.MeshBasicMaterial({color:0x00ff00, transparent: true, opacity: 0.8});
                    const hbGeo = new THREE.BoxGeometry(stats.width * 0.8, 0.1, 0.08);
                    const healthBar = new THREE.Mesh(hbGeo, hbMat);
                    healthBar.position.y = 2.0;
                    healthBar.rotation.y = Math.PI/2;
                    this.userData.healthBar = healthBar;
                    this.add(healthBar);
                    if(SHADOWS_ENABLED) healthBar.receiveShadow = false;
                }
            }

            buildMesh(stats) {
                
                if(stats.geometry === 'GLTF'){
                    // =============================================================
                    // == MODELO GLTF (Para Drift-V - Avocado)                   ==
                    // =============================================================
                    if (loadedDriftVModel) {
                        const model = loadedDriftVModel.clone();
                        
                        // *** AJUSTE FINAL PARA AVOCADO.GLB ***
                        // Escala y orientación probadas para que sea similar a los Box cars.
                        model.scale.set(50, 50, 50); // Escala para el modelo Avocado
                        model.rotation.y = Math.PI; // Orientación
                        model.position.y = 0.5; // Sobre el suelo
                        // *******************************************************
                        
                        this.add(model);
                        this.userData.body = model;
                        this.userData.bodyParts.push(model); 
                        
                        if(SHADOWS_ENABLED){
                            model.traverse(child => { 
                                if(child.isMesh) {
                                    child.castShadow = true; 
                                    child.receiveShadow = true; 
                                } 
                            });
                        }
                    } else {
                        console.warn("Modelo GLTF no cargado, usando Box temporal.");
                        this.createBoxBody(stats);
                    }

                } else {
                    // =============================================================
                    // == MODELO BÁSICO: Box (Otros vehículos)                   ==
                    // =============================================================
                    this.createBoxBody(stats);
                }
                
                this.createGuns(stats);
                this.createWheels(stats);
                this.createTailLights(stats);
            }

            createBoxBody(stats) {
                const bodyMat = new THREE.MeshStandardMaterial({color:stats.color, metalness:0.9, roughness:0.15});
                const bodyGeo = new THREE.BoxGeometry(stats.width, stats.height, stats.length);
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = stats.height / 2 + 0.5;
                if(SHADOWS_ENABLED) body.castShadow = true;
                this.add(body);
                this.userData.body = body;
                this.userData.bodyParts.push(body);
            }

            createWheels(stats){
                const wheelGeo = new THREE.CylinderGeometry(0.5, 0.5, stats.width * 0.25, 12);
                const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9, metalness: 0.1 });

                const wheelData = [
                    { x: stats.width / 2 + 0.1, z: stats.length / 2 - 0.7 },
                    { x: -stats.width / 2 - 0.1, z: stats.length / 2 - 0.7 },
                    { x: stats.width / 2 + 0.1, z: -stats.length / 2 + 0.7 },
                    { x: -stats.width / 2 - 0.1, z: -stats.length / 2 + 0.7 }
                ];

                for (const pos of wheelData) {
                    const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(pos.x, 0.5, pos.z);
                    if(SHADOWS_ENABLED) wheel.castShadow = true;
                    this.add(wheel);
                }
            }
            
            createTailLights(stats){
                const tailLightMat = new THREE.MeshBasicMaterial({color:0xff0000, emissive: 0xff0000, emissiveIntensity: 1.5});
                const tailLightGeo = new THREE.BoxGeometry(stats.width * 0.7, 0.3, 0.1);
                const tailLights = new THREE.Mesh(tailLightGeo, tailLightMat);
                tailLights.position.set(0, 1.0, stats.length/2 - 0.05);
                this.add(tailLights);
                this.userData.tailLights = tailLights;
            }
            
            createGuns(stats){
                // Cañones delanteros - AJUSTADOS PARA MODELO GLTF (Avocado)
                if (!this.userData.isTraffic) {
                    const gunMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.95, roughness: 0.3 });

                    // Posiciones ajustadas para estar más abajo y más separados.
                    const frontZ = -stats.length / 2 + 0.5; 
                    const gunY = 0.9; // Más cerca del suelo
                    const xSpread = stats.width / 2 + 0.5; // Más separados

                    // AK-47 Derecha
                    const ak47_R = new THREE.Group();
                    const barrelR_geo = new THREE.CylinderGeometry(0.08, 0.1, 1.2, 8);
                    const barrelR = new THREE.Mesh(barrelR_geo, gunMat);
                    barrelR.rotation.x = Math.PI / 2;
                    barrelR.position.set(0, 0, 0.6);
                    ak47_R.add(barrelR);
                    
                    // Nueva posición derecha
                    ak47_R.position.set(xSpread, gunY, frontZ); 
                    ak47_R.rotation.y = Math.PI;
                    ak47_R.rotation.x = -0.1;
                    if(SHADOWS_ENABLED) ak47_R.traverse(child => { if(child.isMesh) child.castShadow = true; });
                    this.add(ak47_R);

                    // AK-47 Izquierda (clonar y ajustar posición)
                    const ak47_L = ak47_R.clone();
                    // Nueva posición izquierda
                    ak47_L.position.x = -xSpread; 
                    this.add(ak47_L);

                    // Guardar offsets locales para disparar desde ambas armas
                    this.userData.gunOffsets.push(new THREE.Vector3(xSpread, gunY, frontZ - 0.6));
                    this.userData.gunOffsets.push(new THREE.Vector3(-xSpread, gunY, frontZ - 0.6));
                }
            }


            applyDamage(amount, componentKey = 'chasis_frontal') {
                if (this.userData.health <= 0 || this.userData.isDestroyed) return false;

                const comp = this.componentes[componentKey];
                if (comp && comp.vida > 0) {
                    comp.vida -= amount;
                    comp.vida = Math.max(0, comp.vida);
                    if (comp.vida <= 0) comp.estado = 'DESTRUIDO';
                    else if (comp.vida <= 30) comp.estado = 'CRÍTICO';
                    else if (comp.vida <= 60) comp.estado = 'DAÑADO';
                    else comp.estado = 'OK';
                }

                this.userData.health -= amount * 0.5;
                this.userData.health = Math.max(0, this.userData.health);

                const partsToFlash = this.userData.bodyParts.filter(p => p.material || p.isGroup);

                partsToFlash.forEach(part => {
                     if (part.isMesh && part.material) {
                        if (typeof part.material.opacity === 'undefined') { part.material.transparent = true; part.material.opacity = 1.0; }
                        if (part.material.opacity > 0) {
                            part.material.color.setHex(0xaaaaaa);
                            if(this.userData.tailLights && this.userData.tailLights.material) this.userData.tailLights.material.emissiveIntensity = 5;
                            setTimeout(() => {
                                if(this.userData.health > 0){
                                    part.material.color.setHex(VEHICLE_STATS[this.userData.type].color);
                                    if(this.userData.tailLights && this.userData.tailLights.material) this.userData.tailLights.material.emissiveIntensity = 1.5;
                                }
                            }, 80);
                        }
                    }
                });

                if (this.userData.health <= 0 && !this.userData.isDestroyed) {
                    this.destroyVehicle();
                    return true;
                }
                return false;
            }

            destroyVehicle() {
                this.userData.isDestroyed = true;
                this.userData.speed = 0;
                
                const partsToDestroy = this.userData.bodyParts.filter(p => p.isMesh);

                partsToDestroy.forEach(part => {
                    if (part && part.material) {
                        part.material.transparent = true;
                        part.material.opacity = 0.5;
                        part.material.color.setHex(0x333333);
                    }
                });
                
                if(this.userData.body && this.userData.body.isGroup){
                    this.userData.body.traverse(child => {
                        if(child.isMesh && child.material) child.material.transparent = true;
                    });
                }


                if(this.userData.tailLights) this.userData.tailLights.material.emissiveIntensity = 0.1;

                if(this.userData.healthBar) this.userData.healthBar.visible = false;

                const decayInterval = setInterval(() => {
                    partsToDestroy.forEach(part => {
                        if (part && part.material && part.material.opacity > 0.01) {
                            part.material.opacity *= 0.98;
                        }
                    });
                    
                    if(this.userData.body && this.userData.body.isGroup){
                        this.userData.body.traverse(child => {
                            if(child.isMesh && child.material && child.material.opacity > 0.01) child.material.opacity *= 0.98;
                        });
                    }
                    
                    if (this.userData.body && (this.userData.body.material && this.userData.body.material.opacity < 0.1 || this.userData.body.isGroup && this.userData.body.children.length > 0 && this.userData.body.children[0].material.opacity < 0.1)) {
                        clearInterval(decayInterval);
                        this.position.y = -100; 
                        this.userData.body.visible = false;
                    }
                }, 100);
            }

            getPhysicsModifier() {
                if(this.userData.isDestroyed) return { maxSpeedMod: 0, rotSpeedMod: 0 };

                let maxSpeedMod = 1.0;
                let rotSpeedMod = 1.0;

                if(this.userData.isTraffic) return { maxSpeedMod: 1.0, rotSpeedMod: 1.0 };

                const motor = this.componentes.motor;
                const ruedas = this.componentes.ruedas_traseras;
                const chasis = this.componentes.chasis_frontal;

                if (motor && motor.estado !== 'OK') { maxSpeedMod *= 0.5 + (motor.vida / 100) * 0.5; }
                if (ruedas && ruedas.estado !== 'OK') { rotSpeedMod *= 0.3 + (ruedas.vida / 100) * 0.7; }
                if (chasis && (chasis.estado === 'CRÍTICO' || chasis.estado === 'DESTRUIDO')) { this.userData.speed *= 0.95; }

                return { maxSpeedMod, rotSpeedMod };
            }
        }

        // =========================================================================
        // == CLASE PROJECTILE (Munición)                                       ==
        // =========================================================================
        class Projectile extends THREE.Mesh {
            constructor(position, direction) {
                const geo = new THREE.SphereGeometry(0.1, 8, 8);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 5.0 });
                super(geo, mat);

                this.position.copy(position);
                this.userData.velocity = direction.clone().multiplyScalar(40);
                this.userData.damage = 10;
                this.userData.life = 3; 
                this.userData.time = 0;
            }

            update(delta) {
                this.position.add(this.userData.velocity.clone().multiplyScalar(delta));
                this.userData.time += delta;
                
                if (this.userData.time > this.userData.life) {
                    this.removeFromParent();
                    return true;
                }
                return false;
            }
        }

        // =========================================================================
        // == Carga de Modelo GLTF e Inicio del Juego                           ==
        // =========================================================================

        function loadGLTFModel() {
            const loader = new GLTFLoader();
            loader.load(
                DRIFT_V_MODEL_PATH,
                (gltf) => {
                    loadedDriftVModel = gltf.scene;
                    console.log(`Modelo GLTF (${DRIFT_V_MODEL_PATH}) cargado con éxito.`);
                    document.getElementById('loading-overlay').style.display = 'none';
                    startGame();
                },
                (xhr) => {
                    const percent = (xhr.loaded / xhr.total) * 100;
                    document.getElementById('loading-overlay').textContent = `Cargando Modelo 3D: ${Math.round(percent)}%`;
                },
                (error) => {
                    console.error('Error al cargar el modelo GLTF. Usando Box temporal.', error);
                    document.getElementById('loading-overlay').textContent = 'Error de carga. Usando modelo básico.';
                    setTimeout(startGame, 2000); 
                }
            );
        }

        function startGame() {
            setupScene();
            initEntities();
            setupControls();
            gameReady = true;
            animate();
        }

        // =========================================================================
        // == INICIALIZACIÓN DE LA ESCENA                                       ==
        // =========================================================================

        function setupScene() {
            scene.background = new THREE.Color(0x333344);

            const ambient = new THREE.AmbientLight(0xffffff, 0.4); scene.add(ambient);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(20, 50, 20); 
            
            if(SHADOWS_ENABLED){
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 4096;
                directionalLight.shadow.mapSize.height = 4096;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 100;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.top = 50;
                directionalLight.shadow.camera.bottom = -50;
                directionalLight.shadow.bias = -0.001; 
            }
            scene.add(directionalLight);

            const groundGeo = new THREE.PlaneGeometry(MAP_SIZE * 2, MAP_SIZE * 2);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x222222, side: THREE.DoubleSide });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            if(SHADOWS_ENABLED) ground.receiveShadow = true;
            scene.add(ground);

            const wallMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.8, roughness: 0.1 });
            const createWall = (w, h, d, x, y, z) => {
                const wall = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), wallMat);
                wall.position.set(x, y + h / 2, z);
                if(SHADOWS_ENABLED) wall.castShadow = true;
                scene.add(wall);
            };

            createWall(MAP_SIZE * 2 + 4, 10, 4, 0, 0, -MAP_SIZE);
            createWall(MAP_SIZE * 2 + 4, 10, 4, 0, 0, MAP_SIZE);
            createWall(4, 10, MAP_SIZE * 2 + 4, MAP_SIZE, 0, 0);
            createWall(4, 10, MAP_SIZE * 2 + 4, -MAP_SIZE, 0, 0);

            camera.position.set(0, 20, 20); 
            camera.lookAt(0, 0, 0);
        }

        // =========================================================================
        // == GESTIÓN DE JUEGO Y ENTIDADES                                      ==
        // =========================================================================

        let playerCar;
        const enemies = [];
        const traffic = [];
        const projectiles = [];
        const cars = [];

        function initEntities() {
            // 1. Jugador (Drift-V)
            playerCar = new CarController('Drift-V', false);
            playerCar.position.set(0, 0.5, 0);
            scene.add(playerCar);
            cars.push(playerCar);

            // 2. Enemigos (IA)
            const enemyTypes = ['Muscle Car', 'Sport', 'Pickup', 'Drift-V'];
            for(let i = 0; i < MAX_ENEMIES; i++){
                const type = enemyTypes[i % enemyTypes.length];
                const enemy = new CarController(type, true);
                const pos = getRandomPosNearCenter(10);
                enemy.position.set(pos.x, 0.5, pos.z);
                enemy.rotation.y = Math.random() * Math.PI * 2;
                scene.add(enemy);
                enemies.push(enemy);
                cars.push(enemy);
            }

            // 3. Tráfico (IA)
            for(let i = 0; i < MAX_TRAFFIC; i++){
                const type = 'Traffic';
                const tCar = new CarController(type, true);
                const pos = getRandomPosNearCenter(30);
                tCar.position.set(pos.x, 0.5, pos.z);
                tCar.rotation.y = Math.random() * Math.PI * 2;
                scene.add(tCar);
                traffic.push(tCar);
                cars.push(tCar);
            }
        }

        function getRandomPosNearCenter(distance) {
            const range = MAP_SIZE - distance;
            return {
                x: (Math.random() - 0.5) * range * 2,
                z: (Math.random() - 0.5) * range * 2
            };
        }

        // =========================================================================
        // == LÓGICA DE CONTROL DEL JUGADOR                                     ==
        // =========================================================================

        const controls = { forward: false, backward: false, left: false, right: false, turbo: false, fire: false };
        let lastFired = 0;

        function setupControls() {
            document.addEventListener('keydown', (event) => {
                switch (event.key.toLowerCase()) {
                    case 'w': controls.forward = true; break;
                    case 's': controls.backward = true; break;
                    case 'a': controls.left = true; break;
                    case 'd': controls.right = true; break;
                    case 'shift': controls.turbo = true; break;
                    case ' ': controls.fire = true; break; 
                }
            });

            document.addEventListener('keyup', (event) => {
                switch (event.key.toLowerCase()) {
                    case 'w': controls.forward = false; break;
                    case 's': controls.backward = false; break;
                    case 'a': controls.left = false; break;
                    case 'd': controls.right = false; break;
                    case 'shift': controls.turbo = false; break;
                    case ' ': controls.fire = false; break;
                }
            });
        }

        function handlePlayerInput(delta) {
            if (playerCar.userData.isDestroyed) {
                playerCar.userData.speed = 0;
                return;
            }

            const stats = playerCar.getPhysicsModifier();
            let maxSpeed = playerCar.userData.maxSpeed * stats.maxSpeedMod;
            let rotSpeed = playerCar.userData.rotSpeed * stats.rotSpeedMod;

            if (controls.turbo) {
                maxSpeed *= 1.5; 
                rotSpeed *= 1.2;
            }

            if (controls.forward) {
                playerCar.userData.speed = Math.min(maxSpeed, playerCar.userData.speed + 0.05);
            } else if (controls.backward) {
                playerCar.userData.speed = Math.max(-maxSpeed
