<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>CENIT DE ACERO: Arena de Combate Extremo</title>

<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/shaders/CopyShader.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/postprocessing/UnrealBloomPass.js"></script>


<style>
  /* Base Style - ESTILO AAA ESTILIZADO */
  :root{
    --bg:#020306;
    --red:#e74c3c;
    --blue:#3498db;
    --green:#2ecc71;
    --shadow:rgba(0,0,0,0.8);
    --text-color:#111111;
    /* Nuevos colores para estilo Gamer */
    --panel-bg:rgba(10, 15, 20, 0.75); 
    --panel-border:rgba(0, 255, 255, 0.5); /* Cian futurista */
    --panel-text: #ffffff;
    --red-glow: #ff0044;
  }
  html,body{height:100%;margin:0;background:linear-gradient(#6e8ca0,#a0c0e0);font-family:'Montserrat', sans-serif;color:var(--text-color);overflow:hidden}
  #holder{width:100%;height:100%;position:relative;touch-action:none; display: block;} 
  
  @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700;800&display=swap');

  /* HUD - Estilo de consola de juego (Final) */
  .hud{
    position:fixed;top:8px;left:10px;right:10px;display:flex;justify-content:space-between;z-index:120;
    font-size:12px;pointer-events:none;text-shadow:0 0 4px #000;
  } 
  .panel{
    background:var(--panel-bg);
    padding:6px 10px; 
    border-radius:2px;
    font-weight:600;
    pointer-events:auto;
    box-shadow:0 0 10px rgba(0, 255, 255, 0.2); 
    border:1px solid var(--panel-border);
    color: var(--panel-text);
    backdrop-filter:blur(3px);
    transition: background-color 0.3s;
  }
  .panel h2{font-size:14px;margin:0 0 3px 0;color:#00ffff} 
  #diagnostico{ flex-direction: column; width: 140px; pointer-events: none; line-height: 1.1; font-size: 11px; }
  .estado-ok{ color: #00ffaa; } 
  .estado-danado{ color: #ffcc00; } 
  .estado-critico{ color: var(--red-glow); font-weight: 700; }
  .bar-container{width:80px;height:10px;background:#333333;border-radius:2px;overflow:hidden;margin-top:2px;border:1px solid rgba(0,255,255,0.4)}
  .health-bar{height:100%;width:100%;background:linear-gradient(90deg, #c0392b, var(--red-glow));transition:width 0.2s}
  .ammo-bar{height:100%;width:100%;background:linear-gradient(90deg, #27ae60, #00ffaa);transition:width 0.2s}
  
  /* Velocímetro */
  .speedometer{
    position:fixed;right:10px; bottom:120px; width:100px;height:100px; background:var(--panel-bg); border-radius:50%; border:1px solid var(--panel-border); box-shadow:0 0 10px rgba(0, 255, 255, 0.2); display:flex;flex-direction:column;align-items:center;justify-content:center; pointer-events:none; z-index:115; backdrop-filter:blur(3px);
  }
  .speed-value{font-size:30px;font-weight:800;color:var(--panel-text);text-shadow:0 0 8px rgba(0, 255, 255, 0.4)}
  
  /* Controles (Joystick Estilo Gamer Final) */
  .joy { 
      position:fixed; left:12px; bottom:12px; width:100px; height:100px; border-radius:12px; 
      background:rgba(255,255,255,0.08); 
      display:flex; align-items:center; justify-content:center; pointer-events:auto; z-index:100; 
      border:2px solid rgba(0, 255, 255, 0.4); 
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
  }
  .stick { 
      width:40px; height:40px; border-radius:50%; 
      background:linear-gradient(135deg, #00ffff, #009999); 
      border: 2px solid #fff;
      box-shadow: 0 0 10px #00ffff;
      transform:translate(0,0) 
  }
  
  /* Botones de acción */
  .fire { 
      position:fixed; right:120px; bottom:20px; width:70px; height:70px; border-radius:50%; 
      background:linear-gradient(135deg,#ff0000,#cc0000); 
      box-shadow:0 0 15px var(--red); font-size:30px; border:3px solid #ffaaaa; 
      display: flex; align-items: center; justify-content: center;
  }
  
  .turbo { 
      position:fixed; right:12px; bottom:12px; width:90px; height:90px; border-radius:50%; 
      background:linear-gradient(135deg,#0055ff,#0033cc); 
      box-shadow:0 0 15px #0055ff; font-size:40px; 
      border:3px solid #aaffff;
      display: flex; align-items: center; justify-content: center;
  }
  .turbo.cooldown { background:linear-gradient(135deg, #003366, #0066cc); box-shadow:none; opacity: 0.5 !important; }

  
  /* FPS/Loader */
  .fps{position:fixed;left:12px;bottom:120px;background:var(--panel-bg);padding:4px 8px;border-radius:4px;font-weight:600;z-index:110;font-size:12px;backdrop-filter:blur(3px); color: var(--panel-text);}

  #loading {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #fff;
    background: rgba(0,0,0,0.8);
    padding: 15px;
    border-radius: 8px;
    font-size: 1.2em;
    z-index: 130;
  }
  
  @media (max-width:420px){ 
    .joy{width:90px;height:90px;left:8px;bottom:8px;} 
    .fire{right:95px;bottom:12px;width:60px;height:60px;font-size:24px}
    .turbo{right:8px;bottom:8px;width:70px;height:70px;font-size:30px} 
    .fps{left:8px;bottom:100px;} 
    .speedometer{width:100px;height:100px;right:8px;bottom:100px;}
    #diagnostico{ top: 8px; right: 8px; left: auto; width: 120px; padding: 6px 8px; }
  }
</style>
</head>
<body>
  <div id="holder"></div>

  <div class="hud">
    <div class="panel">
      <h2>VEHÍCULO: <span id="carType">Sport</span></h2>
      Integridad:
      <div class="bar-container"><div id="healthBar" class="health-bar"></div></div>
    </div>

    <div class="panel" id="diagnostico">
        <h2>DIAGNÓSTICO</h2>
        <div id="componentes">
            </div>
    </div>
    
    <div class="panel">
      <h2>MUNICIÓN</h2>
      Misiles: <span id="missileCountDisplay">3</span> / 3 
      <div class="bar-container"><div id="ammoBar" class="ammo-bar"></div></div>
    </div>
  </div>
  
  <div class="speedometer">
    <div class="speed-value" id="speedDisplay">0</div>
    <div class="speed-unit">KM/H</div>
  </div>

  <div id="loading">Cargando CENIT DE ACERO...</div>

  <div class="joy" id="joy"><div class="stick" id="stick"></div></div>
  <div class="fire" id="fire">💥</div>
  <div class="turbo" id="turbo">🚀</div>
  <div class="fps" id="fps">FPS: --</div>


<script>

// =========================================================================
// == CONSTANTES Y CONFIGURACIÓN ===========================================
// =========================================================================

const BLOOM_ENABLED = true; 
const SHADOWS_ENABLED = true; 

const VEHICLE_STATS = {
    'Muscle Car': { color: 0x880000, width: 2.8, length: 5.0, height: 1.0, health: 100, maxSpeed: 1.2, rotSpeed: 0.040, maxAmmo: 15 },
    'Sport': { color: 0x223388, width: 2.2, length: 4.0, height: 0.8, health: 80, maxSpeed: 1.4, rotSpeed: 0.055, maxAmmo: 10 },
    'Pickup': { color: 0x336633, width: 3.2, length: 5.5, height: 1.2, health: 150, maxSpeed: 0.9, rotSpeed: 0.030, maxAmmo: 20 },
    'Traffic': { color: 0xaaaaaa, width: 2.5, length: 4.5, height: 1.0, health: 50, maxSpeed: 0.7, rotSpeed: 0.020, maxAmmo: 0 }
};

// Variables globales para la IA y el Juego
const AI_CARS = [];
const TRAFFIC_CARS = [];
let car = null; 
let gameObjects = []; 

// =========================================================================
// == CLASE CARCONTROLLER (Sin Cambios Funcionales)                       ==
// =========================================================================

class CarController extends THREE.Group {
    constructor(type, isAI) {
        super();
        const stats = VEHICLE_STATS[type];

        this.userData.isAI = isAI;
        this.userData.type = type;
        this.userData.maxHealth = stats.health;
        this.userData.health = stats.health;
        this.userData.maxAmmo = stats.maxAmmo;
        this.userData.ammo = stats.maxAmmo;
        this.userData.maxSpeed = stats.maxSpeed;
        this.userData.rotSpeed = stats.rotSpeed;
        this.userData.speed = 0; 
        this.userData.isDestroyed = false;

        this.userData.gunOffsets = []; 
        
        // El mesh de colisión es un poco más grande que el modelo visual
        const boxGeo = new THREE.BoxGeometry(stats.width + 0.5, 2.0, stats.length + 0.5); 
        const boxMat = new THREE.MeshBasicMaterial({ visible: false }); 
        this.userData.collisionMesh = new THREE.Mesh(boxGeo, boxMat);
        this.add(this.userData.collisionMesh); 
        // Se crea el BoundingBox para la detección de colisión
        this.userData.boundingBox = new THREE.Box3().setFromObject(this.userData.collisionMesh);


        this.componentes = {
            motor: { vida: 100, max: 100, estado: 'OK', efecto: 'Potencia' },
            ruedas_traseras: { vida: 100, max: 100, estado: 'OK', efecto: 'Tracción' },
            sistema_punteria: { vida: 100, max: 100, estado: 'OK', efecto: 'Precisión' },
            chasis_frontal: { vida: 100, max: 100, estado: 'OK', efecto: 'Blindaje' }
        };
        if (type === 'Traffic') {
            this.componentes = { chasis: { vida: 100, max: 100, estado: 'OK', efecto: 'Estructura' } };
        }

        this.buildMesh(stats);

        if(isAI){
            const hbMat = new THREE.MeshBasicMaterial({color:0x00ff00, transparent: true, opacity: 0.8});
            const hbGeo = new THREE.BoxGeometry(stats.width * 0.8, 0.2, 0.1);
            const healthBar = new THREE.Mesh(hbGeo, hbMat);
            healthBar.position.y = 2.5;
            healthBar.rotation.y = Math.PI/2;
            this.userData.healthBar = healthBar;
            this.add(healthBar);
            if(SHADOWS_ENABLED) healthBar.receiveShadow = false;
            
            // AI Movement Vars
            this.userData.target = new THREE.Vector3(); 
            this.userData.mode = 'idle'; 
            this.userData.aiTurn = 0;
            this.userData.aiForward = 0;
            this.userData.lastFired = 0;
            this.userData.fireCooldown = 500 + Math.random() * 500;
        }
    }

    buildMesh(stats) {
        const bodyGeo = new THREE.TorusKnotGeometry(stats.length/5, stats.width/8, 100, 16); 
        const bodyMat = new THREE.MeshStandardMaterial({color:stats.color, metalness:0.9, roughness:0.15}); 
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.scale.set(1.5, 0.8, 1);
        body.rotation.y = Math.PI / 2;
        body.position.y = 1.0; 
        if(SHADOWS_ENABLED){ body.castShadow = true; body.receiveShadow = true; }
        this.add(body);
        
        const tailLightMat = new THREE.MeshBasicMaterial({color:0xff0000, emissive: 0xff0000, emissiveIntensity: 1.5});
        const tailLightGeo = new THREE.BoxGeometry(stats.width * 0.7, 0.3, 0.1);
        const tailLights = new THREE.Mesh(tailLightGeo, tailLightMat);
        tailLights.position.set(0, 1.0, stats.length/2 - 0.05); 
        this.add(tailLights);

        this.userData.body = body;
        this.userData.tailLights = tailLights;
        
        // Modelo de arma tipo Rifle de Asalto (M4/AK)
        if (this.userData.type !== 'Traffic') {
            const gunMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.95, roughness: 0.15 });

            const frontZ = -stats.length / 2 + 0.3;
            const leftX = -stats.width / 2 - 0.2;
            const rightX = stats.width / 2 + 0.2;
            const gunY = 1.0;
            const barrelLength = 1.5;

            const barrelR = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, barrelLength, 8), gunMat);
            barrelR.rotation.z = Math.PI / 2;
            barrelR.position.set(rightX, gunY, frontZ - barrelLength/2);
            this.add(barrelR);

            const receiverR = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.25, 0.5), gunMat);
            receiverR.position.set(rightX, gunY, frontZ + 0.25);
            this.add(receiverR);

            const barrelL = barrelR.clone();
            barrelL.position.x = leftX;
            this.add(barrelL);
            const receiverL = receiverR.clone();
            receiverL.position.x = leftX;
            this.add(receiverL);

            this.userData.gunOffsets.push(new THREE.Vector3(rightX, gunY, frontZ - barrelLength));
            this.userData.gunOffsets.push(new THREE.Vector3(leftX, gunY, frontZ - barrelLength));
        }

        this.createWheels(stats);
    }
    
    createWheels(stats){
        const wheelGeo = new THREE.CylinderGeometry(0.5, 0.5, stats.width * 0.25, 12);
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9, metalness: 0.1 });
        
        const wheelData = [
            { x: stats.width / 2 + 0.1, z: stats.length / 2 - 0.7 },
            { x: -stats.width / 2 - 0.1, z: stats.length / 2 - 0.7 },
            { x: stats.width / 2 + 0.1, z: -stats.length / 2 + 0.7 },
            { x: -stats.width / 2 - 0.1, z: -stats.length / 2 + 0.7 }
        ];
        
        for (const pos of wheelData) {
            const wheel = new THREE.Mesh(wheelGeo, wheelMat);
            wheel.rotation.z = Math.PI / 2;
            wheel.position.set(pos.x, 0.5, pos.z);
            if(SHADOWS_ENABLED) wheel.castShadow = true;
            this.add(wheel);
        }
    }

    applyDamage(amount, componentKey = 'chasis_frontal') {
        if (this.userData.health <= 0 || this.userData.isDestroyed) return false;
        
        const comp = this.componentes[componentKey];
        if (comp && comp.vida > 0) {
            comp.vida -= amount;
            comp.vida = Math.max(0, comp.vida);
            if (comp.vida <= 0) comp.estado = 'DESTRUIDO';
            else if (comp.vida <= 30) comp.estado = 'CRÍTICO';
            else if (comp.vida <= 60) comp.estado = 'DAÑADO';
            else comp.estado = 'OK';
        }

        this.userData.health -= amount * 0.5; // Reducción de la salud total
        this.userData.health = Math.max(0, this.userData.health);

        if (this.userData.body && this.userData.body.material) {
            // Efecto visual de golpe
            if (typeof this.userData.body.material.opacity === 'undefined') {
                this.userData.body.material.transparent = true;
                this.userData.body.material.opacity = 1.0;
            }
            if (this.userData.body.material.opacity > 0) {
                 this.userData.body.material.color.setHex(0xaaaaaa); 
                 if(this.userData.tailLights && this.userData.tailLights.material) this.userData.tailLights.material.emissiveIntensity = 5; 
                 setTimeout(() => {
                    if(this.userData.health > 0){
                        this.userData.body.material.color.setHex(VEHICLE_STATS[this.userData.type].color);
                        if(this.userData.tailLights && this.userData.tailLights.material) this.userData.tailLights.material.emissiveIntensity = 1.5; 
                    }
                }, 80);
            }
        }
        
        if (this.userData.health <= 0 && !this.userData.isDestroyed) {
             this.destroyVehicle();
             return true;
        }
        return false;
    }
    
    destroyVehicle() {
        this.userData.isDestroyed = true;
        this.userData.speed = 0; 

        this.userData.body.material.transparent = true;
        this.userData.body.material.opacity = 0.5;
        this.userData.body.material.color.setHex(0x333333); 
        this.userData.tailLights.material.emissiveIntensity = 0.1; 

        if(this.userData.healthBar) this.userData.healthBar.visible = false;

        const decayInterval = setInterval(() => {
            if (this.userData.body.material.opacity > 0.01) {
                this.userData.body.material.opacity *= 0.98;
                if(this.userData.body.material.opacity < 0.1) this.position.y = -100; 
            } else {
                clearInterval(decayInterval);
                this.userData.body.visible = false;
            }
        }, 100);
    }

    getPhysicsModifier() {
        if(this.userData.isDestroyed) return { maxSpeedMod: 0, rotSpeedMod: 0 };
        
        let maxSpeedMod = 1.0;
        let rotSpeedMod = 1.0;
        
        const motor = this.componentes.motor;
        const ruedas = this.componentes.ruedas_traseras;
        const chasis = this.componentes.chasis_frontal;

        if (motor && motor.estado !== 'OK') {
            maxSpeedMod *= 0.5 + (motor.vida / 100) * 0.5;
        }
        
        if (ruedas && ruedas.estado !== 'OK') {
             rotSpeedMod *= 0.3 + (ruedas.vida / 100) * 0.7;
        }

        if (chasis && (chasis.estado === 'CRÍTICO' || chasis.estado === 'DESTRUIDO')) {
            this.userData.speed *= 0.95; // Pequeño freno por chasis dañado
        }

        return { maxSpeedMod, rotSpeedMod };
    }
}

// =========================================================================
// == FUNCIÓN DE INICIALIZACIÓN PRINCIPAL (init)                          ==
// =========================================================================

let renderer = null; 
let composer = null; 

// FIX AUDIO: Declaración de AudioContext para gestión de reproducción automática
const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContext();
const audioLoader = new THREE.AudioLoader();
const listener = new THREE.AudioListener();
let motorSound = null; // THREE.PositionalAudio

let audioStarted = false;
function startAudio(){
    if(!audioStarted){
        // Usamos el AudioContext para desbloquear la reproducción en navegadores
        if (audioCtx.state === 'suspended') {
            audioCtx.resume().catch(e => console.warn("Fallo al reanudar AudioContext:", e));
        }
        
        if(motorSound) {
             motorSound.context.resume().then(() => {
                motorSound.play().catch(e => console.warn("Fallo al iniciar el audio del motor:", e));
             }).catch(e => console.warn("Fallo al reanudar AudioContext y Play:", e));
        }
        
        audioStarted = true;
    }
    // Removemos los listeners una vez que se inicia el audio
    document.removeEventListener('pointerdown', startAudio);
    document.removeEventListener('touchstart', startAudio);
    document.removeEventListener('click', startAudio); 
}
// Agregamos listeners de interacción para iniciar el audio
document.addEventListener('pointerdown', startAudio);
document.addEventListener('touchstart', startAudio);
document.addEventListener('click', startAudio); 


function init() {
    (function(){
      const holder = document.getElementById('holder');
      const CITY_SIZE = 400; 
      const BULLET_COOLDOWN_MS = 260;
      const MISSILE_COOLDOWN_MS = 1500; 
      const UI_COMP_EL = document.getElementById('componentes'); 
      const UI_MISSILE_EL = document.getElementById('missileCountDisplay'); 
      let CURRENT_CAR_TYPE = 'Sport'; 
      
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x6e8ca0); 
      scene.fog = new THREE.Fog(scene.background, CITY_SIZE/2, 2000); 
      
      // -------------------------------------------------------------------
      // ** GESTIÓN DEFENSIVA DEL RENDERER ** // 
      // -------------------------------------------------------------------
      try {
        renderer = new THREE.WebGLRenderer({
            antialias: true, 
            alpha: false,
            powerPreference: "low-power", 
            failIfMajorPerformanceCaveat: true 
        });
        
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        renderer.shadowMap.enabled = SHADOWS_ENABLED;
        if(SHADOWS_ENABLED) renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        renderer.domElement.style.position = 'absolute';
        renderer.domElement.style.top = '0';
        renderer.domElement.style.left = '0';
        renderer.domElement.style.width = '100%';
        renderer.domElement.style.height = '100%';
        renderer.domElement.style.zIndex = '0'; 
        
        holder.appendChild(renderer.domElement);
        renderer.setClearColor(scene.background); 
        
        const loadingEl = document.getElementById('loading');
        if (loadingEl) loadingEl.style.display = 'none';
        
      } catch (err) {
        console.error('Error FATAL al crear el contexto WebGL:', err);
        const loadingEl = document.getElementById('loading');
        let errorDetails = (typeof EffectComposer === 'undefined') ? 'EffectComposer is not defined' : err.message;
        if (loadingEl) {
             loadingEl.innerHTML = `¡Error al inicializar 3D! WebGL falló.<br>Intente en un navegador/dispositivo diferente.<br>Detalles: ${errorDetails}`;
             loadingEl.style.backgroundColor = 'rgba(150, 0, 0, 0.9)';
        }
        return; 
      }
      
      const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000); 
      camera.position.set(0, 12, 24);
      
      // ** Audio (THREE.js Positional) **
      camera.add(listener);
      motorSound = new THREE.PositionalAudio(listener);
      audioLoader.load( 'https://www.soundjay.com/transport/car-engine-01.mp3', function( buffer ) {
          motorSound.setBuffer( buffer );
          motorSound.setLoop( true );
          motorSound.setRefDistance( 10 );
          motorSound.setVolume( 0.0 );
      });

      // Efectos de post-procesado (Bloom)
      if(BLOOM_ENABLED && typeof EffectComposer !== 'undefined'){
        try{
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.0, 0.4, 0.85); 
            bloomPass.renderToScreen = true;
            composer.addPass(bloomPass);
        } catch(e){
            console.warn("Fallo al inicializar EffectComposer o Bloom. Renderizado simple activo.", e);
            composer = null; 
        }
      } else if (BLOOM_ENABLED) {
          composer = null; 
      }

      // Luces
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.9); 
      dirLight.position.set(200, 400, 300);
      dirLight.castShadow = SHADOWS_ENABLED;
      if(SHADOWS_ENABLED){
        dirLight.shadow.mapSize.width = 1024; 
        dirLight.shadow.mapSize.height = 1024;
      }
      dirLight.shadow.camera.left = -CITY_SIZE;
      dirLight.shadow.camera.right = CITY_SIZE;
      dirLight.shadow.camera.top = CITY_SIZE;
      dirLight.shadow.camera.bottom = -CITY_SIZE;
      dirLight.shadow.bias = -0.0005; 
      scene.add(dirLight);
      
      scene.add(new THREE.HemisphereLight(0xffffff, 0x080820, 0.8)); 
      scene.add(new THREE.AmbientLight(0xffffff, 0.5)); 

      // ---------------------------------------------------------
      // ** SUELO METÁLICO (Final) **
      // ---------------------------------------------------------
      const metalMat = new THREE.MeshStandardMaterial({
        color: 0x444444, 
        roughness: 0.1, 
        metalness: 0.95, 
        emissive: 0x111111,
        emissiveIntensity: 0.1
      });
      const ground = new THREE.Mesh(new THREE.PlaneGeometry(CITY_SIZE, CITY_SIZE, 1, 1), metalMat);
      ground.rotation.x = -Math.PI/2;
      ground.position.y = 0;
      if(SHADOWS_ENABLED) ground.receiveShadow = true;
      scene.add(ground);


      // Muros
      const WALL_THICKNESS = 10;
      const WALL_HEIGHT = 180;
      const arenaMat = new THREE.MeshStandardMaterial({color: 0x333333, roughness: 0.8, metalness: 0.3}); 

      function createWall(x, z, sizeX, sizeZ) {
        const wall = new THREE.Mesh(new THREE.BoxGeometry(sizeX, WALL_HEIGHT, sizeZ), arenaMat);
        wall.position.set(x, WALL_HEIGHT / 2 + 0.5, z);
        if(SHADOWS_ENABLED){ wall.castShadow = true; wall.receiveShadow = true; }
        scene.add(wall);
        
        wall.userData.isWall = true;
        wall.userData.boundingBox = new THREE.Box3().setFromObject(wall);
        gameObjects.push(wall);
      }
      
      createWall(0, -CITY_SIZE/2 - WALL_THICKNESS/2, CITY_SIZE + WALL_THICKNESS * 2, WALL_THICKNESS); // Muro Norte
      createWall(0, CITY_SIZE/2 + WALL_THICKNESS/2, CITY_SIZE + WALL_THICKNESS * 2, WALL_THICKNESS); // Muro Sur
      createWall(CITY_SIZE/2 + WALL_THICKNESS/2, 0, WALL_THICKNESS, CITY_SIZE); // Muro Este
      createWall(-CITY_SIZE/2 - WALL_THICKNESS/2, 0, WALL_THICKNESS, CITY_SIZE); // Muro Oeste

      // ---------- VEHÍCULOS ----------
      
      car = new CarController(CURRENT_CAR_TYPE, false);
      car.position.set(0, 0, 0);
      scene.add(car); 
      gameObjects.push(car); 
      car.add(motorSound);

      const ai1 = new CarController('Muscle Car', true);
      ai1.position.set(20, 0, 50);
      ai1.rotation.y = Math.PI;
      scene.add(ai1); 
      AI_CARS.push(ai1); 
      gameObjects.push(ai1);

      const ai2 = new CarController('Pickup', true);
      ai2.position.set(-20, 0, -50);
      ai2.rotation.y = 0;
      scene.add(ai2); 
      AI_CARS.push(ai2); 
      gameObjects.push(ai2);

      // Tráfico (5 Coches)
      for(let i = 0; i < 5; i++){
          const traffic = new CarController('Traffic', true);
          // Posición en una calle simulada (línea vertical u horizontal)
          const isVertical = Math.random() < 0.5;
          let x = isVertical ? (Math.random() * 40 - 20) : (Math.random() * CITY_SIZE*0.8 - CITY_SIZE*0.4);
          let z = isVertical ? (Math.random() * CITY_SIZE*0.8 - CITY_SIZE*0.4) : (Math.random() * 40 - 20);
          
          traffic.position.set(x, 0, z);
          traffic.rotation.y = isVertical ? (Math.random() < 0.5 ? 0 : Math.PI) : (Math.random() < 0.5 ? Math.PI/2 : -Math.PI/2);
          
          traffic.userData.maxSpeed *= (0.8 + Math.random() * 0.4);
          traffic.userData.mode = 'cruise';
          TRAFFIC_CARS.push(traffic);
          scene.add(traffic); 
          gameObjects.push(traffic);
      }

      // Estado del jugador
      const state = {
          forward: 0, 
          turn: 0, 
          speed: 0,
          health: car.userData.health, 
          missileCount: 3 
      };
      
      // SISTEMA DE ARMAS (Bullet Pool)
      const bulletPool = [];
      const missilePool = []; 
      const activeBullets = [];
      const activeMissiles = [];
      const maxBullets = 120;
      const maxMissiles = 10;

      const BULLET_DAMAGE = 15;
      const MISSILE_DAMAGE = 80; 
      const MISSILE_SPEED = 2.0;
      const MISSILE_IMPACT_RADIUS = 5.0; 

      function setupBulletPool() {
          const bulletGeo = new THREE.SphereGeometry(0.18, 8, 8);
          const bulletMat = new THREE.MeshBasicMaterial({ color: 0xff4444, emissive: 0xff0000, emissiveIntensity: 6 }); 
          for (let i = 0; i < maxBullets; i++) {
              const bullet = new THREE.Mesh(bulletGeo, bulletMat);
              bullet.userData.dir = new THREE.Vector3();
              bullet.userData.speed = 3.0; 
              bullet.userData.damage = BULLET_DAMAGE;
              bullet.visible = false;
              bullet.userData.isBullet = true;
              if(SHADOWS_ENABLED) bullet.castShadow = true;
              scene.add(bullet);
              bulletPool.push(bullet);
          }
          
          const missileGeo = new THREE.CylinderGeometry(0.4, 0.6, 2.0, 8); 
          const missileMat = new THREE.MeshStandardMaterial({color: 0xaaaaaa, metalness: 0.9, roughness: 0.1});
          for(let i = 0; i < maxMissiles; i++){
              const missile = new THREE.Mesh(missileGeo, missileMat);
              missile.rotation.x = Math.PI / 2;
              missile.userData.dir = new THREE.Vector3();
              missile.userData.speed = MISSILE_SPEED;
              missile.userData.damage = MISSILE_DAMAGE;
              missile.userData.isMissile = true;
              missile.visible = false;
              
              const light = new THREE.PointLight(0xff8800, 10, 10);
              missile.add(light);
              missile.userData.light = light;

              if(SHADOWS_ENABLED) missile.castShadow = true;
              scene.add(missile);
              missilePool.push(missile);
          }
      }
      function getBullet() {
          const bullet = bulletPool.find(b => !b.visible);
          if (bullet) { bullet.visible = true; bullet.userData._spawnTime = performance.now(); activeBullets.push(bullet); }
          return bullet;
      }
      function releaseBullet(b) {
          b.visible = false;
          b.position.set(0, -9999, 0);
          b.userData.dir.set(0,0,0);
          const index = activeBullets.indexOf(b);
          if (index > -1) activeBullets.splice(index, 1);
      }
      function getMissile() {
          if (state.missileCount <= 0) return null;
          const missile = missilePool.find(m => !m.visible);
          if (missile) { 
              missile.visible = true; 
              missile.userData._spawnTime = performance.now(); 
              activeMissiles.push(missile); 
              state.missileCount--;
              missile.userData.light.intensity = 10;
          }
          return missile;
      }
      function releaseMissile(m) {
          m.visible = false;
          m.position.set(0, -9999, 0);
          m.userData.dir.set(0,0,0);
          m.userData.light.intensity = 0;
          const index = activeMissiles.indexOf(m);
          if (index > -1) activeMissiles.splice(index, 1);
      }

      function spawnBulletsFromCar(targetCar, dir, offsets = null){
          const offs = offsets || (targetCar.userData.gunOffsets || []);
          for(const off of offs){
              const b = getBullet();
              if(!b) break; 
              const origin = targetCar.position.clone().add(off.clone().applyQuaternion(targetCar.quaternion));
              b.position.copy(origin);
              b.userData.dir.copy(dir);
              
              // FIX SONIDO: Audio de disparo
              const sound = new Audio('https://www.soundjay.com/weapons/rifle-01.mp3'); 
              sound.volume = 0.3; 
              sound.play().catch(e => console.warn("Fallo al iniciar el audio del disparo:", e));
          }
      }

      function spawnMissileFromCar(targetCar, dir){
          if(targetCar.userData.isAI) return false; 
          
          const m = getMissile();
          if(!m) return false;
          
          const offset = new THREE.Vector3(0, 1.5, -targetCar.userData.length/2); 
          const origin = targetCar.position.clone().add(offset.applyQuaternion(targetCar.quaternion));
          
          m.position.copy(origin);
          m.userData.dir.copy(dir);
          m.rotation.copy(targetCar.rotation);
          
          // FIX SONIDO: Audio de misil
          const sound = new Audio('https://www.soundjay.com/military/missile-01.mp3'); 
          sound.volume = 0.6; 
          sound.play().catch(e => console.warn("Fallo al iniciar el audio del misil:", e));

          return true;
      }

      setupBulletPool(); 
      
      // Función TWEEN simplificada
      const TWEEN = { 
        Easing: { Quadratic: { Out: (k) => k * (2 - k) } },
        Tween: function(obj) { return { to: function(props, duration) { return { easing: function(e) { this.easingFn = e; return this; }, start: function() { 
          let start = performance.now();
          let current = {};
          for(let key in props) current[key] = typeof obj[key] === 'object' ? obj[key].clone() : obj[key];

          function animate(time) {
            let elapsed = time - start;
            let progress = Math.min(1, elapsed / duration);
            let eased = this.easingFn ? this.easingFn(progress) : progress;
            for(let key in props) {
              if (typeof obj[key] === 'object') { 
                  obj[key].copy(current[key]).lerp(props[key], eased); 
              } else {
                  obj[key] = current[key] + (props[key] - current[key]) * eased;
              }
            }
            if (progress < 1) requestAnimationFrame(animate.bind(this));
            else if (this.onComplete) this.onComplete();
          }
          requestAnimationFrame(animate.bind(this));
          return this;
        }, onComplete: function(cb) { this.onComplete = cb; return this; } } },
        start: function() { } 
      };

      function createExplosion(position, isMissile = false){
          const size = isMissile ? 5.0 : 0.5; 
          const duration = isMissile ? 400 : 200;
          const color = isMissile ? 0xffaa00 : 0xff4444;
          const intensity = isMissile ? 30 : 8; 

          const flash = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({color: color, transparent: true, opacity: 1.0}));
          flash.position.copy(position);
          flash.position.y += 1.0;
          scene.add(flash);
          
          const expLight = new THREE.PointLight(color, intensity, isMissile ? 15 : 3);
          expLight.position.copy(flash.position);
          scene.add(expLight);

          if(isMissile){
              // FIX SONIDO: Explosión de misil
              const sound = new Audio('https://www.soundjay.com/military/explosion-01.mp3'); 
              sound.volume = 0.8; sound.play().catch(e => console.warn("Fallo al iniciar el audio de la explosión:", e));
          } else {
              // FIX SONIDO: Impacto de bala
              const sound = new Audio('https://www.soundjay.com/weapons/bullet-impact-01.mp3'); 
              sound.volume = 0.5; sound.play().catch(e => console.warn("Fallo al iniciar el audio de impacto:", e));
          }

          new TWEEN.Tween(flash.scale).to({x: size, y: size, z: size}, duration).easing(TWEEN.Easing.Quadratic.Out).start();
          new TWEEN.Tween(flash.material).to({opacity: 0.0}, duration).onComplete(() => {
              scene.remove(flash); flash.geometry.dispose(); flash.material.dispose();
          }).start();
          
          new TWEEN.Tween(expLight).to({intensity: 0}, duration).easing(TWEEN.Easing.Quadratic.Out).onComplete(() => {
             scene.remove(expLight); expLight.dispose();
          }).start();
      }

      function applyDamage(target, amount, component = 'chasis_frontal', isMissile = false){
          createExplosion(target.position, isMissile);
          
          const isDead = target.applyDamage(amount, component);
          if(target === car) state.health = car.userData.health;
          if(isDead){ console.log(`${target.userData.type} DESTRUIDO!`); }
      }
      

      const halfCity = CITY_SIZE / 2;
      
      // =========================================================================
      // ** FIX CRÍTICO V14: LÓGICA DE COLISIÓN MEJORADA **
      // =========================================================================
      function checkCollisions(dt){
          
          // 1. Colisiones de Proyectiles (Balas y Misiles)
          const activeProjectiles = [...activeBullets, ...activeMissiles];
          for(let i=activeProjectiles.length-1;i>=0;i--){
              const p = activeProjectiles[i];
              let hit = false;
              
              if (Math.abs(p.position.x) > halfCity + 10 || Math.abs(p.position.z) > halfCity + 10) { 
                  hit = true; 
                  if(p.userData.isBullet) releaseBullet(p);
                  else if(p.userData.isMissile) releaseMissile(p);
                  continue; 
              } 
              
              const targets = [car, ...AI_CARS, ...TRAFFIC_CARS].filter(t => !t.userData.isDestroyed);
              for(const target of targets){
                  if(target.position.distanceTo(p.position) < (p.userData.isMissile ? MISSILE_IMPACT_RADIUS : 3.0) && target.userData.health > 0){ 
                      
                      let componentHit = 'chasis_frontal';
                      const dot = new THREE.Vector3().subVectors(target.position, p.position).normalize().dot(new THREE.Vector3(0,0,-1).applyQuaternion(target.quaternion));
                      if (target.componentes.motor && dot < -0.5) componentHit = 'motor'; 
                      else if (target.componentes.ruedas_traseras && dot > -0.5 && dot < 0.5) componentHit = 'ruedas_traseras';

                      applyDamage(target, p.userData.damage, componentHit, p.userData.isMissile);
                      hit = true;
                      break;
                  }
              }
              if (hit){ 
                  if(p.userData.isBullet) releaseBullet(p);
                  else if(p.userData.isMissile) releaseMissile(p);
              }
          }
          
          // 2. Colisiones de Vehículos con el Entorno/Otros
          for(const currentCar of gameObjects.filter(obj => obj instanceof CarController && !obj.userData.isDestroyed)){
              const currentBBox = currentCar.userData.boundingBox.copy(currentCar.userData.collisionMesh.geometry.boundingBox).applyMatrix4(currentCar.matrixWorld);
              
              for(const obj of gameObjects){
                  if(obj === currentCar || (obj instanceof CarController && obj.userData.isDestroyed)) continue;
                  
                  const isWall = obj.userData.isWall;
                  const otherBBox = obj.userData.boundingBox.copy(
                      (obj instanceof CarController ? obj.userData.collisionMesh.geometry.boundingBox : obj.geometry.boundingBox)
                  ).applyMatrix4(obj.matrixWorld);

                  if(currentBBox.intersectsBox(otherBBox)){
                      // Lógica de retroceso vectorial
                      let pushDirection = new THREE.Vector3();
                      let separationFactor = 0.3; // Distancia para empujar
                      
                      if(isWall){
                          // Calcular la dirección desde el centro de la pared al centro del coche
                          pushDirection.subVectors(currentCar.position, obj.position).normalize();
                      } else { 
                          // Colisión coche-coche: la dirección es la del coche que recibe el impacto
                          pushDirection.subVectors(currentCar.position, obj.position).normalize();
                          separationFactor = 0.5; 
                          // También empujar al otro coche
                          obj.position.addScaledVector(pushDirection.clone().negate(), separationFactor * 0.5);
                          obj.userData.speed *= -0.1;
                      }

                      // Aplicar el empuje al coche actual
                      currentCar.position.addScaledVector(pushDirection, separationFactor);
                      currentCar.userData.speed *= -0.2; // Freno/reversa
                      applyDamage(currentCar, 5, 'chasis_frontal');
                  }
              }
              
              // Colisión con los límites del mapa (Hard Limit)
              if (Math.abs(currentCar.position.x) > halfCity || Math.abs(currentCar.position.z) > halfCity) {
                   currentCar.userData.speed *= -0.2;
                   
                   let pushDirection = new THREE.Vector3();
                   if (currentCar.position.x > halfCity) pushDirection.x = -1;
                   if (currentCar.position.x < -halfCity) pushDirection.x = 1;
                   if (currentCar.position.z > halfCity) pushDirection.z = -1;
                   if (currentCar.position.z < -halfCity) pushDirection.z = 1;

                   currentCar.position.addScaledVector(pushDirection, 0.5);
                   applyDamage(currentCar, 5, 'chasis_frontal');
              }
          }
          
          state.health = car.userData.health; 
      }
      
      function updateCamera(){
        const desired = car.position.clone().add(new THREE.Vector3(0,4,12).applyQuaternion(car.quaternion)); 
        camera.position.lerp(desired, 0.15);
        camera.lookAt(car.position.clone().add(new THREE.Vector3(0,1.2,0)));
      }

      function updateHUD(){
          document.getElementById('healthBar').style.width = (state.health / car.userData.maxHealth * 100) + '%';
          UI_MISSILE_EL.textContent = `${state.missileCount} / 3`;
          document.getElementById('ammoBar').style.width = (state.missileCount / 3 * 100) + '%';
          
          const kmh = Math.round(Math.abs(car.userData.speed) / car.userData.maxSpeed * 200);
          document.getElementById('speedDisplay').textContent = kmh;
          
          let html = '';
          for (const key in car.componentes) {
              const comp = car.componentes[key];
              let className = comp.estado === 'CRÍTICO' ? 'estado-critico' : comp.estado === 'DAÑADO' ? 'estado-danado' : 'estado-ok';
              html += `<p class="componente-estado"><strong>${comp.efecto.toUpperCase()}:</strong> <span class="${className}">${comp.estado} (${Math.round(comp.vida)}%)</span></p>`;
          }
          UI_COMP_EL.innerHTML = html;
          
          const missileBtn = document.getElementById('turbo');
          if (state.missileCount <= 0) {
              missileBtn.classList.add('cooldown');
          } else {
              missileBtn.classList.remove('cooldown');
              missileBtn.style.opacity = 1.0;
          }
          
          // CONTROL DE VOLUMEN DEL MOTOR
          if(motorSound) motorSound.setVolume(Math.min(0.8, Math.abs(car.userData.speed) * 0.5));
      }
      
      // =========================================================================
      // ** LÓGICA DE MOVIMIENTO Y COMPORTAMIENTO DE LA IA (V14) **
      // =========================================================================
      function updateAICars(now, dt){
          const target = car.position.clone();
          
          // Lógica de los AI_CARS (Enemigos)
          for(const aicar of AI_CARS){
              if(aicar.userData.isDestroyed) continue;
              
              const distance = aicar.position.distanceTo(target);
              
              // 1. Rotación para apuntar al objetivo
              const targetVector = new THREE.Vector3().subVectors(target, aicar.position).normalize();
              const currentVector = new THREE.Vector3(0,0,-1).applyQuaternion(aicar.quaternion).normalize();
              
              let angle = currentVector.angleTo(targetVector);
              const cross = new THREE.Vector3().crossVectors(currentVector, targetVector);
              if (cross.y > 0) angle = -angle; 

              // Rotación es proporcional al ángulo y la velocidad de rotación
              aicar.userData.aiTurn = angle / (Math.PI / 4); // Normalizar el giro entre -1 y 1 (o más)

              // 2. Lógica de Persecución y Distancia
              if (distance > 30) {
                  aicar.userData.aiForward = 1.0; // Perseguir si está lejos
                  aicar.userData.aiTurn = Math.min(1.0, Math.max(-1.0, aicar.userData.aiTurn));
              } else if (distance < 15) {
                  aicar.userData.aiForward = -0.5; // Retroceder si está demasiado cerca
                  if(aicar.userData.aiTurn > 0.05 || aicar.userData.aiTurn < -0.05) aicar.userData.aiTurn *= -1; // Maniobrar en reversa
              } else {
                  aicar.userData.aiForward = 0.5; // Mantener posición
                  aicar.userData.aiTurn *= 0.2; // Suavizar giro para disparar
              }
              
              // 3. Disparo de la IA
              if(distance < 50 && now - aicar.userData.lastFired > aicar.userData.fireCooldown){
                  if (Math.abs(angle) < 0.15) { // Disparar solo si está apuntando razonablemente bien
                      const dir = new THREE.Vector3(0,0,-1).applyQuaternion(aicar.quaternion).normalize();
                      spawnBulletsFromCar(aicar, dir);
                      aicar.userData.lastFired = now;
                      aicar.userData.fireCooldown = 500 + Math.random() * 500;
                  }
              }
          }
          
          // Lógica de TRAFFIC_CARS (Tráfico)
          for(const traffic of TRAFFIC_CARS){
              if(traffic.userData.isDestroyed) continue;
              
              // Simulación de "cruising"
              if (traffic.userData.mode === 'cruise') {
                  traffic.userData.aiForward = 0.7; 
                  traffic.userData.aiTurn = 0;
                  
                  // Lógica simple de borde (mejora en Z)
                  if (traffic.position.z > halfCity - 10 && traffic.userData.aiForward > 0 && traffic.rotation.y < Math.PI / 4) {
                      traffic.rotation.y = Math.PI; 
                  } else if (traffic.position.z < -halfCity + 10 && traffic.userData.aiForward > 0 && traffic.rotation.y > 3 * Math.PI / 4) {
                       traffic.rotation.y = 0; 
                  }
              }
          }
      }
      
      // ---------- INPUTS Y CONTROLES ----------
      const joy = document.getElementById('joy'), stickEl = document.getElementById('stick');
      let touchId = null, baseX=0, baseY=0;
      let stick = {x:0,y:0};
      function resetStick(){ stick={x:0,y:0}; stickEl.style.transform = `translate(0px,0px)`; }
      
      
      joy.addEventListener('touchstart', e=>{ e.preventDefault(); const t = e.changedTouches[0]; touchId = t.identifier; baseX=t.clientX; baseY=t.clientY; }, {passive:false});
      joy.addEventListener('touchmove', e=>{ e.preventDefault(); for(const t of e.changedTouches){ if(t.identifier===touchId){ const dx=t.clientX-baseX, dy=t.clientY-baseY; const max=36; const nx=Math.max(-1,Math.min(1,dx/max)); const ny=Math.max(-1,Math.min(1,dy/max)); stick.x = nx; stick.y = -ny; stickEl.style.transform = `translate(${nx*28}px,${-ny*28}px)`; } } }, {passive:false});
      joy.addEventListener('touchend', e=>{ for(const t of e.changedTouches){ if(t.identifier===touchId){ touchId=null; resetStick(); } } }, {passive:false});
      
      let md=false;
      joy.addEventListener('pointerdown', e=>{ 
          md=true; baseX=e.clientX; baseY=e.clientY; 
          if (e.pointerType === 'mouse') joy.setPointerCapture(e.pointerId); 
      });
      joy.addEventListener('pointermove', e=>{ 
          if(!md) return; 
          const dx=e.clientX-baseX, dy=e.clientY-baseY; 
          const max=36; 
          const nx=Math.max(-1,Math.min(1,dx/max)); 
          const ny=Math.max(-1,Math.min(1,dy/max)); 
          stick.x=nx; stick.y=-ny; 
          stickEl.style.transform=`translate(${nx*28}px,${-ny*28}px)`; 
      });
      joy.addEventListener('pointerup', e=>{ md=false; resetStick(); });
      joy.addEventListener('pointerleave', e=>{ md=false; resetStick(); });
      
      const fireBtn = document.getElementById('fire');
      fireBtn.addEventListener('touchstart', e=>{ e.preventDefault(); doFire(); }, {passive:false});
      fireBtn.addEventListener('mousedown', doFire);

      const missileBtn = document.getElementById('turbo');
      missileBtn.addEventListener('touchstart', e=>{ e.preventDefault(); doMissile(); }, {passive:false});
      missileBtn.addEventListener('mousedown', doMissile);
      
      let lastFireTime = 0;
      function doFire(){
          const now = performance.now();
          if(now - lastFireTime < BULLET_COOLDOWN_MS || car.userData.isDestroyed) return;
          lastFireTime = now;
          
          fireBtn.classList.add('cooldown');
          setTimeout(() => { fireBtn.classList.remove('cooldown'); }, BULLET_COOLDOWN_MS);

          const dir = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion).normalize();
          spawnBulletsFromCar(car, dir);
      }
      
      let lastMissileTime = 0;
      function doMissile(){
          const now = performance.now();
          if(now - lastMissileTime < MISSILE_COOLDOWN_MS || car.userData.isDestroyed || state.missileCount <= 0) return;

          const dir = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion).normalize();
          const launched = spawnMissileFromCar(car, dir);

          if(launched) {
              lastMissileTime = now;
              // El cooldown visual solo aplica para el misil, no para el botón
              missileBtn.classList.add('cooldown');
              setTimeout(() => { 
                 missileBtn.classList.remove('cooldown'); 
                 if(state.missileCount > 0) missileBtn.style.opacity = 1.0; 
              }, MISSILE_COOLDOWN_MS);
          }
      }
      
      // ---------- RENDER LOOP ----------
      let last = performance.now(); let frames = 0; let lastFpsTime = performance.now();
      function animate(){
        const now = performance.now();
        const dt = Math.min(50, now-last) / 16.666;
        last = now;
        
        // Lógica de la IA
        updateAICars(now, dt);
        
        // Movimiento del Jugador y la IA
        const controlledCars = [car, ...AI_CARS, ...TRAFFIC_CARS];
        for (const currentCar of controlledCars) {
            if (currentCar.userData.isDestroyed) continue;
            
            let forward = 0, turn = 0;
            if (currentCar === car) {
                forward = Math.max(-1, Math.min(1, stick.y));
                turn = Math.max(-1, Math.min(1, stick.x));
            } else {
                forward = currentCar.userData.aiForward;
                turn = currentCar.userData.aiTurn;
            }

            const physicsMod = currentCar.getPhysicsModifier();
            let maxSpeed = currentCar.userData.maxSpeed * physicsMod.maxSpeedMod; 
            
            // Aceleración y Freno
            if(forward > 0.05) currentCar.userData.speed += 0.018 * forward * dt;
            else if(forward < -0.05) currentCar.userData.speed -= 0.03 * (-forward) * dt;
            else currentCar.userData.speed *= 0.95; // Amortiguación del movimiento (FIXED)
            
            currentCar.userData.speed = Math.max(-maxSpeed * 0.5, Math.min(maxSpeed, currentCar.userData.speed));
            
            const currentSpeedFactor = Math.abs(currentCar.userData.speed / currentCar.userData.maxSpeed);
            let rotationMultiplier = 1;
            if(currentSpeedFactor < 0.1) rotationMultiplier = 0.5; // Más difícil girar si casi no te mueves
            
            currentCar.rotation.y += -turn * currentCar.userData.rotSpeed * physicsMod.rotSpeedMod * (0.9 + currentSpeedFactor) * dt * rotationMultiplier;
            
            const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(currentCar.quaternion);
            currentCar.position.add(fwd.multiplyScalar(currentCar.userData.speed * dt * 0.82));
        }

        checkCollisions(dt);
        
        // Movimiento de proyectiles y misiles
        for(let i = activeBullets.length - 1; i >= 0; i--){
            const bullet = activeBullets[i];
            bullet.position.addScaledVector(bullet.userData.dir, bullet.userData.speed * dt);
        }
        
        for(let i = activeMissiles.length - 1; i >= 0; i--){
            const missile = activeMissiles[i];
            // Orientar el misil a su dirección de vuelo (estético)
            missile.lookAt(missile.position.clone().add(missile.userData.dir));
            missile.rotation.x -= Math.PI / 2;
            
            missile.position.addScaledVector(missile.userData.dir, missile.userData.speed * dt);
            missile.userData.light.intensity *= 0.98;
        }
        
        updateCamera();
        updateHUD();
        
        // RENDERIZADO CON COMPOSER
        if(composer && BLOOM_ENABLED){
            composer.render();
        } else {
            renderer.render(scene, camera);
        }
        
        frames++; 
        if(now - (lastFpsTime || now) >= 1000){ 
            lastFpsTime = now;
            document.getElementById('fps').textContent = `FPS: ${frames}`;
            frames = 0;
        }

        requestAnimationFrame(animate);
      }

      // INICIO DEL BUCLE
      animate(); 

      window.addEventListener('resize', ()=>{ 
        if(renderer){
            renderer.setSize(window.innerWidth, window.innerHeight); 
            camera.aspect = innerWidth/innerHeight; 
            camera.updateProjectionMatrix(); 
            if(composer) composer.setSize(window.innerWidth, window.innerHeight);
        }
      });
      
      // Iniciar audio al cargar y con cualquier interacción posterior
      startAudio();

    })();
}

// CRÍTICO: Iniciar la función de inicialización cuando el DOM esté cargado
document.addEventListener('DOMContentLoaded', init); 
</script>
</body>
</html>
