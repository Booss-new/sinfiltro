<!--
  pixeljump.html
  Juego de plataformas 2D original inspirado en los cl√°sicos (pero sin copiar assets).
  - Controles: teclado (A/D, flechas izquierda/derecha, W / espacio / click para saltar)
             botones t√°ctiles en m√≥vil (izq/der/saltar)
  - Mec√°nicas: caminar, correr (hold shift), salto, gravedad, enemigos patrullando,
               monedas, vidas, score, niveles, c√°mara, parallax, pause, guardado local.
  - Todo en un solo archivo, ligero y optimizado para m√≥vil.
  - Cambia nombres, colores y reglas como quieras.
-->
<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
<title>PixelJump ‚Äî Demo</title>
<style>
  :root{
    --bg1:#071226; --bg2:#001018; --accent:#00d1ff; --accent2:#8a6eff;
    --ui:#eaf7ff; --muted:#9fb0bf;
    --hud-bg: rgba(0,0,0,0.35);
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg1),var(--bg2));-webkit-font-smoothing:antialiased;font-family:Inter,system-ui,Arial;}
  #gamewrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;padding:12px;box-sizing:border-box}
  canvas{display:block;border-radius:12px;background:linear-gradient(180deg,#081224,#021018);box-shadow:0 20px 60px rgba(0,0,0,0.6);}
  /* HUD */
  .hud{position:fixed;left:16px;top:16px;color:var(--ui);z-index:40;background:var(--hud-bg);padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);backdrop-filter:blur(6px)}
  .hud b{color:var(--accent)}
  .hud-right{position:fixed;right:16px;top:16px;color:var(--ui);z-index:40;background:var(--hud-bg);padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);backdrop-filter:blur(6px)}
  /* Mobile touch controls */
  .touch-controls{position:fixed;left:0;right:0;bottom:18px;display:flex;justify-content:center;gap:12px;z-index:50;pointer-events:none}
  .btn{width:64px;height:64px;border-radius:14px;background:linear-gradient(180deg,rgba(255,255,255,0.03),rgba(255,255,255,0.01));display:flex;align-items:center;justify-content:center;color:var(--ui);font-size:22px;border:1px solid rgba(255,255,255,0.04);pointer-events:auto;user-select:none}
  .btn.secondary{width:48px;height:48px;font-size:18px}
  .left-group{display:flex;gap:8px}
  .right-group{display:flex;gap:8px}
  /* Overlay menus */
  .overlay{position:fixed;inset:0;background:linear-gradient(180deg,rgba(0,0,0,0.6),rgba(0,0,0,0.6));display:none;align-items:center;justify-content:center;z-index:80}
  .menu{width:calc(100% - 40px);max-width:560px;background:linear-gradient(180deg,#06131c,#021018);padding:20px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);color:var(--ui)}
  .menu h2{margin:0 0 8px 0;color:var(--accent)}
  .menu p{color:var(--muted);font-size:14px}
  .row{display:flex;gap:8px;margin-top:12px}
  .menu button{margin-top:12px;padding:8px 12px;border-radius:10px;border:none;background:linear-gradient(90deg,var(--accent),var(--accent2));color:#001;font-weight:700;cursor:pointer}
  /* Responsive canvas size */
  @media(min-width:901px){
    canvas{width:860px;height:540px}
  }
  @media(max-width:900px){
    canvas{width:100%;height:calc(100vh - 120px)}
    .touch-controls{bottom:28px}
    .btn{width:58px;height:58px}
  }
  /* Simple tiny animations */
  .pulse{animation:pulse .9s ease-in-out infinite}
  @keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.02)}100%{transform:scale(1)}}
</style>
</head>
<body>
<div id="gamewrap">
  <canvas id="game"></canvas>
</div>

<div class="hud" id="hud">
  Vida: <b id="life">3</b> ‚Ä¢ Puntos: <b id="score">0</b> ‚Ä¢ Nivel: <b id="level">1</b>
</div>
<div class="hud-right" id="hudright">
  Tiempo: <b id="time">0</b>s
</div>

<!-- touch controls -->
<div class="touch-controls" aria-hidden="false">
  <div class="left-group">
    <div class="btn" id="btnLeft">‚óÄ</div>
    <div class="btn" id="btnRight">‚ñ∂</div>
  </div>
  <div class="right-group">
    <div class="btn secondary" id="btnRun">üèÉ</div>
    <div class="btn" id="btnJump">‚§¥</div>
  </div>
</div>

<!-- overlays -->
<div class="overlay" id="menuOverlay">
  <div class="menu" role="dialog" aria-modal="true">
    <h2>PixelJump ‚Äî Men√∫</h2>
    <p>Demostraci√≥n jugable. Controles: teclado A/D / ‚Üê‚Üí, W / espacio para saltar. En m√≥vil usa botones t√°ctiles.</p>
    <div class="row">
      <button id="resumeBtn">Continuar</button>
      <button id="restartBtn">Reiniciar nivel</button>
      <button id="gotoLevelBtn">Siguiente nivel</button>
    </div>
    <div class="row">
      <button id="exportScore">Guardar puntaje</button>
      <button id="closeMenu">Cerrar</button>
    </div>
    <p style="margin-top:10px;color:var(--muted);">Al presionar fuera de esta ventana tambi√©n se cerrar√°.</p>
  </div>
</div>

<script>
/* ===========================
   PixelJump - Juego de plataformas 2D
   Autor: ChatGPT (adaptaci√≥n original)
   =========================== */

/* ---- Setup canvas & sizing ---- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha: false });

function resizeCanvas(){
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.max(640, Math.floor(rect.width * devicePixelRatio));
  canvas.height = Math.max(360, Math.floor(rect.height * devicePixelRatio));
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* ---- Game constants ---- */
const GRAVITY = 1600; // px/s^2
const TILE = 48;      // base tile size
const PLAYER_SPEED = 220;
const PLAYER_RUN_MULT = 1.45;
const JUMP_SPEED = 520;
const MAX_FALL = 900;
const CAMERA_LERP = 0.12;

/* ---- State ---- */
let lastTs = 0;
let keys = {};
let touchState = {left:false,right:false,jump:false,run:false};
let paused = false;
let levelIndex = 0;
let timeElapsed = 0;
let highscore = Number(localStorage.getItem('pj.high')||0);

/* HUD elems */
const lifeEl = document.getElementById('life');
const scoreEl = document.getElementById('score');
const levelEl = document.getElementById('level');
const timeEl = document.getElementById('time');

/* Sounds - optional (commented out to keep file tiny). Could be added via Audio objects. */

/* ---- Simple tile-based levels ----
   We'll define levels as arrays of strings for tiles:
   ' ' = empty
   '#' = solid block
   'M' = moving enemy spawn placeholder
   'C' = coin
   'P' = player start
   'G' = goal (flag)
*/
const LEVELS = [
  {
    name: "Pradera Inicial",
    map: [
      "                                                                                ",
      "                                                                                ",
      "                                                                                ",
      "                                                                                ",
      "                                                                                ",
      "              C                                                                 ",
      "       ####        ##                ##                                        ",
      "                       C                     C                                  ",
      "   P              #######       ###         #####        C                      ",
      "############################### #############  ##############################  ",
    ],
  },
  {
    name: "Ca√±√≥n Neon",
    map: [
      "                                                                                ",
      "                                                                                ",
      "                                                                                ",
      "                              C                                                 ",
      "                       ####              ####                                   ",
      "           C                                                                    ",
      "   P          ###      ###          C                                            ",
      "             ####     ####      ##########         ###       M                  ",
      "       ####            ####  ##############    ##############                    ",
      "#########################################################################  ####",
    ],
  },
];

/* ---- Entities & world ---- */
function createWorld(levelData){
  const rows = levelData.map.slice(); // clone
  const w = rows[0].length;
  const h = rows.length;
  const blocks = [];
  const coins = [];
  const enemies = [];
  let playerStart = {x: TILE*2, y: TILE*(h-3)};
  let goal = null;

  for(let y=0;y<h;y++){
    const row = rows[y];
    for(let x=0;x<w;x++){
      const ch = row[x] || ' ';
      const px = x*TILE, py = y*TILE;
      if(ch === '#') blocks.push({x:px,y:py,w:TILE,h:TILE});
      if(ch === 'C') coins.push({x:px+TILE/4,y:py+TILE/4,w:TILE/2,h:TILE/2, collected:false});
      if(ch === 'P') playerStart = {x:px,y:py};
      if(ch === 'M') enemies.push({x:px,y:py,w:TILE-8,h:TILE-8,vx:80,dir:1,alive:true}); // patrol enemy
      if(ch === 'G') goal = {x:px,y:py,w:TILE,h:TILE};
    }
  }

  // fallback ground on last row if none
  if(blocks.length === 0){
    const py = (h-1)*TILE;
    for(let i=0;i<w;i++) blocks.push({x:i*TILE,y:py,w:TILE,h:TILE});
  }

  return {w:w*TILE, h:h*TILE, blocks, coins, enemies, playerStart, goal};
}

/* ---- Player object ---- */
function createPlayer(x,y){
  return {
    x: x+4, y: y+4,
    w: TILE-10, h: TILE-6,
    vx:0, vy:0,
    onGround:false,
    lives:3,
    score:0,
    invuln:0
  };
}

/* ---- Collision helpers ---- */
function rectsOverlap(a,b){
  return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h);
}

function moveAndCollide(entity,dx,dy,world){
  // move in x then y, resolving collisions with blocks
  let newX = entity.x + dx;
  let newY = entity.y;

  // horizontal
  entity.x = newX;
  for(let b of world.blocks){
    if(rectsOverlap(entity,b)){
      if(dx > 0){ entity.x = b.x - entity.w - 0.01; entity.vx = 0; }
      else if(dx < 0){ entity.x = b.x + b.w + 0.01; entity.vx = 0; }
    }
  }

  // vertical
  newY = entity.y + dy;
  entity.y = newY;
  entity.onGround = false;
  for(let b of world.blocks){
    if(rectsOverlap(entity,b)){
      if(dy > 0){ // falling -> land on top
        entity.y = b.y - entity.h - 0.01;
        entity.vy = 0;
        entity.onGround = true;
      } else if(dy < 0){ // hitting head
        entity.y = b.y + b.h + 0.01;
        entity.vy = 0;
      }
    }
  }
}

/* ---- Game variables ---- */
let world = null;
let player = null;
let cam = {x:0,y:0,w:canvas.width, h:canvas.height};
let running = true;

/* ---- Load level ---- */
function loadLevel(index){
  levelIndex = Math.max(0, Math.min(index, LEVELS.length-1));
  const level = LEVELS[levelIndex];
  world = createWorld(level);
  player = createPlayer(world.playerStart.x, world.playerStart.y);
  player.lives = player.lives || 3;
  player.score = player.score || 0;
  cam.x = player.x - canvas.width/ (2*devicePixelRatio);
  cam.y = player.y - canvas.height/ (2*devicePixelRatio);
  timeElapsed = 0;
  updateHUD();
  levelEl.textContent = levelIndex + 1;
}

/* ---- HUD update ---- */
function updateHUD(){
  lifeEl.textContent = player.lives;
  scoreEl.textContent = player.score;
  timeEl.textContent = Math.floor(timeElapsed);
  levelEl.textContent = levelIndex+1;
}

/* ---- Input handlers ---- */
window.addEventListener('keydown', (e)=>{ keys[e.key.toLowerCase()] = true; if(e.key==='Escape') toggleMenu(); e.preventDefault && e.preventDefault(); });
window.addEventListener('keyup', (e)=>{ keys[e.key.toLowerCase()] = false; });

/* touch buttons */
const btnLeft = document.getElementById('btnLeft');
const btnRight = document.getElementById('btnRight');
const btnJump = document.getElementById('btnJump');
const btnRun = document.getElementById('btnRun');

btnLeft.addEventListener('touchstart',(e)=>{ touchState.left = true; e.preventDefault(); });
btnLeft.addEventListener('touchend',()=>{ touchState.left = false; });
btnRight.addEventListener('touchstart',(e)=>{ touchState.right = true; e.preventDefault(); });
btnRight.addEventListener('touchend',()=>{ touchState.right = false; });
btnJump.addEventListener('touchstart',(e)=>{ touchState.jump = true; e.preventDefault(); setTimeout(()=>touchState.jump=false,150); });
btnRun.addEventListener('touchstart',(e)=>{ touchState.run = true; e.preventDefault(); });
btnRun.addEventListener('touchend',()=>{ touchState.run = false; });

/* also respond to mouse clicks for jump */
canvas.addEventListener('mousedown',(e)=>{ touchState.jump = true; setTimeout(()=>touchState.jump=false,120); });

/* ---- Menu overlay controls ---- */
const menuOverlay = document.getElementById('menuOverlay');
document.getElementById('resumeBtn').addEventListener('click', ()=>{ toggleMenu(false); });
document.getElementById('closeMenu').addEventListener('click', ()=>{ toggleMenu(false); });
document.getElementById('restartBtn').addEventListener('click', ()=>{ restartLevel(); toggleMenu(false); });
document.getElementById('gotoLevelBtn').addEventListener('click', ()=>{ nextLevel(); toggleMenu(false); });
document.getElementById('exportScore').addEventListener('click', ()=>{ localStorage.setItem('pj.lastScore', player.score); alert('Puntaje guardado localmente: '+player.score); });

menuOverlay.addEventListener('click',(e)=>{ if(e.target===menuOverlay) toggleMenu(false); });

function toggleMenu(forceState){
  if(typeof forceState === 'boolean'){ paused = !forceState; }
  paused = (typeof forceState === 'boolean') ? forceState : !paused;
  menuOverlay.style.display = paused ? 'flex':'none';
}

/* ---- Game logic update ---- */
function update(dt){
  if(paused) return;
  timeElapsed += dt;
  // input: combine keyboard and touch
  const left = keys['arrowleft'] || keys['a'] || touchState.left;
  const right = keys['arrowright'] || keys['d'] || touchState.right;
  const jumpKey = keys['w'] || keys[' '] || keys['arrowup'] || touchState.jump;
  const runKey = keys['shift'] || touchState.run;

  // horizontal velocity
  let targetSpeed = 0;
  if(left) targetSpeed = -PLAYER_SPEED;
  if(right) targetSpeed = PLAYER_SPEED;
  if(runKey) targetSpeed *= PLAYER_RUN_MULT;

  // simple acceleration
  const accel = 1600;
  player.vx += Math.sign(targetSpeed - player.vx) * Math.min(Math.abs(targetSpeed - player.vx), accel * dt);

  // apply gravity
  player.vy += GRAVITY * dt;
  if(player.vy > MAX_FALL) player.vy = MAX_FALL;

  // jump
  if(jumpKey && player.onGround){
    player.vy = -JUMP_SPEED;
    player.onGround = false;
  }

  // move and collide against world blocks
  moveAndCollide(player, player.vx * dt, player.vy * dt, world);

  // coins pickup
  for(let c of world.coins){
    if(!c.collected && rectsOverlap(player, c)){
      c.collected = true;
      player.score += 10;
    }
  }

  // enemies movement + collision with player
  for(let e of world.enemies){
    if(!e.alive) continue;
    e.x += e.vx * dt * e.dir;
    // reverse on block collision or edge
    let collided = false;
    const probe = {x:e.x,y:e.y,w:e.w,h:e.h};
    for(let b of world.blocks){
      if(rectsOverlap(probe,b)){
        collided = true; break;
      }
    }
    if(collided){
      e.dir *= -1;
      e.x += e.vx * dt * e.dir * 2;
    }
    // player vs enemy
    if(rectsOverlap(player, e) && e.alive){
      // if player falling onto enemy (stomp)
      if(player.vy > 120){
        e.alive = false;
        player.vy = -JUMP_SPEED*0.45;
        player.score += 40;
      } else {
        if(player.invuln <= 0){
          player.lives -= 1;
          player.invuln = 1.2;
          player.x = world.playerStart.x+4;
          player.y = world.playerStart.y+4;
          player.vx = player.vy = 0;
        }
      }
    }
  }

  if(player.invuln > 0) player.invuln -= dt;

  // goal detection - if none defined create implicit rightmost goal
  // If player goes beyond right edge of world, advance level
  if(player.x > world.w - TILE*1.5){
    nextLevel();
  }

  // update camera (smooth)
  const screenW = canvas.width / devicePixelRatio;
  const screenH = canvas.height / devicePixelRatio;
  const targetCx = player.x + player.w/2 - screenW/2;
  const targetCy = player.y + player.h/2 - screenH/2;
  cam.x += (targetCx - cam.x) * CAMERA_LERP;
  cam.y += (targetCy - cam.y) * CAMERA_LERP;
  // clamp
  cam.x = Math.max(0, Math.min(world.w - screenW, cam.x));
  cam.y = Math.max(0, Math.min(world.h - screenH, cam.y));

  // update HUD
  updateHUD();

  // lose condition
  if(player.lives <= 0){
    alert('Has perdido todas las vidas. Reiniciando juego.');
    player.lives = 3;
    player.score = 0;
    loadLevel(0);
  }
}

/* ---- Render loop ---- */
function clear(){
  ctx.fillStyle = "#06131a";
  ctx.fillRect(0,0,canvas.width/devicePixelRatio,canvas.height/devicePixelRatio);
}

// simple parallax background
function drawBackground(){
  const sw = canvas.width/devicePixelRatio, sh = canvas.height/devicePixelRatio;
  // gradient sky
  const grad = ctx.createLinearGradient(0,0,0,sh);
  grad.addColorStop(0, "#05203a");
  grad.addColorStop(1, "#00141b");
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,sw,sh);

  // distant hills parallax
  const p1 = Math.max(0, Math.min(1, cam.x / (world.w || 1000)));
  ctx.fillStyle = "rgba(10,20,30,0.6)";
  ctx.beginPath();
  const baseY = sh*0.75;
  ctx.moveTo(0,baseY);
  for(let i=0;i<=10;i++){
    const x = (i/10)*sw;
    const y = baseY - Math.sin((i+p1*6)*0.9)*30 - 30;
    ctx.lineTo(x,y);
  }
  ctx.lineTo(sw,baseY); ctx.closePath(); ctx.fill();

  // small parallax clouds
  ctx.fillStyle = "rgba(255,255,255,0.03)";
  for(let i=0;i<6;i++){
    const cx = ((i*180) - (cam.x*0.2 % 1000) + sw*2) % (sw+200) - 100;
    const cy = 40 + i*18;
    ctx.beginPath(); ctx.ellipse(cx,cy,70,18,0,0,Math.PI*2); ctx.fill();
  }
}

function draw(){
  clear();
  drawBackground();

  // transform world to camera view
  ctx.save();
  ctx.translate(-Math.floor(cam.x), -Math.floor(cam.y));

  // draw blocks
  ctx.fillStyle = "#0b3f3f";
  for(let b of world.blocks){
    ctx.fillStyle = "#0d3b2f";
    ctx.fillRect(b.x, b.y, b.w, b.h);
    // top bevel
    ctx.fillStyle = "rgba(255,255,255,0.02)";
    ctx.fillRect(b.x, b.y, b.w, 4);
  }

  // draw coins
  for(let c of world.coins){
    if(c.collected) continue;
    ctx.fillStyle = "#ffd24a";
    ctx.beginPath(); ctx.ellipse(c.x + c.w/2, c.y + c.h/2, c.w/2, c.h/2, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "rgba(0,0,0,0.12)"; ctx.fillRect(c.x + c.w*0.15, c.y + c.h*0.45, c.w*0.7, c.h*0.15);
  }

  // draw enemies
  for(let e of world.enemies){
    if(!e.alive) continue;
    ctx.fillStyle = "#ff6b6b";
    ctx.fillRect(e.x, e.y, e.w, e.h);
    // eyes
    ctx.fillStyle = "#111"; ctx.fillRect(e.x + 8, e.y + 8, 6, 6); ctx.fillRect(e.x + e.w - 16, e.y + 8, 6, 6);
  }

  // draw player (simple 3-color sprite)
  ctx.save();
  if(player.invuln > 0 && Math.floor(player.invuln * 10) % 2 === 0) ctx.globalAlpha = 0.4;
  // body
  ctx.fillStyle = "#00d1ff"; ctx.fillRect(player.x, player.y, player.w, player.h);
  // head
  ctx.fillStyle = "#083042"; ctx.fillRect(player.x + 6, player.y - 10, player.w - 12, 10);
  // eye
  ctx.fillStyle = "#fff"; ctx.fillRect(player.x + 8, player.y - 8, 4, 4);
  ctx.restore();

  // draw goal (optional)
  if(world.goal){
    ctx.fillStyle="#8aff8a"; ctx.fillRect(world.goal.x, world.goal.y, world.goal.w, world.goal.h);
  }

  ctx.restore();

  // HUD overlay drawn in DOM for clearer text; but we can draw tooltips here if needed
}

/* ---- Main loop ---- */
function mainLoop(ts){
  if(!lastTs) lastTs = ts;
  const dt = Math.min(0.033, (ts - lastTs)/1000); // cap dt ~33ms
  lastTs = ts;

  if(!paused) update(dt);
  draw();

  requestAnimationFrame(mainLoop);
}

/* ---- Utility: restart/next level ---- */
function restartLevel(){
  loadLevel(levelIndex);
  paused = false; menuOverlay.style.display = 'none';
}

function nextLevel(){
  loadLevel((levelIndex+1) % LEVELS.length);
}

/* ---- Start game ---- */
loadLevel(0);
requestAnimationFrame(mainLoop);

/* ---- Small polish: keyboard UI and click handlers ---- */
document.addEventListener('keydown', (e)=>{
  if(e.key === 'p') { toggleMenu(true); }
  if(e.key === 'r') restartLevel();
  if(e.key === 'n') nextLevel();
});

/* expose small debug */
window.pixeljump = { loadLevel, restartLevel, nextLevel };

/* ---- Make sure touch controls not blocking vertical scroll outside canvas on mobile ---- */
(function allowPageScrollOutsideCanvas(){
  // If the user scrolls the page outside canvas, allow default behavior.
  // We already bound touchstart on our control buttons only; canvas click used only for jump.
})();

/* ---- Performance notes ----
  - All heavy loops are small; images and audio avoided to keep size low.
  - IntersectionObserves not needed here; we use simple game loop + culling via camera.
  - For production: replace primitive shapes with optimized sprite atlases.
---- */
</script>
</body>
</html>
```Ó®Å0Ó®Ç
