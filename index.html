<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>SinFiltro ‚Äî Fase1 (Conducci√≥n m√≥vil)</title>
  <meta name="description" content="Demo: f√≠sica vehicular, controles t√°ctiles, optimizado m√≥vil (fase1) ‚Äî SinFiltro" />
  <!-- Three.js + cannon-es desde CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
  <script type="module">
    // cannon-es via ESM import (CDN)
    import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';
    window.CANNON = CANNON; // expose to non-module code below
  </script>

  <style>
    /* Minimal neutral UI: mant√©n tu look aplicando tu CSS encima si lo deseas */
    html,body{height:100%;margin:0;background:#05060a;color:#eaf7ff;font-family:Inter,system-ui;overflow:hidden;-webkit-tap-highlight-color:transparent}
    #app{position:fixed;inset:0;display:flex;flex-direction:column}
    canvas{display:block;width:100%;height:100%}

    /* overlay controls */
    .ui-top{position:fixed;top:12px;left:12px;right:12px;display:flex;justify-content:space-between;align-items:center;z-index:30;pointer-events:auto}
    .btn{background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.04);padding:8px 10px;border-radius:10px;color:var(--text,#eaf7ff);backdrop-filter:blur(6px)}
    .brand{font-weight:700}
    /* joystick areas */
    .touch-left, .touch-right{position:fixed;bottom:18px;height:36vh;width:46%;z-index:25;pointer-events:auto}
    .touch-left{left:4%}
    .touch-right{right:4%;display:flex;justify-content:flex-end}
    /* small indicators */
    .indicator{position:fixed;bottom:8px;left:50%;transform:translateX(-50%);z-index:25;color:#9fb0bf;font-size:13px;pointer-events:none}

    /* visual joystick (simple) */
    .joystick-base{width:110px;height:110px;border-radius:50%;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.04);display:flex;align-items:center;justify-content:center;touch-action:none}
    .joystick-stick{width:46px;height:46px;border-radius:50%;background:linear-gradient(135deg,#00d1ff,#8a6eff);box-shadow:0 8px 24px rgba(0,0,0,0.6);transform:translate(0,0)}
    .controls-mini{display:flex;gap:8px}
    .small-btn{padding:8px 10px;border-radius:10px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);color:#eaf7ff}

    /* viewer / debug area */
    .debug{position:fixed;top:72px;right:12px;background:rgba(0,0,0,0.45);padding:8px;border-radius:8px;color:#9fb0bf;font-size:12px;z-index:40}
    @media (min-width:900px){ .touch-left,.touch-right{display:none} }
  </style>
</head>
<body>
  <div id="app">
    <div class="ui-top">
      <div style="display:flex;gap:8px;align-items:center">
        <div class="btn brand" id="brandBtn">SinFiltro</div>
        <div class="btn" id="menuBtn">‚ò∞</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <div class="btn" id="searchBtn">üîé</div>
        <div class="btn" id="modeBtn">üåó</div>
      </div>
    </div>

    <!-- touch areas (left = steer, right = accel/brake + quick actions) -->
    <div class="touch-left" id="touchLeft" aria-hidden="false" style="pointer-events:auto">
      <div style="margin-left:12px;touch-action:none">
        <div class="joystick-base" id="joyBaseLeft">
          <div class="joystick-stick" id="joyStickLeft"></div>
        </div>
      </div>
    </div>

    <div class="touch-right" id="touchRight" aria-hidden="false" style="pointer-events:auto">
      <div style="display:flex;align-items:flex-end;gap:12px;touch-action:none;margin-right:12px">
        <div style="display:flex;flex-direction:column;gap:10px;align-items:flex-end">
          <div class="joystick-base" id="joyBaseRight" style="width:74px;height:74px">
            <div class="joystick-stick" id="joyStickRight" style="width:34px;height:34px"></div>
          </div>
          <div class="controls-mini">
            <div class="small-btn" id="handBrake">‚õì</div>
            <div class="small-btn" id="toggleView">üëÅ</div>
          </div>
        </div>
      </div>
    </div>

    <div class="indicator" id="fps">FPS: -- ‚Ä¢ Speed: 0</div>
    <div class="debug" id="debug">Cargando f√≠sica...</div>
    <!-- THREE canvas will be inserted by script -->
  </div>

<script>
/* =============================
   SinFiltro ‚Äî Fase1 Juego (Core)
   - Three.js renderer + cannon-es physics
   - Mobile optimized (pixelRatio clamp)
   - Touch joysticks (steer + throttle)
   - Overlays non-blocking when hidden
   Params: Ajusta variables en la parte superior de este script.
   ============================= */

(async function(){
  // ================= PARAMETERS (ajustables) =================
  const PARAMS = {
    PIXEL_RATIO_MAX: 1.6,        // clamp for mobile perf
    PHYSICS_STEP: 1/60,
    MAX_FORWARD_FORCE: 420,      // torque-ish drive force
    MAX_STEER_ANGLE: 0.5,        // radians
    BRAKE_FORCE: 150,
    MASS: 1200,
    WHEEL_RADIUS: 0.28
  };

  // =============== UTILS ===============
  const $ = s => document.querySelector(s);
  const clamp = (v,a,b)=> Math.max(a, Math.min(b,v));
  const now = ()=> (performance || Date).now();

  // =============== Basic scene setup ===============
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x05060a);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
  camera.position.set(0, 3.2, -6);
  camera.lookAt(0,0,0);

  const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
  // clamp pixel ratio for mobile
  const dpr = Math.min(window.devicePixelRatio || 1, PARAMS.PIXEL_RATIO_MAX);
  renderer.setPixelRatio(dpr);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.domElement.style.touchAction = 'none'; // prevent default gestures
  document.getElementById('app').appendChild(renderer.domElement);

  // lights
  const hemi = new THREE.HemisphereLight(0xffffff,0x222244, 0.8);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(5,10,5);
  scene.add(dir);

  // ground
  const groundGeo = new THREE.PlaneGeometry(400, 400);
  const groundMat = new THREE.MeshStandardMaterial({color:0x081026, roughness:0.9, metalness:0.05});
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  // ================= physics (cannon-es loaded earlier via module) =================
  // Wait until CANNON is available (imported earlier)
  function waitForCannon(){ return new Promise((res,rej)=>{
    const max = 2000; let t=0;
    (function check(){
      if(window.CANNON) return res(window.CANNON);
      t+=50; if(t>max) return rej('cannon not loaded');
      setTimeout(check,50);
    })();
  })}

  const CANNON = await waitForCannon();
  const world = new CANNON.World({ gravity: new CANNON.Vec3(0,-9.82,0) });
  world.broadphase = new CANNON.SAPBroadphase(world);
  world.defaultContactMaterial.friction = 0.3;

  // ground body
  const groundBody = new CANNON.Body({ mass:0, shape:new CANNON.Plane(), material: new CANNON.Material() });
  groundBody.quaternion.setFromEuler(-Math.PI/2,0,0);
  world.addBody(groundBody);

  // simple vehicle using raycast vehicle
  const chassisShape = new CANNON.Box(new CANNON.Vec3(1.1,0.45,2.0));
  const chassisBody = new CANNON.Body({ mass: PARAMS.MASS });
  chassisBody.addShape(chassisShape);
  chassisBody.position.set(0, 1.2, 0);
  chassisBody.quaternion.setFromEuler(0,0,0);
  world.addBody(chassisBody);

  // visual chassis
  const chassisMesh = new THREE.Mesh(
    new THREE.BoxGeometry(2.2,0.9,4.0),
    new THREE.MeshStandardMaterial({color:0x123144, metalness:0.4, roughness:0.35})
  );
  chassisMesh.castShadow = true;
  scene.add(chassisMesh);

  // Wheel info for raycast vehicle
  const options = {
    radius: PARAMS.WHEEL_RADIUS,
    directionLocal: new CANNON.Vec3(0,-1,0),
    axleLocal: new CANNON.Vec3(-1,0,0),
    chassisConnectionPointLocal: new CANNON.Vec3(),
    maxSuspensionForce: 100000,
    suspensionRestLength: 0.3,
    suspensionStiffness: 30,
    suspensionDamping: 4.3,
    frictionSlip: 2,
    rollInfluence: 0.01
  };

  const vehicle = new CANNON.RaycastVehicle({
    chassisBody: chassisBody,
    indexRightAxis: 0, // x
    indexUpAxis: 1, // y
    indexForwardAxis: 2 // z
  });

  // positions for four wheels
  const wheelPositions = [
    new CANNON.Vec3(-1.0, 0,  1.6),
    new CANNON.Vec3( 1.0, 0,  1.6),
    new CANNON.Vec3(-1.0, 0, -1.6),
    new CANNON.Vec3( 1.0, 0, -1.6)
  ];

  wheelPositions.forEach((pos)=>{
    const opt = Object.assign({}, options);
    opt.chassisConnectionPointLocal.set(pos.x, pos.y, pos.z);
    vehicle.addWheel(opt);
  });

  vehicle.addToWorld(world);

  // wheel visuals (simple)
  const wheelMeshes = [];
  vehicle.wheelInfos.forEach((w)=>{
    const geo = new THREE.CylinderGeometry(PARAMS.WHEEL_RADIUS, PARAMS.WHEEL_RADIUS, 0.36, 16);
    geo.rotateZ(Math.PI/2);
    const mat = new THREE.MeshStandardMaterial({color:0x0f1720, metalness:0.2, roughness:0.5});
    const m = new THREE.Mesh(geo, mat);
    m.castShadow = true;
    scene.add(m);
    wheelMeshes.push(m);
  });

  // add some obstacles (for demo)
  for(let i=0;i<8;i++){
    const b = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.8,0.8), new THREE.MeshStandardMaterial({color:0x223344}));
    b.position.set((Math.random()-0.5)*40,0.4,(Math.random()-0.5)*80);
    scene.add(b);
    const cb = new CANNON.Body({mass:0});
    cb.addShape(new CANNON.Box(new CANNON.Vec3(0.4,0.4,0.4)));
    cb.position.copy(b.position);
    world.addBody(cb);
  }

  // ======= controls state =======
  let steer = 0;     // -1..1
  let throttle = 0;  // -1..1 (forward positive)
  let brake = 0;     // 0..1

  // ======= joystick implementation (lightweight) =======
  function makeJoystick(baseEl, stickEl, options){
    // options: onMove(dx,dy), maxRadius
    let active = false, identifier = null;
    let startX=0, startY=0;
    const maxR = options.maxRadius || 44;

    function setStick(x,y){
      stickEl.style.transform = `translate(${x}px, ${y}px)`;
    }

    baseEl.addEventListener('touchstart', (e)=> {
      e.preventDefault();
      const t = e.changedTouches[0];
      active = true; identifier = t.identifier;
      startX = t.clientX; startY = t.clientY;
      setStick(0,0);
    }, {passive:false});

    baseEl.addEventListener('touchmove', (e)=>{
      if(!active) return;
      for(const t of e.changedTouches){
        if(t.identifier===identifier){
          const dx = t.clientX - startX;
          const dy = t.clientY - startY;
          const dist = Math.sqrt(dx*dx+dy*dy);
          const ratio = Math.min(1, dist / maxR);
          const nx = dx * ratio / (dist||1) * Math.min(dist, maxR);
          const ny = dy * ratio / (dist||1) * Math.min(dist, maxR);
          setStick(nx, ny);
          options.onMove(nx / maxR, ny / maxR);
        }
      }
    }, {passive:false});

    baseEl.addEventListener('touchend', (e)=>{
      for(const t of e.changedTouches){
        if(t.identifier===identifier){
          active=false; identifier=null; setStick(0,0);
          options.onEnd && options.onEnd();
        }
      }
    }, {passive:false});

    // mouse fallback for desktop testing
    let mouseDown=false;
    baseEl.addEventListener('pointerdown', (e)=>{ mouseDown=true; startX=e.clientX; startY=e.clientY; setStick(0,0); });
    baseEl.addEventListener('pointermove', (e)=>{ if(!mouseDown) return; const dx = e.clientX-startX, dy = e.clientY-startY; const dist=Math.sqrt(dx*dx+dy*dy); const nx=dx/Math.max(dist,1)*Math.min(dist,maxR); const ny=dy/Math.max(dist,1)*Math.min(dist,maxR); setStick(nx,ny); options.onMove(nx/maxR, ny/maxR); }, {passive:true});
    baseEl.addEventListener('pointerup', (e)=>{ mouseDown=false; setStick(0,0); options.onEnd && options.onEnd(); });
  }

  // wire joysticks
  const joyBaseLeft = $('#joyBaseLeft'), joyStickLeft = $('#joyStickLeft');
  const joyBaseRight = $('#joyBaseRight'), joyStickRight = $('#joyStickRight');

  makeJoystick(joyBaseLeft, joyStickLeft, {
    maxRadius: 44,
    onMove: (nx,ny)=> {
      // left joystick: nx -> steer, up/down ignored
      steer = clamp(nx, -1, 1); // left negative
    },
    onEnd: ()=> { steer = 0; }
  });

  makeJoystick(joyBaseRight, joyStickRight, {
    maxRadius: 34,
    onMove: (nx,ny)=> {
      // right joystick: ny negative = forward (finger swipe up means negative dy if base center)
      // we invert y so upward finger = forward positive
      throttle = clamp(-ny, -1, 1);
    },
    onEnd: ()=> { throttle = 0; }
  });

  // handbrake and view toggle
  $('#handBrake').addEventListener('click', ()=> { brake = brake>0?0:1; $('#handBrake').textContent = brake? '‚õì' : '‚õì'; });
  let chase = true;
  $('#toggleView').addEventListener('click', ()=> { chase = !chase; $('#toggleView').textContent = chase? 'üëÅ' : 'üëÅ'; });

  // keyboard support (desktop)
  const keys = {};
  window.addEventListener('keydown', (e)=> { keys[e.key.toLowerCase()] = true; });
  window.addEventListener('keyup', (e)=> { keys[e.key.toLowerCase()] = false; });

  // ============ physics update loop ============
  let lastTime = performance.now()/1000;
  let accumulator = 0;
  const maxSubSteps = 3;

  function physicsStep(dt){
    // apply engine force to rear wheels (wheels 2 & 3)
    const engineForce = PARAMS.MAX_FORWARD_FORCE * throttle;
    const brakeForce = PARAMS.BRAKE_FORCE * brake;

    // simple steering: rotate chassis quaternion small amount proportional to steer and speed
    // but better: set wheel steering on front wheels
    const steerAngle = PARAMS.MAX_STEER_ANGLE * steer;

    // apply to vehicle wheelInfos directly
    vehicle.setSteeringValue(steerAngle, 0);
    vehicle.setSteeringValue(steerAngle, 1);

    // engine/brake on rear wheels
    vehicle.applyEngineForce(-engineForce, 2);
    vehicle.applyEngineForce(-engineForce, 3);

    // braking: set brake force on all wheels
    vehicle.setBrake(brakeForce, 0);
    vehicle.setBrake(brakeForce, 1);
    vehicle.setBrake(brakeForce, 2);
    vehicle.setBrake(brakeForce, 3);

    world.step(PARAMS.PHYSICS_STEP);
  }

  // ============ animation & sync visuals ============
  const statsIndicator = $('#fps');
  const debugEl = $('#debug');
  let lastFpsTime = performance.now(), frames=0;

  function animate(){
    requestAnimationFrame(animate);
    const t = performance.now()/1000;
    let dt = t - lastTime;
    lastTime = t;
    // clamp large dt
    dt = Math.min(0.05, dt);
    accumulator += dt;

    // limit substeps adaptively
    let substeps = 0;
    while(accumulator >= PARAMS.PHYSICS_STEP && substeps < maxSubSteps){
      physicsStep(PARAMS.PHYSICS_STEP);
      accumulator -= PARAMS.PHYSICS_STEP;
      substeps++;
    }

    // Sync visuals: chassis
    chassisMesh.position.copy(chassisBody.position);
    chassisMesh.quaternion.copy(chassisBody.quaternion);

    // wheels
    for(let i=0;i<vehicle.wheelInfos.length;i++){
      vehicle.updateWheelTransform(i);
      const t = vehicle.wheelInfos[i].worldTransform;
      const pos = t.position;
      const quat = t.quaternion;
      wheelMeshes[i].position.set(pos.x, pos.y, pos.z);
      wheelMeshes[i].quaternion.set(quat.x, quat.y, quat.z, quat.w);
    }

    // camera follow
    if(chase){
      const carPos = chassisMesh.position;
      const carQuaternion = chassisMesh.quaternion;
      const forward = new THREE.Vector3(0,0,1).applyQuaternion(carQuaternion).normalize();
      const camTarget = new THREE.Vector3().copy(carPos).add(new THREE.Vector3(0,1.6,0));
      const camPos = new THREE.Vector3().copy(carPos).add(forward.clone().multiplyScalar(-6)).add(new THREE.Vector3(0,2,0));
      camera.position.lerp(camPos, 0.08);
      camera.lookAt(camTarget);
    } else {
      // free camera slight orbit (desktop)
      camera.position.lerp(new THREE.Vector3(0,8,-12), 0.02);
      camera.lookAt(0,0,0);
    }

    renderer.render(scene, camera);

    // fps indicator
    frames++;
    const nowMs = performance.now();
    if(nowMs - lastFpsTime >= 500){
      const fps = Math.round(frames*1000/(nowMs-lastFpsTime));
      frames=0; lastFpsTime = nowMs;
      const speed = (chassisBody.velocity.length()).toFixed(1);
      statsIndicator.textContent = `FPS: ${fps} ‚Ä¢ Speed: ${speed}`;
      debugEl.textContent = `Throttle:${throttle.toFixed(2)} Steer:${steer.toFixed(2)} Brake:${brake} Mass:${PARAMS.MASS}`;
    }

  } // animate

  // kickstart
  lastTime = performance.now()/1000;
  animate();

  // resize handling
  window.addEventListener('resize', ()=> {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // ============ UI interactions (demo menus) ============
  // menu / search / brand
  $('#menuBtn').addEventListener('click', ()=>{
    // simple demo: show a toast / or open your panel
    alert('Demo: abrir men√∫ lateral (integra tu panel real aqu√≠).');
  });
  $('#searchBtn').addEventListener('click', ()=> {
    // open a demo search overlay (you can replace with real input)
    const q = prompt('Buscar (demo): escribe t√©rmino');
    if(q) alert('Demo: buscar -> ' + q);
  });
  $('#brandBtn').addEventListener('click', ()=> { window.scrollTo({top:0,behavior:'smooth'}); });

  // mode toggle (dark/light) ‚Äî adjust css variable quickly
  $('#modeBtn').addEventListener('click', ()=>{
    const b = document.body;
    if(b.classList.contains('light')){ b.classList.remove('light'); $('#modeBtn').textContent='üåó'; }
    else { b.classList.add('light'); $('#modeBtn').textContent='‚òÄÔ∏è'; }
  });

  // ensure overlays don't block touch when hidden: pointer-events handled by CSS classes above
  // touch areas already have pointer-events enabled.

  // ============ cleanup hint ============
  window._sinfiltro_cleanup = ()=> {
    renderer.forceContextLoss();
    renderer.domElement = null;
  };

  // final log
  console.log('SinFiltro Fase1 core loaded ‚Äî prueba en m√≥vil: usa joystick izquierdo para dirigir y joystick derecho para acelerar.');

})();
</script>
</body>
</html>
