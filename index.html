<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>SinFiltro â€” Playa Azul (demo)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=Poppins:wght@600&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#05060a; --card: rgba(255,255,255,0.03);
    --accent1:#00d1ff; --accent2:#8a6eff;
    --muted:#9fb0bf; --text:#eaf7ff;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#03030a,#0b1220);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;color:var(--text);-webkit-font-smoothing:antialiased;touch-action:none}
  #holder{position:fixed;inset:0;overflow:hidden}
  canvas{display:block}

  /* Top bar */
  .topbar{position:fixed;left:12px;right:12px;top:12px;height:56px;display:flex;align-items:center;justify-content:space-between;z-index:220;pointer-events:auto}
  .brand{font-family:Poppins, sans-serif;font-weight:600;padding:8px 12px;border-radius:12px;background:rgba(0,0,0,0.45);backdrop-filter:blur(6px);color:var(--text)}
  .controls{display:flex;gap:8px}
  .ctrl-btn{padding:8px 12px;border-radius:12px;background:linear-gradient(90deg,var(--accent1),var(--accent2));color:#001;border:none;cursor:pointer;font-weight:600}

  /* Bottom UI (joystick+fire) */
  .joy{position:fixed;left:18px;bottom:18px;width:110px;height:110px;border-radius:60px;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;z-index:210;pointer-events:auto}
  .stick{width:48px;height:48px;border-radius:50%;background:rgba(255,255,255,0.06);transform:translate(0,0)}
  .fire{position:fixed;right:20px;bottom:28px;width:64px;height:64px;border-radius:36px;background:linear-gradient(135deg,var(--accent1),var(--accent2));display:flex;align-items:center;justify-content:center;z-index:210;pointer-events:auto;box-shadow:0 12px 40px rgba(0,0,0,0.45)}

  /* minimap + FPS */
  #minimap{position:fixed;right:12px;bottom:110px;width:120px;height:120px;border-radius:8px;background:rgba(0,0,0,0.55);z-index:210;pointer-events:none;border:1px solid rgba(255,255,255,0.03)}
  #fps{position:fixed;left:12px;bottom:12px;padding:8px 10px;border-radius:10px;background:rgba(0,0,0,0.55);font-size:12px;color:var(--muted);z-index:210}

  /* info badge */
  .infoBadge{position:fixed;right:12px;top:80px;padding:8px 10px;border-radius:10px;background:linear-gradient(90deg,var(--accent1),var(--accent2));color:#001;font-weight:600;z-index:210}

  /* small responsive tweaks */
  @media(max-width:420px){ .joy{left:12px;bottom:12px;width:92px;height:92px}.stick{width:42px;height:42px}.fire{right:12px;bottm:18px;width:56px;height:56px} #minimap{width:96px;height:96px} }
</style>
</head>
<body>
  <div id="holder"></div>

  <div class="topbar">
    <div class="brand">SinFiltro â€” Playa Azul (demo)</div>
    <div class="controls">
      <button id="toggleStreets" class="ctrl-btn">Calles: ON</button>
      <button id="toggleSat" class="ctrl-btn">SatÃ©lite: OFF</button>
      <button id="recenter" class="ctrl-btn">Re-centrar</button>
    </div>
  </div>

  <div id="minimap" aria-hidden="true"></div>
  <div id="fps">FPS: â€”</div>

  <div class="joy" id="joy"><div class="stick" id="stick"></div></div>
  <button class="fire" id="btnFire">ðŸ”«</button>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

  <script>
  /* ============================
     SinFiltro â€” Playa Azul (demo)
     - Calles vectoriales simplificadas (proporciÃ³n)
     - Toggle satellite/textured ground
     - Minimap 2D
     - Joystick + Fire
     - Collisiones "suaves" por lÃ­mites invisibles
     - Mobile-first touch/pointer support
     ============================ */

  (function(){
    // ---------- scene & renderer ----------
    const container = document.getElementById('holder');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x05060a);
    scene.fog = new THREE.FogExp2(0x05060a, 0.0016);

    const renderer = new THREE.WebGLRenderer({antialias:true, alpha:false});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);
    renderer.domElement.style.touchAction = 'none';

    // ---------- camera ----------
    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
    camera.position.set(0,6,12);

    // ---------- lights (soft, low cost) ----------
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(30,50,30);
    dir.castShadow = true;
    dir.shadow.mapSize.set(1024,1024);
    dir.shadow.camera.left = -60; dir.shadow.camera.right=60; dir.shadow.camera.top=60; dir.shadow.camera.bottom=-60;
    scene.add(dir);
    scene.add(new THREE.AmbientLight(0xffffff, 0.18));

    // ---------- ground (toggle satellite / plain) ----------
    let groundMesh;
    const groundSize = 800;
    const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize, 1,1);
    const plainMat = new THREE.MeshStandardMaterial({color:0x0b1220, metalness:0.05, roughness:0.95});
    const satTexture = new THREE.TextureLoader().load('https://picsum.photos/1024/1024?blur=3'); // placeholder
    satTexture.wrapS = satTexture.wrapT = THREE.RepeatWrapping;
    satTexture.repeat.set(4,4);
    const satMat = new THREE.MeshStandardMaterial({map:satTexture, metalness:0.02, roughness:0.75});
    groundMesh = new THREE.Mesh(groundGeo, plainMat);
    groundMesh.rotation.x = -Math.PI/2;
    groundMesh.receiveShadow = true;
    scene.add(groundMesh);

    // ---------- simple environment assets ----------
    const lightPoleMat = new THREE.MeshStandardMaterial({color:0x111111});
    function makePole(x,z){
      const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05,2.5,6), lightPoleMat);
      pole.position.set(x,1.25,z);
      scene.add(pole);
      const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.08,8,8), new THREE.MeshStandardMaterial({emissive:0xfff4c9, emissiveIntensity:0.6, color:0x222222}));
      bulb.position.set(x,2.3,z); scene.add(bulb);
    }
    // add distant poles (light visual)
    for(let i=0;i<60;i++){
      makePole((Math.random()-0.5)*200, (Math.random()-0.5)*200);
    }

    // ---------- player car ----------
    const car = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.7,4.2), new THREE.MeshStandardMaterial({color:0xff5555, metalness:0.35, roughness:0.6}));
    body.position.y = 0.65; car.add(body);
    const wheelGeo = new THREE.CylinderGeometry(0.35,0.35,0.5,8);
    const wheelMat = new THREE.MeshStandardMaterial({color:0x0c0c0c});
    for(let i=0;i<4;i++){
      const w = new THREE.Mesh(wheelGeo, wheelMat);
      w.rotation.z=Math.PI/2; w.position.y = 0.25;
      w.position.x = (i%2===0)?-1:1; w.position.z = (i<2)?1.1:-1.1;
      car.add(w);
    }
    car.position.set(0,0,0);
    car.castShadow = true;
    scene.add(car);

    // ---------- bot car (demo) ----------
    const bot = car.clone();
    bot.children[0].material = new THREE.MeshStandardMaterial({color:0x3b8aff, metalness:0.2, roughness:0.6});
    bot.position.set(10,0,-6);
    scene.add(bot);

    // ---------- streets data (simplified vector grid for Playa Azul) ----------
    // NOTE: This is a simplified approximated vector set (proportional), not fetched from Maps API.
    // The coordinates are in local plane units (meters-ish) centered around origin.
    // We'll build a modest subset of Playa Azul layout (streets + main avenues).
    const streets = [
      // each street is an array of [x,z] pairs (x east-west, z north-south)
      // main avenue
      [[-120, 20],[ -90, 20],[-60,20],[-30,20],[0,20],[30,20],[60,20],[90,20],[120,20]],
      // parallel streets (grid)
      [[-120, 0],[-90,0],[-60,0],[-30,0],[0,0],[30,0],[60,0],[90,0],[120,0]],
      [[-120,-20],[-90,-20],[-60,-20],[-30,-20],[0,-20],[30,-20],[60,-20],[90,-20],[120,-20]],
      [[-40,-60],[-40,-30],[-40,0],[ -40,30],[ -40,60]],
      [[10,-80],[10,-50],[10,-20],[10,10],[10,40],[10,70]],
      // small side roads
      [[-90, 20],[-90,0],[-90,-20]],
      [[-30,20],[-30,0],[-30,-20]],
      [[30,20],[30,0],[30,-20]],
      [[90,20],[90,0],[90,-20]],
      // curving access
      [[60,20],[70,30],[80,40],[90,60]]
    ];

    // Build line geometries for streets and optionally extruded thin meshes to act as drivable surfaces
    const streetGroup = new THREE.Group();
    const streetMaterial = new THREE.LineBasicMaterial({color:0xdfefff, linewidth:2});
    const roadSurfaceMat = new THREE.MeshStandardMaterial({color:0x12171d, metalness:0.02, roughness:0.9});
    const roadSurfaces = new THREE.Group();

    function createStreets(){
      streetGroup.clear();
      roadSurfaces.clear();
      for(const seg of streets){
        // line
        const points = seg.map(p => new THREE.Vector3(p[0], 0.02, p[1]));
        const geo = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geo, streetMaterial);
        streetGroup.add(line);

        // create a "road surface" as a thin extruded ribbon (approx)
        const shape = new THREE.Shape();
        // compute perpendicular offsets to create ribbon along polyline
        for(let i=0;i<points.length;i++){
          const p = points[i];
          if(i===0) shape.moveTo(p.x-2, p.z);
          shape.lineTo(p.x+2, p.z);
        }
        // create geometry by sweeping a thin box along path (cheap way: place small boxes along points)
        for(let i=0;i<points.length-1;i++){
          const p0 = points[i], p1 = points[i+1];
          const dir = new THREE.Vector3().subVectors(p1,p0);
          const length = dir.length();
          const mesh = new THREE.Mesh(new THREE.BoxGeometry(4,0.02,length+0.02), roadSurfaceMat);
          mesh.position.set((p0.x+p1.x)/2, 0.01, (p0.z+p1.z)/2);
          mesh.lookAt(p1.x, 0.01, p1.z);
          mesh.rotateX(Math.PI/2);
          roadSurfaces.add(mesh);
        }
      }
      scene.add(streetGroup);
      scene.add(roadSurfaces);
    }
    createStreets();
    let streetsVisible = true;

    // ---------- soft collision boundaries ----------
    // Build an array of "drivable corridor" points and create a function that clamps car to nearest road corridor.
    // We'll implement "soft constraints": if player drives off-road, friction increases and movement reduced.
    const roadCorridors = [];
    for(const seg of streets){
      for(let i=0;i<seg.length-1;i++){
        const a = seg[i], b = seg[i+1];
        roadCorridors.push({a:[a[0],a[1]], b:[b[0],b[1]]});
      }
    }
    // helper: distance from point to segment
    function pointToSegmentDist(px,pz, a,b){
      const vx = b[0]-a[0], vz=b[1]-a[1];
      const wx = px - a[0], wz = pz - a[1];
      const c = (vx*wx + vz*wz) / (vx*vx+vz*vz);
      const t = Math.max(0, Math.min(1, c));
      const projx = a[0]+vx*t, projz = a[1]+vz*t;
      const dx = px-projx, dz = pz-projz;
      return Math.sqrt(dx*dx + dz*dz);
    }
    function isOnRoad(px,pz){
      // if within 3.2 units of any road segment => on road
      for(const seg of roadCorridors){
        if(pointToSegmentDist(px,pz, seg.a, seg.b) < 3.4) return true;
      }
      return false;
    }

    // ---------- bullets ----------
    const bullets = [];
    function spawnBullet(origin, dir){
      const g = new THREE.SphereGeometry(0.12, 6,6);
      const m = new THREE.MeshStandardMaterial({emissive:0xffcc66, color:0x111111});
      const b = new THREE.Mesh(g,m);
      b.position.copy(origin);
      b.userData = {dir:dir.clone(), speed:2.8};
      scene.add(b); bullets.push(b);
    }

    // ---------- input (joystick) ----------
    const joy = document.getElementById('joy');
    const stickEl = document.getElementById('stick');
    let stick = {x:0,y:0}, touchId = null, baseX=0, baseY=0;
    function resetStick(){ stick.x=0; stick.y=0; stickEl.style.transform='translate(0px,0px)'; }
    joy.addEventListener('touchstart', e=>{ e.preventDefault(); const t=e.changedTouches[0]; touchId=t.identifier; baseX=t.clientX; baseY=t.clientY; }, {passive:false});
    joy.addEventListener('touchmove', e=>{ e.preventDefault(); for(const t of e.changedTouches) if(t.identifier===touchId){ const dx=t.clientX-baseX, dy=t.clientY-baseY, max=36; const nx=Math.max(-1,Math.min(1,dx/max)); const ny=Math.max(-1,Math.min(1,dy/max)); stick.x=nx; stick.y=-ny; stickEl.style.transform=`translate(${nx*28}px,${-ny*28}px)`; } }, {passive:false});
    joy.addEventListener('touchend', e=>{ for(const t of e.changedTouches) if(t.identifier===touchId){ touchId=null; resetStick(); } }, {passive:false});
    // pointer fallback
    let md=false;
    joy.addEventListener('pointerdown', e=>{ md=true; baseX=e.clientX; baseY=e.clientY; joy.setPointerCapture(e.pointerId); });
    joy.addEventListener('pointermove', e=>{ if(!md) return; const dx=e.clientX-baseX, dy=e.clientY-baseY, max=36; const nx=Math.max(-1,Math.min(1,dx/max)); const ny=Math.max(-1,Math.min(1,dy/max)); stick.x=nx; stick.y=-ny; stickEl.style.transform=`translate(${nx*28}px,${-ny*28}px)`; });
    joy.addEventListener('pointerup', e=>{ md=false; resetStick(); });

    // fire button
    const fireBtn = document.getElementById('btnFire');
    fireBtn.addEventListener('touchstart', e=>{ e.preventDefault(); doFire(); }, {passive:false});
    fireBtn.addEventListener('pointerdown', ()=> doFire());
    function doFire(){
      const dir = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion).normalize();
      const origin = car.position.clone().add(new THREE.Vector3(0,0.9,-2).applyQuaternion(car.quaternion));
      spawnBullet(origin, dir);
    }

    // ---------- motion state ----------
    const state = {speed:0, forward:0, turn:0, maxSpeed:0.95, rotSpeed:0.035};
    let lastTime = performance.now();

    // ---------- camera follow ----------
    function updateCamera(){
      const desired = car.position.clone().add(new THREE.Vector3(0,4.2,9).applyQuaternion(car.quaternion));
      camera.position.lerp(desired, 0.14);
      const lookAt = car.position.clone().add(new THREE.Vector3(0,1.4,0));
      camera.lookAt(lookAt);
    }

    // ---------- minimap (2D) ----------
    const mini = document.getElementById('minimap');
    const miniCanvas = document.createElement('canvas');
    miniCanvas.width = mini.clientWidth * devicePixelRatio;
    miniCanvas.height = mini.clientHeight * devicePixelRatio;
    mini.style.width = mini.clientWidth + 'px';
    mini.style.height = mini.clientHeight + 'px';
    mini.appendChild(miniCanvas);
    const miniCtx = miniCanvas.getContext('2d');
    function drawMinimap(){
      const w = miniCanvas.width, h = miniCanvas.height;
      miniCtx.clearRect(0,0,w,h);
      miniCtx.fillStyle = '#081018'; miniCtx.fillRect(0,0,w,h);
      miniCtx.strokeStyle = 'rgba(200,220,255,0.9)'; miniCtx.lineWidth = 2;
      // bounding box for area of interest
      const scale = 0.5; // pixels per world unit
      const cx = w/2, cy = h/2;
      // draw streets
      for(const seg of streets){
        miniCtx.beginPath();
        for(let i=0;i<seg.length;i++){
          const p = seg[i];
          const x = cx + p[0]*scale, y = cy + p[1]*scale;
          if(i===0) miniCtx.moveTo(x,y); else miniCtx.lineTo(x,y);
        }
        miniCtx.stroke();
      }
      // draw player
      const px = cx + car.position.x*scale, py = cy + car.position.z*scale;
      miniCtx.fillStyle = '#ff6b6b'; miniCtx.beginPath(); miniCtx.arc(px,py,6,0,Math.PI*2); miniCtx.fill();
    }

    // ---------- UI toggles ----------
    const toggleStreetsBtn = document.getElementById('toggleStreets');
    const toggleSatBtn = document.getElementById('toggleSat');
    const recenterBtn = document.getElementById('recenter');
    toggleStreetsBtn.addEventListener('click', ()=> {
      streetsVisible = !streetsVisible;
      streetGroup.visible = streetsVisible;
      roadSurfaces.visible = streetsVisible;
      toggleStreetsBtn.textContent = `Calles: ${streetsVisible? 'ON':'OFF'}`;
    });
    let satelliteOn = false;
    toggleSatBtn.addEventListener('click', ()=> {
      satelliteOn = !satelliteOn;
      if(satelliteOn){ scene.remove(groundMesh); groundMesh = new THREE.Mesh(groundGeo, satMat); groundMesh.rotation.x = -Math.PI/2; groundMesh.receiveShadow=true; scene.add(groundMesh); toggleSatBtn.textContent='SatÃ©lite: ON'; }
      else{ scene.remove(groundMesh); groundMesh = new THREE.Mesh(groundGeo, plainMat); groundMesh.rotation.x = -Math.PI/2; groundMesh.receiveShadow=true; scene.add(groundMesh); toggleSatBtn.textContent='SatÃ©lite: OFF'; }
    });
    recenterBtn.addEventListener('click', ()=> { camera.position.set(car.position.x, car.position.y+6, car.position.z+12); });

    // ---------- basic bot motion ----------
    let botAngle = 0;

    // ---------- FPS counter ----------
    const fpsEl = document.getElementById('fps');
    let fpsLast = performance.now(), frames=0;

    // ---------- render loop ----------
    function animate(){
      const now = performance.now();
      const dtRaw = now - lastTime;
      const dt = Math.min(50, dtRaw) / 16.666; // normalized
      lastTime = now;

      // update state from stick
      state.forward = stick.y;
      state.turn = stick.x;

      // acceleration + friction
      if(state.forward > 0.05) state.speed += 0.02 * state.forward * dt;
      else if(state.forward < -0.05) state.speed -= 0.03 * (-state.forward) * dt;
      else state.speed *= 0.985;

      // clamp
      state.speed = Math.max(-state.maxSpeed, Math.min(state.maxSpeed, state.speed));

      // rotation influenced by speed and turn
      car.rotation.y += -state.turn * state.rotSpeed * (0.9 + Math.abs(state.speed)) * dt;

      // movement vector
      const forwardVec = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion);
      const moveStep = forwardVec.clone().multiplyScalar(state.speed * dt * 0.8);

      // soft road friction: if off-road reduce speed gradually and slightly push back to road
      const onRoad = isOnRoad(car.position.x, car.position.z);
      if(!onRoad){
        state.speed *= 0.92; // more friction off-road
        // optional gentle push towards nearest road (soft constrain)
        let best = {d:1e9, proj:null};
        for(const seg of roadCorridors){
          const a=seg.a, b=seg.b;
          const vx=b[0]-a[0], vz=b[1]-a[1];
          const wx=car.position.x - a[0], wz=car.position.z - a[1];
          const c = (vx*wx + vz*wz) / (vx*vx+vz*vz);
          const t = Math.max(0, Math.min(1, c));
          const px = a[0]+vx*t, pz = a[1]+vz*t;
          const dx = car.position.x - px, dz = car.position.z - pz;
          const d = Math.sqrt(dx*dx + dz*dz);
          if(d < best.d){ best.d = d; best.proj = {x:px, z:pz}; }
        }
        if(best.proj && best.d < 12){
          // subtle correction
          const towardX = (best.proj.x - car.position.x) * 0.02;
          const towardZ = (best.proj.z - car.position.z) * 0.02;
          car.position.x += towardX; car.position.z += towardZ;
        }
      }

      // apply movement
      car.position.add(moveStep);

      // camera
      updateCamera();

      // bullets update
      for(let i=bullets.length-1;i>=0;i--){
        const b = bullets[i];
        b.position.add(b.userData.dir.clone().multiplyScalar(b.userData.speed * dt));
        // check distance to bot (simple hit)
        if(b.position.distanceTo(bot.position) < 1.2){
          scene.remove(b); bullets.splice(i,1);
          const hit = new THREE.Mesh(new THREE.SphereGeometry(0.25,8,6), new THREE.MeshStandardMaterial({emissive:0xff6622}));
          hit.position.copy(bot.position); scene.add(hit);
          setTimeout(()=> scene.remove(hit),600);
          continue;
        }
        if(b.position.length() > 1000){ scene.remove(b); bullets.splice(i,1); }
      }

      // bot motion (circle + face player)
      botAngle += 0.0025 * dt * 30;
      bot.position.x = Math.cos(botAngle)*10; bot.position.z = Math.sin(botAngle)*10;
      bot.lookAt(car.position);

      renderer.render(scene, camera);

      // FPS
      frames++; const now2 = performance.now();
      if(now2 - fpsLast >= 600){
        const fps = Math.round((frames*1000)/(now2-fpsLast));
        fpsEl.textContent = `FPS: ${fps} â€¢ ${isOnRoad(car.position.x, car.position.z)? 'On road':'Off road'}`;
        fpsLast = now2; frames=0;
      }

      // minimap
      drawMinimap();

      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    // ---------- responsive ----------
    window.addEventListener('resize', ()=>{ renderer.setSize(innerWidth, innerHeight); camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); miniCanvas.width = mini.clientWidth * devicePixelRatio; miniCanvas.height = mini.clientHeight * devicePixelRatio; });

    // ---------- initial camera centering ----------
    camera.position.set(car.position.x, car.position.y+6, car.position.z+12);
    updateCamera();

    // ---------- small UX enhancers ----------
    // tap on brand to show sample preview image
    document.querySelector('.brand').addEventListener('click', ()=> {
      // quick preview (reusing the minimap element place)
      alert('Demo: EstÃ¡s en Playa Azul (prototipo). Usa joystick para mover, botÃ³n disparo y toggles arriba.');
    });

    // make sure UI doesn't block canvas touches completely
    renderer.domElement.addEventListener('touchstart', (e)=>{ /* allow canvas touches */ }, {passive:true});

    // ---------- keyboard for desktop testing ----------
    const keys = {};
    window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()] = true; });
    window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false; });
    function keyboardDrive(){
      // simple mapping for desktop: WASD/arrow keys
      if(keys['w'] || keys['arrowup']) stick.y = 1;
      else if(keys['s'] || keys['arrowdown']) stick.y = -1;
      else stick.y = 0;
      if(keys['a'] || keys['arrowleft']) stick.x = -1;
      else if(keys['d'] || keys['arrowright']) stick.x = 1;
      else stick.x = 0;
    }
    setInterval(keyboardDrive, 50);

    // ---------- finalize ----------
    // initial UI state
    streetGroup.visible = streetsVisible;
    roadSurfaces.visible = streetsVisible;
    toggleStreetsBtn.textContent = `Calles: ${streetsVisible? 'ON':'OFF'}`;
    toggleSatBtn.textContent = `SatÃ©lite: ${satelliteOn? 'ON':'OFF'}`;

  })();
  </script>
</body>
</html>
