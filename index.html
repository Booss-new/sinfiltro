<!-- index.html - SinFiltro: Playas (Prototipo calles, joystick, minimapa, toggle sat√©lite) -->
<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>SinFiltro - Playas (prototipo)</title>
<meta name="description" content="Prototipo: calles Playas - joystick, minimapa, sat√©lite toggle, colisiones suaves, optimizado m√≥vil" />
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg-1:#05060a; --text:#eaf7ff; --muted:#9fb0bf; --accent:#00d1ff;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,var(--bg-1),#071226);color:var(--text);-webkit-font-smoothing:antialiased;overflow:hidden}
  #canvasHolder{width:100%;height:100vh;display:block;position:relative}
  /* Top bar (keeps approved style) */
  .topBar{position:fixed;left:12px;right:12px;top:12px;z-index:80;display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:12px;background:rgba(255,255,255,0.02);backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,0.03)}
  .brand{font-weight:700;font-size:18px;background:linear-gradient(90deg,var(--accent),#8a6eff);-webkit-background-clip:text;background-clip:text;color:transparent}
  .top-controls{display:flex;gap:8px;align-items:center}
  .icon-btn{width:44px;height:44px;border-radius:10px;background:rgba(255,255,255,0.03);display:inline-flex;align-items:center;justify-content:center;color:var(--muted);border:1px solid rgba(255,255,255,0.02);cursor:pointer}
  /* joystick */
  .joy { position:fixed; left:14px; bottom:14px; width:110px; height:110px; border-radius:60px; background:rgba(255,255,255,0.02); display:flex; align-items:center; justify-content:center; pointer-events:auto; z-index:60 }
  .stick { width:48px; height:48px; border-radius:50%; background:rgba(255,255,255,0.06); transform:translate(0,0) }
  /* fire */
  .btnFire { position:fixed; right:14px; bottom:22px; width:66px;height:66px;border-radius:50%;background:linear-gradient(135deg,var(--accent),#8a6eff);display:flex;align-items:center;justify-content:center;color:#001;font-weight:700;z-index:60;box-shadow:0 12px 40px rgba(0,0,0,0.45);pointer-events:auto }
  /* minimap */
  #minimap { position:fixed; right:12px; top:86px; width:120px; height:120px; border-radius:8px; background:rgba(0,0,0,0.45); z-index:80; border:1px solid rgba(255,255,255,0.03); overflow:hidden; }
  #minimap canvas{ width:100%; height:100%; display:block }
  /* FPS */
  #fps { position:fixed; left:12px; bottom:12px; font-size:12px; color:var(--muted); z-index:80; background:rgba(0,0,0,0.35);padding:6px;border-radius:8px;border:1px solid rgba(255,255,255,0.02) }
  /* viewer preview */
  #viewer{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(0,0,0,0.88), rgba(0,0,0,0.96));z-index:120}
  #viewer .card{width:92%;max-width:820px;border-radius:12px;padding:12px;background:#000}
  #viewer img{width:100%;height:auto;display:block;border-radius:10px}
  /* responsive tweaks */
  @media(max-width:420px){
    .joy{width:96px;height:96px}
    .stick{width:42px;height:42px}
    #minimap{width:94px;height:94px;top:82px}
  }
</style>
</head>
<body>
  <div id="canvasHolder"></div>

  <div class="topBar" role="banner" aria-label="cabecera">
    <div style="display:flex;gap:12px;align-items:center">
      <button id="menuBtn" class="icon-btn" title="Men√∫">‚ò∞</button>
      <button id="brandBtn" class="brand" title="Ir al inicio">SinFiltro</button>
    </div>
    <div class="top-controls">
      <button id="toggleSat" class="icon-btn" title="Alternar Sat√©lite/Normal">üõ∞Ô∏è</button>
      <button id="themeBtn" class="icon-btn" title="Modo">üåó</button>
    </div>
  </div>

  <div id="minimap" aria-hidden="false"><canvas id="miniCanvas" width="300" height="300"></canvas></div>
  <div id="fps">FPS: --</div>

  <div class="joy" id="joy" aria-label="Joystick">
    <div class="stick" id="stick"></div>
  </div>
  <div class="btnFire" id="btnFire" title="Disparar">üî´</div>

  <div id="viewer" role="dialog" aria-hidden="true">
    <div class="card">
      <img id="viewerImg" src="" alt="preview">
      <div style="display:flex;justify-content:center;margin-top:12px">
        <button id="closeViewer" class="icon-btn" style="padding:8px 12px">Cerrar</button>
      </div>
    </div>
  </div>

  <!-- Three.js minimal -->
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

<script>
/* ================= Prototype Playas map - SinFiltro
   - Simula calles principales Playa Azul / Playa Caleta / Playa Hornos
   - Joystick touch, fire, minimap, sat toggle (placeholder), collisions, mobile-optimized
   - Keep UI/design consistent with approved premium look
*/

/* ---------- Helpers ---------- */
const $ = s => document.querySelector(s);
const mkImg = (n) => `https://picsum.photos/seed/sinfiltro-${n}/1024/1024`;

/* ---------- Three.js scene setup ---------- */
const holder = document.getElementById('canvasHolder');
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x05060a, 0.0018);

const renderer = new THREE.WebGLRenderer({antialias:true, alpha:false});
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.domElement.style.display = 'block';
renderer.domElement.style.touchAction = 'none'; // avoid passive touch capture
holder.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
camera.position.set(0, 6, 12);

const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(5,10,7); scene.add(dir);
scene.add(new THREE.AmbientLight(0xffffff, 0.24));

/* ---------- Ground + road materials ---------- */
const groundMat = new THREE.MeshStandardMaterial({color:0x0b1220, metalness:0.05, roughness:0.9});
const ground = new THREE.Mesh(new THREE.PlaneGeometry(1200,1200), groundMat);
ground.rotation.x = -Math.PI/2; ground.position.y = 0; scene.add(ground);

/* Road materials: normal (asphalt) and satellite placeholder */
const roadMat = new THREE.MeshStandardMaterial({color:0x2f3538, metalness:0.02, roughness:0.7});
const roadSatMat = new THREE.MeshStandardMaterial({map: new THREE.TextureLoader().load(mkImg(77)), metalness:0.02, roughness:0.8});

/* ---------- Simple map geometry: roads defined as rectangles
   Coordinates are local (x,z). We create a set of road segments approximating
   Playa Azul / Playa Caleta / Playa Hornos intersection network (prototype).
*/
const roads = [];
function addRoadSegment(cx, cz, length, width, angle=0){
  const geom = new THREE.PlaneGeometry(length+0.01, width+0.01);
  geom.rotateX(-Math.PI/2);
  const mesh = new THREE.Mesh(geom, roadMat);
  mesh.position.set(cx, 0.01, cz);
  mesh.rotation.y = angle;
  mesh.userData.road = true;
  scene.add(mesh);
  roads.push(mesh);
  return mesh;
}

// prototype layout (hand-crafted approximate)
// main avenue (east-west) - Playa Azul
addRoadSegment(0, 0, 240, 8, 0);              // Playa Azul central
addRoadSegment(0, -26, 200, 6, 0);            // branch
addRoadSegment(0, 26, 200, 6, 0);             // branch

// north-south collectors - Playa Caleta & Playa Hornos
addRoadSegment(-40, 0, 160, 6, Math.PI/2);    // Playa Caleta
addRoadSegment(40, 0, 160, 6, Math.PI/2);     // Playa Hornos

// smaller connectors
addRoadSegment(-90, -40, 90, 4, Math.PI*0.12);
addRoadSegment(90, 40, 90, 4, -Math.PI*0.08);
addRoadSegment(-30, 70, 70, 4, Math.PI*0.08);
addRoadSegment(30, -70, 70, 4, -Math.PI*0.08);

// Add curbs/sidewalk visual thin planes
roads.forEach(r=>{
  const edge = r.clone();
  edge.material = new THREE.MeshStandardMaterial({color:0x0d1b22, metalness:0.02, roughness:1});
  edge.scale.y = 1;
  edge.position.y = 0.02;
  scene.add(edge);
});

/* ---------- Buildings (low-poly, instanced-like) ---------- */
const buildings = [];
const bMat = new THREE.MeshStandardMaterial({color:0x25333a, metalness:0.05, roughness:0.95});
for(let i=0;i<120;i++){
  const w = 6 + Math.random()*12;
  const d = 6 + Math.random()*12;
  const h = 2 + Math.random()*8;
  const geom = new THREE.BoxGeometry(w, h, d);
  const m = new THREE.Mesh(geom, bMat);
  // place mostly along roads
  let placed=false, tries=0;
  while(!placed && tries<40){
    tries++;
    const x = (Math.random()-0.5)*200;
    const z = (Math.random()-0.5)*200;
    // avoid placing on road planes (simple distance check)
    let onRoad=false;
    for(const r of roads){
      const dist = distancePointToPlaneXZ({x,z}, r);
      if(dist < (Math.max(r.geometry.parameters.width || r.geometry.parameters.height || 6,4) * 0.5 + 6)) { onRoad = false; }
    }
    // better: place near roads edges
    if(Math.abs(z) < 120 && Math.abs(x) < 120){
      // simple heuristics: place only outside center corridor
      if(Math.abs(z) > 10 || Math.abs(x) > 10){
        placed=true; m.position.set(x, h/2, z); scene.add(m); buildings.push(m); break;
      }
    }
  }
}

/* helper to compute simple distance to road plane center (XZ) */
function distancePointToPlaneXZ(p, planeMesh){
  const px = planeMesh.position.x, pz = planeMesh.position.z;
  return Math.hypot(p.x - px, p.z - pz);
}

/* ---------- Player car (low poly) ---------- */
const car = new THREE.Group();
const body = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.7,4.2), new THREE.MeshStandardMaterial({color:0xff5555, metalness:0.35, roughness:0.6}));
body.position.y = 0.7; car.add(body);
const wheelGeo = new THREE.CylinderGeometry(0.35,0.35,0.5,8);
const wheelMat = new THREE.MeshStandardMaterial({color:0x111111});
for(let i=0;i<4;i++){
  const w = new THREE.Mesh(wheelGeo, wheelMat);
  w.rotation.z = Math.PI/2;
  w.position.y = 0.25;
  w.position.x = (i%2===0)?-1:1;
  w.position.z = (i<2)?1.2:-1.2;
  car.add(w);
}
car.position.set(-6,0,6); scene.add(car);

/* ---------- Simple collision boxes (for buildings) ---------- */
const colliders = [];
buildings.forEach(b=>{
  const box = new THREE.Box3().setFromObject(b);
  colliders.push(box);
});

/* ---------- Camera follow ---------- */
const camOffset = new THREE.Vector3(0,5,10);

/* ---------- Movement state & joystick handling ---------- */
const state = {forward:0, turn:0, speed:0, maxSpeed:0.85, rotSpeed:0.045};
let stick = {x:0,y:0};
let lastTime = performance.now();

const joy = document.getElementById('joy'), stickEl = document.getElementById('stick');
let touchId = null, baseX=0, baseY=0;
function resetStick(){ stick={x:0,y:0}; stickEl.style.transform = `translate(0px,0px)`; }
joy.addEventListener('touchstart', e=>{ e.preventDefault(); const t=e.changedTouches[0]; touchId=t.identifier; baseX=t.clientX; baseY=t.clientY; }, {passive:false});
joy.addEventListener('touchmove', e=>{ e.preventDefault(); for(const t of e.changedTouches){ if(t.identifier===touchId){ const dx=t.clientX-baseX; const dy=t.clientY-baseY; const max=36; const nx=Math.max(-1,Math.min(1,dx/max)); const ny=Math.max(-1,Math.min(1,dy/max)); stick.x=nx; stick.y=-ny; stickEl.style.transform=`translate(${nx*28}px,${-ny*28}px)`; } } }, {passive:false});
joy.addEventListener('touchend', e=>{ for(const t of e.changedTouches) if(t.identifier===touchId){ touchId=null; resetStick(); } }, {passive:false});
// pointer fallback
let mouseDown=false;
joy.addEventListener('pointerdown', e=>{ mouseDown=true; baseX=e.clientX; baseY=e.clientY; joy.setPointerCapture(e.pointerId); });
joy.addEventListener('pointermove', e=>{ if(!mouseDown) return; const dx=e.clientX-baseX, dy=e.clientY-baseY; const max=36; const nx=Math.max(-1,Math.min(1,dx/max)); const ny=Math.max(-1,Math.min(1,dy/max)); stick.x=nx; stick.y=-ny; stickEl.style.transform=`translate(${nx*28}px,${-ny*28}px)`; });
joy.addEventListener('pointerup', e=>{ mouseDown=false; resetStick(); });

/* Fire button (spawn small bullet) */
const bullets = [];
function spawnBullet(origin, dir){
  const g = new THREE.SphereGeometry(0.12,6,6);
  const m = new THREE.MeshStandardMaterial({emissive:0xffcc77, color:0x222222});
  const b = new THREE.Mesh(g,m);
  b.position.copy(origin);
  b.userData.dir = dir.clone();
  b.userData.speed = 2.4;
  scene.add(b); bullets.push(b);
}
$('#btnFire').addEventListener('touchstart', e=>{ e.preventDefault(); doFire(); }, {passive:false});
$('#btnFire').addEventListener('mousedown', doFire);
function doFire(){ const dir = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion).normalize(); const origin = car.position.clone().add(new THREE.Vector3(0,1.2,-2).applyQuaternion(car.quaternion)); spawnBullet(origin, dir); }

/* ---------- Collision handling: simple sphere vs box approximate ---------- */
function collideCar(pos){
  // approximate car as sphere radius
  const r = 1.1;
  for(const b of colliders){
    if(b.distanceToPoint(pos) < r){
      return true;
    }
  }
  return false;
}

/* ---------- Minimap (2D canvas) ---------- */
const miniCanvas = document.getElementById('miniCanvas');
const miniCtx = miniCanvas.getContext('2d');
function renderMini(){
  const w = miniCanvas.width, h = miniCanvas.height;
  miniCtx.clearRect(0,0,w,h);
  // draw background
  miniCtx.fillStyle = '#06101a';
  miniCtx.fillRect(0,0,w,h);
  // simple transform: world area [-120..120] -> canvas
  function toMini(x,z){ return {x: (x+120)/240*w, y: (z+120)/240*h}; }
  // roads
  miniCtx.fillStyle = '#666';
  roads.forEach(r=>{
    // draw center rectangle using position and rotation
    const len = r.geometry.parameters.width || r.geometry.parameters.height || 40;
    const width = (r.geometry.parameters.height || r.geometry.parameters.width || 6);
    // approximate as line between endpoints
    const cx = r.position.x, cz = r.position.z;
    const angle = r.rotation.y;
    const L = (r.geometry.parameters.width || r.geometry.parameters.height) || 40;
    // approximate endpoints in world coords
    const dx = Math.cos(angle) * L/2, dz = Math.sin(angle) * L/2;
    const p1 = toMini(cx - dx, cz - dz), p2 = toMini(cx + dx, cz + dz);
    miniCtx.lineWidth = Math.max(4, width/2);
    miniCtx.strokeStyle = '#333';
    miniCtx.beginPath(); miniCtx.moveTo(p1.x, p1.y); miniCtx.lineTo(p2.x, p2.y); miniCtx.stroke();
  });
  // player dot
  const p = toMini(car.position.x, car.position.z);
  miniCtx.fillStyle = '#ff5555'; miniCtx.beginPath(); miniCtx.arc(p.x, p.y, 6,0,Math.PI*2); miniCtx.fill();
}

/* ---------- Main loop + physics ---------- */
let fpsCounter = {frames:0, last:performance.now(), fps:0};
const fpsEl = $('#fps');

function animate(){
  const now = performance.now();
  const rawDt = now - lastTime;
  const dt = Math.min(50, rawDt) / 16.666;
  lastTime = now;

  // update state from stick
  state.forward = Math.max(-1, Math.min(1, stick.y));
  state.turn = Math.max(-1, Math.min(1, stick.x));

  if(state.forward > 0.05) state.speed += 0.02 * state.forward * dt;
  else if(state.forward < -0.05) state.speed -= 0.03 * (-state.forward) * dt;
  else state.speed *= 0.985;

  state.speed = Math.max(-state.maxSpeed, Math.min(state.maxSpeed, state.speed));
  // rotate
  car.rotation.y += -state.turn * state.rotSpeed * (0.9 + Math.abs(state.speed)) * dt;

  // forward vector and next pos
  const forwardVec = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion);
  const delta = forwardVec.multiplyScalar(state.speed * dt * 0.82);
  const nextPos = car.position.clone().add(delta);

  // collision check
  if(!collideCar(nextPos)){
    car.position.copy(nextPos);
  } else {
    // softly stop
    state.speed *= 0.45;
  }

  // camera follow smooth
  const desiredCam = car.position.clone().add(new THREE.Vector3(0,4,10).applyQuaternion(car.quaternion));
  camera.position.lerp(desiredCam, 0.14);
  camera.lookAt(car.position.clone().add(new THREE.Vector3(0,1.4,0)));

  // update bullets
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.position.add(b.userData.dir.clone().multiplyScalar(b.userData.speed * dt));
    if(b.position.length() > 200){ scene.remove(b); bullets.splice(i,1); continue; }
  }

  renderer.render(scene, camera);

  // minimap & fps update every frame
  renderMini();
  fpsCounter.frames++;
  if(now - fpsCounter.last >= 500){
    fpsCounter.fps = Math.round((fpsCounter.frames*1000)/(now - fpsCounter.last));
    fpsCounter.last = now; fpsCounter.frames = 0;
    fpsEl.textContent = `FPS: ${fpsCounter.fps}`;
  }

  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

/* ---------- Window / resize ---------- */
window.addEventListener('resize', ()=>{ renderer.setSize(innerWidth, innerHeight); camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); });

/* ---------- Sat toggle: swap road materials (placeholder) ---------- */
let sat = false;
$('#toggleSat').addEventListener('click', ()=>{
  sat = !sat;
  roads.forEach(r => r.material = sat ? roadSatMat : roadMat);
  // also change ground tint slightly
  ground.material.color.set(sat ? 0x0f120e : 0x0b1220);
});

/* ---------- Theme toggle (keeps body class but doesn't change layout) ---------- */
const THEME_KEY = 'sinfiltro.theme';
let theme = localStorage.getItem(THEME_KEY) || 'dark';
function applyTheme(t){ if(t==='light'){ document.body.classList.add('light'); $('#themeBtn').textContent='‚òÄÔ∏è'; } else { document.body.classList.remove('light'); $('#themeBtn').textContent='üåó'; } }
applyTheme(theme);
$('#themeBtn').addEventListener('click', ()=>{ theme = (theme==='dark') ? 'light' : 'dark'; localStorage.setItem(THEME_KEY, theme); applyTheme(theme); });

/* ---------- Viewer image demo (click brand) ---------- */
$('#brandBtn').addEventListener('click', ()=> {
  $('#viewerImg').src = mkImg(21);
  $('#viewer').style.display='flex'; $('#viewer').setAttribute('aria-hidden','false');
});
$('#closeViewer').addEventListener('click', ()=> { $('#viewer').style.display='none'; $('#viewer').setAttribute('aria-hidden','true'); });

/* ---------- Small streaming optimization hint (not heavy: keep scene light)
   - We kept building count low and used basic materials.
   - If you want to scale: use InstancedMesh for buildings, or load tiles and create mesh per tile.
   - For true satellite tiles, swap roadSatMat.map with tile compositor (see notes).
*/

/* ---------- End prototype ----------
   Next steps I recommend (pick one):
   1) Replace placeholder satellite with real tile provider (OpenStreetMap or ESRI WorldImagery). I can integrate tiles and a simple tile cache next.
   2) Convert buildings -> InstancedMesh for big map performance.
   3) Add precise street geometry using GeoJSON extracted from the Playas area and generate extruded polylines (most accurate).
   4) Add NPC traffic & basic capture/arena mechanics.
*/

/* If quieres que integre las tiles satelitales reales (WorldImagery/OSM/Mapbox),
   dime cu√°l proveedor prefieres. Mapbox & Google requieren token; ESRI WorldImagery and OSM tiles can be used freely (respectando TOS). Puedo integrar el compositor de tiles y un cache local en el navegador.
*/

</script>
</body>
</html>
