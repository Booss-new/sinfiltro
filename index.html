<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>SinFiltro - Playas JM (Arena Vehicular, Noche)</title>
<meta name="description" content="MVP: arena vehicular con calles definidas (simuladas), colisiones suaves, joystick, optimizado para mÃ³vil." />
<style>
  :root{
    --bg-1:#05060a; --text:#eaf7ff; --muted:#9fb0bf; --accent:#00d1ff;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg-1),#071226);color:var(--text);font-family:Inter,system-ui,Arial;overflow:hidden;-webkit-tap-highlight-color:transparent}
  #canvasHolder{width:100%;height:100%;display:block;touch-action:none}
  /* overlay UI (keeps approved premium look) */
  .topBar{position:fixed;left:12px;right:12px;top:12px;display:flex;justify-content:space-between;align-items:center;z-index:120}
  .logo{font-weight:700;padding:8px 12px;border-radius:10px;background:rgba(255,255,255,0.02);backdrop-filter:blur(6px)}
  .miniBtns{display:flex;gap:8px}
  .icon{padding:8px;border-radius:10px;background:rgba(255,255,255,0.02);cursor:pointer}
  /* joystick + fire */
  .joy { position:fixed; left:14px; bottom:16px; width:100px; height:100px; border-radius:60px; background:rgba(255,255,255,0.03); display:flex; align-items:center; justify-content:center; pointer-events:auto; z-index:160 }
  .stick { width:46px; height:46px; border-radius:50%; background:rgba(255,255,255,0.08); transform:translate(0,0) }
  .btnFire { position:fixed; right:18px; bottom:28px; width:68px; height:68px; border-radius:50%; background:linear-gradient(135deg,#00d1ff,#8a6eff); color:#001; display:flex; align-items:center; justify-content:center; pointer-events:auto; z-index:160; box-shadow:0 20px 50px rgba(0,0,0,0.6); font-weight:700 }
  /* viewer placeholder */
  #viewer{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.85);z-index:200}
  #viewer img{max-width:92%;height:auto;border-radius:12px}
  /* fps badge */
  #fpsBadge{position:fixed;left:12px;top:86px;padding:6px 8px;border-radius:8px;background:rgba(0,0,0,0.45);font-size:12px;color:var(--muted);z-index:160}
  /* small responsive tweaks */
  @media(max-width:420px){ .joy{width:92px;height:92px} .stick{width:40px;height:40px} .btnFire{width:60px;height:60px} .logo{padding:6px 10px;font-size:14px} }
</style>
</head>
<body>
  <div id="canvasHolder"></div>

  <!-- UI overlay (keeps design) -->
  <div class="topBar">
    <div class="logo" id="logoBtn">SinFiltro â€” Playas JM</div>
    <div class="miniBtns">
      <div class="icon" id="menuBtn">â˜°</div>
      <div class="icon" id="startBtn">â–¶</div>
    </div>
  </div>

  <div id="fpsBadge">FPS: --</div>

  <div class="joy" id="joy">
    <div class="stick" id="stick"></div>
  </div>

  <div class="btnFire" id="btnFire">ðŸ”«</div>

  <div id="viewer" role="dialog" aria-hidden="true">
    <div style="text-align:center">
      <img id="viewerImg" src="" alt="preview"><br><br>
      <button id="closeViewer" style="padding:8px 12px;border-radius:8px">Cerrar</button>
    </div>
  </div>

  <!-- THREE.JS -->
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

<script>
/* =========================
   SinFiltro - Playas JM (streets polygons)
   - Polygons roads (lightweight)
   - Soft collision boxes
   - Joystick + fire
   - FPS counter
   - Mobile-friendly: low-res, no heavy textures
   ========================= */

/* Helpers */
const $ = s => document.querySelector(s);
const rand = n => Math.floor(Math.random()*n);

/* Scene setup */
const holder = document.getElementById('canvasHolder');
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x05060a, 0.0018);

const renderer = new THREE.WebGLRenderer({antialias:true, alpha:false});
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // cap for mobile perf
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputEncoding = THREE.sRGBEncoding;
holder.appendChild(renderer.domElement);

// camera
const camera = new THREE.PerspectiveCamera(62, innerWidth/innerHeight, 0.1, 2000);
camera.position.set(0,6,12);

// lights
const dir = new THREE.DirectionalLight(0xffffff, 0.85);
dir.position.set(5,10,7); scene.add(dir);
scene.add(new THREE.AmbientLight(0xffffff, 0.22));

// ground base
const groundMat = new THREE.MeshStandardMaterial({color:0x071226, roughness:0.95});
const ground = new THREE.Mesh(new THREE.PlaneGeometry(1200,1200), groundMat);
ground.rotation.x = -Math.PI/2; ground.position.y = 0; scene.add(ground);

/* ============================================================
   CREATE SIMPLIFIED STREET NETWORK (polygons)
   - This is a lightweight, hand-made road layout inspired by
     organic blocks (Playas JM main arteries).
   - Roads are extruded shapes; sidewalks / curb boxes created
     as invisible collision meshes to keep car inside.
   ============================================================ */

// road material (dark asphalt) + stripe material
const roadMat = new THREE.MeshStandardMaterial({color:0x11161a, metalness:0.05, roughness:0.9});
const stripeMat = new THREE.MeshStandardMaterial({color:0xffee99, emissive:0xffee99, emissiveIntensity:0.05});

// helper: create road from path (array of [x,z]), width
function createRoad(path, width=6){
  // build centerline shape (extrude)
  const shape = new THREE.Shape();
  shape.moveTo(path[0][0], path[0][1]);
  for(let i=1;i<path.length;i++) shape.lineTo(path[i][0], path[i][1]);
  // extrude small thickness
  const geom = new THREE.ExtrudeGeometry(shape, {depth:0.1, bevelEnabled:false});
  // rotate to XZ plane
  geom.rotateX(-Math.PI/2);
  // center geometry: extrude geometry uses Y depth; reposition
  const mesh = new THREE.Mesh(geom, roadMat);
  mesh.position.y = 0.01; // slightly above ground
  // compute bounding helpers (approx)
  mesh.userData.road = true;
  scene.add(mesh);
  return mesh;
}

// helper: create center stripes (thin boxes along segments)
function stripeAlong(p1, p2, gap=6){
  const v1 = new THREE.Vector2(p1[0], p1[1]), v2 = new THREE.Vector2(p2[0], p2[1]);
  const seg = v2.clone().sub(v1);
  const len = seg.length();
  const dir = seg.clone().normalize();
  const count = Math.floor(len / gap);
  const group = new THREE.Group();
  for(let i=0;i<count;i++){
    const t = (i+0.5)/count;
    const x = v1.x + seg.x * t;
    const z = v1.y + seg.y * t;
    const b = new THREE.Mesh(new THREE.BoxGeometry(0.15,0.02, Math.min(2.2, gap*0.6)), stripeMat);
    b.rotation.x = -Math.PI/2;
    // orient along segment
    const angle = Math.atan2(seg.y, seg.x);
    b.rotation.y = -angle;
    b.position.set(x, 0.06, z);
    group.add(b);
  }
  scene.add(group);
  return group;
}

// collision boundary boxes (invisible) to gently keep cars within roads
const collisionBoxes = [];
function addCollisionBox(x,z,w,h){
  const geo = new THREE.BoxGeometry(w, 2, h);
  const mat = new THREE.MeshBasicMaterial({visible:false});
  const m = new THREE.Mesh(geo, mat);
  m.position.set(x, 1, z);
  scene.add(m);
  collisionBoxes.push(m);
}

/* Define simplified map layout (main streets + small alleys).
   Coordinates are arbitrary units; we will keep scale consistent with car.
   This layout is a simplified, playable approximation (not literal map data).
*/

// Main boulevard (curved-ish)
const boulevard = [
  [-40, -8],[-28,-6],[-12,-4],[-2,-2],[8,0],[22,4],[36,10]
];
createRoad(boulevard, 8);
for(let i=0;i<boulevard.length-1;i++) stripeAlong(boulevard[i], boulevard[i+1], 6);

// Cross street 1
const cross1 = [[-30,18],[-18,10],[-6,4],[6,2],[18,0]];
createRoad(cross1,6);
for(let i=0;i<cross1.length-1;i++) stripeAlong(cross1[i], cross1[i+1],5);

// Curvy coastal lane
const coastal = [[-50,30],[-36,26],[-22,22],[-6,18],[10,14],[26,12]];
createRoad(coastal,5);
for(let i=0;i<coastal.length-1;i++) stripeAlong(coastal[i], coastal[i+1],5);

// Secondary connectors (small alleys)
const a1 = [[-10,-18],[-6,-12],[2,-8],[12,-6]];
createRoad(a1,4);
for(let i=0;i<a1.length-1;i++) stripeAlong(a1[i], a1[i+1],4);

const a2 = [[20,-4],[28,0],[34,6]];
createRoad(a2,4);
for(let i=0;i<a2.length-1;i++) stripeAlong(a2[i], a2[i+1],4);

// add collision bands along road edges (approx)
[ boulevard, cross1, coastal, a1, a2 ].forEach(path=>{
  for(let i=0;i<path.length-1;i++){
    const pA=path[i], pB=path[i+1];
    const mx = (pA[0]+pB[0])/2, mz = (pA[1]+pB[1])/2;
    const segLen = Math.hypot(pB[0]-pA[0], pB[1]-pA[1]);
    // approximate box centered along segment to block off grass
    addCollisionBox(mx, mz, segLen+4, 10);
  }
});

/* ============================================================
   Street furniture: simple lampposts (low poly) + soft lights
   ============================================================ */
const lampMat = new THREE.MeshStandardMaterial({color:0x222f3a, metalness:.6, roughness:.4});
const lightMat = new THREE.MeshStandardMaterial({emissive:0xffdba8, emissiveIntensity:0.4, color:0xfff1e6});
function addLamp(x,z,h=3.2){
  const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06, h, 6), lampMat);
  pole.position.set(x, h/2, z);
  scene.add(pole);
  const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.14,6,6), lightMat);
  bulb.position.set(x, h-0.3, z);
  scene.add(bulb);
  // subtle point light
  const pl = new THREE.PointLight(0xffe6c4, 0.6, 8);
  pl.position.set(x, h-0.3, z);
  scene.add(pl);
}
// sprinkle lamps along main roads
[...boulevard, ...cross1, ...coastal].forEach((p,i)=>{
  if(i%2===0) addLamp(p[0]+(Math.random()-0.5)*1, p[1]+(Math.random()-0.5)*1);
});

/* ============================================================
   Player car (low poly) + simple wheel visuals
   ============================================================ */
const car = new THREE.Group();
const body = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.7,4.2), new THREE.MeshStandardMaterial({color:0xff5555, metalness:0.35, roughness:0.5}));
body.position.y = 0.7;
car.add(body);
const wheelGeo = new THREE.CylinderGeometry(0.35,0.35,0.5,8);
const wheelMat = new THREE.MeshStandardMaterial({color:0x0c0c0c});
for(let i=0;i<4;i++){
  const w = new THREE.Mesh(wheelGeo, wheelMat);
  w.rotation.z = Math.PI/2;
  w.position.y = 0.25;
  w.position.x = (i%2===0)?-1:1;
  w.position.z = (i<2)?1.2:-1.2;
  car.add(w);
}
car.position.set(boulevard[2][0], 0.01, boulevard[2][1]); // spawn on boulevard
scene.add(car);

/* simple bot (visual) */
const bot = car.clone();
bot.children[0].material = new THREE.MeshStandardMaterial({color:0x55aaff, metalness:0.2, roughness:0.5});
bot.position.set(boulevard[4][0]+6,0.01,boulevard[4][1]-4);
scene.add(bot);

/* camera follow */
const camOffset = new THREE.Vector3(0,4.5,9.5);

/* movement state */
const state = {forward:0, turn:0, speed:0, maxSpeed:0.85, rotSpeed:0.045};
let lastTime = performance.now();

/* bullets array */
const bullets = [];

/* spawn bullet (same as before) */
function spawnBullet(origin, dir){
  const g = new THREE.SphereGeometry(0.11, 6,6);
  const m = new THREE.MeshStandardMaterial({emissive:0xffb07a, color:0x222222});
  const b = new THREE.Mesh(g,m);
  b.position.copy(origin);
  b.userData.dir = dir.clone();
  b.userData.speed = 2.5;
  scene.add(b); bullets.push(b);
}

/* ============================================================
   JOYSTICK handling (left) + touch friendly drag for camera
   ============================================================ */
const joy = document.getElementById('joy'), stickEl = document.getElementById('stick');
let touchId = null, baseX=0, baseY=0;
let stick = {x:0,y:0};
function resetStick(){ stick={x:0,y:0}; stickEl.style.transform = `translate(0px,0px)`; }

joy.addEventListener('touchstart', e=>{
  e.preventDefault();
  const t = e.changedTouches[0]; touchId = t.identifier; baseX = t.clientX; baseY = t.clientY;
}, {passive:false});
joy.addEventListener('touchmove', e=>{
  e.preventDefault();
  for(const t of e.changedTouches){
    if(t.identifier === touchId){
      const dx = t.clientX - baseX;
      const dy = t.clientY - baseY;
      const max = 36;
      const nx = Math.max(-1, Math.min(1, dx/max));
      const ny = Math.max(-1, Math.min(1, dy/max));
      stick.x = nx; stick.y = -ny;
      stickEl.style.transform = `translate(${nx*28}px,${-ny*28}px)`;
    }
  }
}, {passive:false});
joy.addEventListener('touchend', e=>{ for(const t of e.changedTouches) if(t.identifier===touchId) { touchId=null; resetStick(); } }, {passive:false});
// pointer fallback
let md=false;
joy.addEventListener('pointerdown', e=>{ md=true; baseX=e.clientX; baseY=e.clientY; joy.setPointerCapture(e.pointerId); });
joy.addEventListener('pointermove', e=>{ if(!md) return; const dx=e.clientX-baseX, dy=e.clientY-baseY; const max=36; const nx=Math.max(-1,Math.min(1,dx/max)); const ny=Math.max(-1,Math.min(1,dy/max)); stick.x=nx; stick.y=-ny; stickEl.style.transform=`translate(${nx*28}px,${-ny*28}px)`; });
joy.addEventListener('pointerup', e=>{ md=false; resetStick(); });

/* fire button */
const fireBtn = document.getElementById('btnFire');
fireBtn.addEventListener('touchstart', e=> { e.preventDefault(); doFire(); }, {passive:false});
fireBtn.addEventListener('mousedown', ()=> doFire());
function doFire(){
  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion).normalize();
  const origin = car.position.clone().add(new THREE.Vector3(0,1, -2).applyQuaternion(car.quaternion));
  spawnBullet(origin, dir);
}

/* touch area for camera drag (right side) -> simple look control */
let cameraDrag = {active:false, startX:0, yaw:0};
renderer.domElement.addEventListener('pointerdown', (e)=>{
  // only open camera drag on right half to avoid interfering joystick
  if(e.clientX > window.innerWidth * 0.45){
    cameraDrag.active = true; cameraDrag.startX = e.clientX;
  }
});
renderer.domElement.addEventListener('pointermove', (e)=>{
  if(!cameraDrag.active) return;
  const dx = (e.clientX - cameraDrag.startX);
  camera.rotation.y -= dx * 0.0012;
  cameraDrag.startX = e.clientX;
});
renderer.domElement.addEventListener('pointerup', ()=> cameraDrag.active=false);
renderer.domElement.addEventListener('pointercancel', ()=> cameraDrag.active=false);

/* ============================================================
   SIMPLE COLLISION: gently push back car from collision boxes
   - For performance we approximate: check car position vs each box's XZ rectangle
   - If inside prohibited area, nudge car back along vector to nearest edge
   ============================================================ */
function resolveCollisions(carPos){
  // iterate boxes
  for(const b of collisionBoxes){
    // compute local dx,dz
    const dx = carPos.x - b.position.x;
    const dz = carPos.z - b.position.z;
    const hx = (b.geometry.parameters.width||b.geometry.parameters.depth)/2 + 0.9; // margin
    const hz = (b.geometry.parameters.depth||b.geometry.parameters.width)/2 + 0.9;
    // approximate because BoxGeometry orientation is axis-aligned
    if(Math.abs(dx) < hx && Math.abs(dz) < hz){
      // compute push vector to nearest edge
      const pushX = (Math.abs(dx) / hx) || 0.01;
      const pushZ = (Math.abs(dz) / hz) || 0.01;
      if(pushX > pushZ){
        // push on X
        carPos.x = b.position.x + (dx>0 ? hx : -hx);
      } else {
        // push on Z
        carPos.z = b.position.z + (dz>0 ? hz : -hz);
      }
    }
  }
}

/* ============================================================
   PERFORMANCE: small LOD & caps
   ============================================================ */
renderer.domElement.style.touchAction = 'none';

/* ============================================================
   animate loop
   ============================================================ */
let lastFrame = performance.now();
let fpsCounter = {frames:0, last: performance.now(), fps:0};
const fpsBadge = document.getElementById('fpsBadge');

function animate(){
  const now = performance.now();
  const rawDt = now - lastTime;
  lastTime = now;
  const dt = Math.min(50, rawDt) / 16.666; // normalized delta

  // movement from stick
  state.forward = Math.max(-1, Math.min(1, stick.y));
  state.turn = Math.max(-1, Math.min(1, stick.x));

  // modify speed
  if(state.forward > 0.06) state.speed += 0.018 * state.forward * dt;
  else if(state.forward < -0.06) state.speed -= 0.03 * (-state.forward) * dt;
  else state.speed *= 0.975;

  state.speed = Math.max(-state.maxSpeed, Math.min(state.maxSpeed, state.speed));

  // rotate car
  car.rotation.y += -state.turn * state.rotSpeed * (0.9 + Math.abs(state.speed)) * dt;

  // move forward
  const forwardVec = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion);
  car.position.add(forwardVec.multiplyScalar(state.speed * dt * 0.85));

  // soft collision resolution
  resolveCollisions(car.position);

  // camera follow
  const desiredCam = car.position.clone().add(new THREE.Vector3(0,4.5,9.5).applyQuaternion(car.quaternion));
  camera.position.lerp(desiredCam, 0.12);
  const lookAt = car.position.clone().add(new THREE.Vector3(0,1.5,0));
  camera.lookAt(lookAt);

  // bot simple orbit slow
  bot.position.x = Math.cos(now*0.0006) * 8;
  bot.position.z = Math.sin(now*0.0006) * 8;
  bot.lookAt(car.position);

  // bullets update
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.position.addScaledVector(b.userData.dir, b.userData.speed * dt);
    // simple range cull
    if(b.position.length() > 900){ scene.remove(b); bullets.splice(i,1); continue; }
    // hit bot?
    if(b.position.distanceTo(bot.position) < 1.2){
      scene.remove(b); bullets.splice(i,1);
      // hit effect
      const hit = new THREE.Mesh(new THREE.SphereGeometry(0.25,6,6), new THREE.MeshStandardMaterial({emissive:0xff5522, color:0x111111}));
      hit.position.copy(bot.position);
      scene.add(hit);
      setTimeout(()=> scene.remove(hit), 600);
    }
  }

  renderer.render(scene, camera);

  // fps
  fpsCounter.frames++;
  if(now - fpsCounter.last >= 1000){
    fpsCounter.fps = Math.round((fpsCounter.frames*1000)/(now-fpsCounter.last));
    fpsCounter.last = now; fpsCounter.frames = 0;
    fpsBadge.textContent = `FPS: ${fpsCounter.fps}`;
  }

  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

/* ============================================================
   UI / small demos
   ============================================================ */
document.getElementById('btnMenu').addEventListener('click', ()=> {
  // modern half-screen panel demo (simple)
  const panel = document.createElement('div');
  panel.style.position='fixed'; panel.style.left='6%'; panel.style.right='6%';
  panel.style.top='16%'; panel.style.bottom='16%'; panel.style.background='linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.008))';
  panel.style.backdropFilter='blur(10px)'; panel.style.borderRadius='12px'; panel.style.zIndex=9999; panel.style.padding='14px';
  panel.innerHTML = `<div style="display:flex;align-items:center;gap:8px"><strong>MenÃº</strong><button id="closeP" style="margin-left:auto">âœ•</button></div>
    <div style="margin-top:8px;color:${getComputedStyle(document.documentElement).getPropertyValue('--muted')||'#9fb0bf'}">
      <button style="display:block;width:100%;padding:10px;margin-top:8px;border-radius:8px">Perfil (demo)</button>
      <button style="display:block;width:100%;padding:10px;margin-top:8px;border-radius:8px">Ajustes (demo)</button>
      <button style="display:block;width:100%;padding:10px;margin-top:8px;border-radius:8px">Salir (demo)</button>
    </div>`;
  document.body.appendChild(panel);
  document.getElementById('closeP').addEventListener('click', ()=> panel.remove());
});

document.getElementById('startBtn').addEventListener('click', ()=> {
  alert('Demo: iniciar partida (1v1 / 4v4) â€” integraciÃ³n futura de matchmaking.');
});

// logo viewer preview
document.getElementById('logoBtn').addEventListener('click', ()=>{
  $('#viewerImg').src = 'https://picsum.photos/900/420?random=' + Math.floor(Math.random()*9999);
  $('#viewer').style.display='flex'; $('#viewer').setAttribute('aria-hidden','false');
});
document.getElementById('closeViewer').addEventListener('click', ()=> { $('#viewer').style.display='none'; $('#viewer').setAttribute('aria-hidden','true'); });

/* Resize handling */
window.addEventListener('resize', ()=> {
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
});

/* Final notes (embedded):
 - Map: simplified "Playas JM" inspired street network (polygons) for immediate gameplay.
 - Collisions: cheap axis-aligned box nudges to keep car inside roads (soft).
 - Performance: capped pixel ratio, no heavy textures, low-poly geometry.
 - To add: GeoJSON import of exact streets / real coordinates (next step).
*/
</script>
</body>
</html>
