<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>CENIT DE ACERO: Simulador de Combate Extremo</title>
<style>
  /* Base Style - ESTILO AAA ESTILIZADO */
  :root{
    --bg:#020306;
    --red:#e74c3c;
    --blue:#3498db;
    --green:#2ecc71;
    --shadow:rgba(0,0,0,0.8);
    --text-color:#ecf0f1;
    --panel-bg:rgba(20,20,30,0.7);
    --panel-border:rgba(255,255,255,0.15);
  }
  html,body{height:100%;margin:0;background:linear-gradient(#020306,#050a1a);font-family:'Montserrat', sans-serif;color:var(--text-color);overflow:hidden}
  #holder{width:100%;height:100%;position:relative;touch-action:none}
  
  @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700;800&display=swap');

  /* HUD - Estilo de consola de juego */
  .hud{position:fixed;top:10px;left:10px;right:10px;display:flex;justify-content:space-between;z-index:120;font-size:13px;pointer-events:none;text-shadow:0 0 5px var(--shadow)}
  .panel{background:var(--panel-bg);padding:8px 14px;border-radius:8px;font-weight:600;border:1px solid var(--panel-border);pointer-events:auto;box-shadow:0 4px 15px var(--shadow);backdrop-filter:blur(3px)}
  .panel h2{font-size:16px;margin:0 0 5px 0;color:#fff}

  /* NUEVA INTERFAZ DE DIAGNÓSTICO DE COMPONENTES */
  #diagnostico{
    flex-direction: column;
    width: 200px; /* Ancho fijo para el panel de diagnóstico */
    pointer-events: none;
    line-height: 1.4;
  }
  #diagnostico h2{ color: #00ffff; }
  .componente-estado{ font-size: 11px; margin-top: 3px; }
  .estado-ok{ color: var(--green); }
  .estado-danado{ color: #ff9900; }
  .estado-critico{ color: var(--red); font-weight: 700; }

  /* Health and Ammo Bars */
  .bar-container{width:130px;height:14px;background:#1a1a2e;border-radius:3px;overflow:hidden;margin-top:5px;border:1px solid rgba(255,255,255,0.2)}
  .health-bar{height:100%;width:100%;background:linear-gradient(90deg, #e74c3c, #c0392b);transition:width 0.2s}
  .ammo-bar{height:100%;width:100%;background:linear-gradient(90deg, #2ecc71, #27ae60);transition:width 0.2s}
  
  /* Velocímetro */
  .speedometer{
    position:fixed;right:10px; bottom:120px; width:120px;height:120px; background:var(--panel-bg); border-radius:50%; border:1px solid var(--panel-border); box-shadow:0 4px 15px var(--shadow); display:flex;flex-direction:column;align-items:center;justify-content:center; pointer-events:none; z-index:115; backdrop-filter:blur(3px);
  }
  .speed-value{font-size:36px;font-weight:800;color:#fff;text-shadow:0 0 8px rgba(255,255,255,0.4)}
  .speed-unit{font-size:12px;color:var(--text-color)}
  
  /* Controles */
  .joy { position:fixed; left:12px; bottom:12px; width:100px; height:100px; border-radius:50px; background:var(--shadow); display:flex; align-items:center; justify-content:center; pointer-events:auto; z-index:100; border:2px solid rgba(255,255,255,0.1) }
  .stick { width:40px; height:40px; border-radius:50%; background:rgba(255,255,255,0.15); transform:translate(0,0) }
  .fire { position:fixed; right:120px; bottom:20px; width:70px; height:70px; border-radius:50%; background:linear-gradient(135deg,var(--red),#ff0000); display:flex;align-items:center;justify-content:center;z-index:110;pointer-events:auto;box-shadow:0 0 15px var(--red); font-size:30px; border:3px solid #fff; transition:transform 0.1s }
  .fire.cooldown { background:linear-gradient(135deg, #333, #555); box-shadow:none; transform: scale(0.9); pointer-events: none; }
  .turbo { position:fixed; right:12px; bottom:12px; width:90px; height:90px; border-radius:50%; background:linear-gradient(135deg,var(--blue),#00f); display:flex;align-items:center;justify-content:center;z-index:110;pointer-events:auto;box-shadow:0 0 10px var(--blue); font-size:20px; border:3px solid #fff; }
  
  /* FPS/Loader */
  .fps{position:fixed;left:12px;bottom:120px;background:var(--panel-bg);padding:4px 8px;border-radius:4px;font-weight:600;z-index:110;font-size:12px;backdrop-filter:blur(3px)}
  #loading{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:130;background:var(--shadow);padding:14px 18px;border-radius:12px;font-weight:600}

  @media (max-width:420px){ 
    .joy{width:90px;height:90px;left:8px;bottom:8px;} 
    .fire{right:95px;bottom:12px;width:60px;height:60px;font-size:24px}
    .turbo{right:8px;bottom:8px;width:70px;height:70px;font-size:16px}
    .fps{left:8px;bottom:100px;} 
    .speedometer{width:100px;height:100px;right:8px;bottom:100px;}
    .speed-value{font-size:30px}
    /* Mover el diagnóstico en móvil */
    #diagnostico{ top: 70px; right: 10px; left: auto; width: 150px; }
  }
</style>
</head>
<body>
  <div id="holder"></div>

  <div class="hud">
    <div class="panel">
      <h2>VEHÍCULO: <span id="carType">Sport</span></h2>
      Integridad:
      <div class="bar-container"><div id="healthBar" class="health-bar"></div></div>
    </div>

    <div class="panel" id="diagnostico">
        <h2>DIAGNÓSTICO ESTRUCTURAL</h2>
        <div id="componentes">
            </div>
    </div>
    
    <div class="panel">
      <h2>MUNICIÓN</h2>
      Munición: <span id="ammoCount">10</span>
      <div class="bar-container"><div id="ammoBar" class="ammo-bar"></div></div>
    </div>
  </div>
  
  <div class="speedometer">
    <div class="speed-value" id="speedDisplay">0</div>
    <div class="speed-unit">KM/H</div>
  </div>

  <div id="loading">Cargando CENIT DE ACERO...</div>

  <div class="joy" id="joy"><div class="stick" id="stick"></div></div>
  <div class="fire" id="fire">💥</div>
  <div class="turbo" id="turbo">🚀</div>
  <div class="fps" id="fps">FPS: --</div>

<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/shaders/CopyShader.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

<script>
// Función para verificar si el EffectComposer se cargó
function hasBloomSupport() {
    return typeof EffectComposer !== 'undefined';
}

// =========================================================================
// == IMPLEMENTACIÓN DEL LUJO DE DETALLE: SIMULACIÓN DE COMPONENTES        ==
// =========================================================================

class CarController extends THREE.Group {
    constructor(type, isAI) {
        super();
        const stats = VEHICLE_STATS[type];

        // --- 1. DATOS DE ESTADO Y COMPONENTES (LUJO DE DETALLE) ---
        this.userData.isAI = isAI;
        this.userData.type = type;
        this.userData.maxHealth = stats.health;
        this.userData.health = stats.health;
        this.userData.maxAmmo = stats.maxAmmo;
        this.userData.ammo = stats.maxAmmo;
        this.userData.maxSpeed = stats.maxSpeed;
        this.userData.rotSpeed = stats.rotSpeed;
        this.userData.speed = 0;

        // **INTEGRACIÓN DE COMPONENTES DE CENIT DE ACERO**
        this.componentes = {
            motor: { vida: 100, max: 100, estado: 'OK', efecto: 'Velocidad Máx.' },
            ruedas_traseras: { vida: 100, max: 100, estado: 'OK', efecto: 'Tracción/Giro' },
            sistema_punteria: { vida: 100, max: 100, estado: 'OK', efecto: 'Precisión/Giro' },
            chasis_frontal: { vida: 100, max: 100, estado: 'OK', efecto: 'Daño Directo' }
        };

        // --- 2. MODELO VISUAL 3D (No modificado, solo referenciado) ---
        this.buildMesh(stats);

        // Barra de salud visible (IA)
        if(isAI){
            const hbMat = new THREE.MeshBasicMaterial({color:0x00ff00});
            const hbGeo = new THREE.BoxGeometry(stats.width * 0.8, 0.2, 0.1);
            const healthBar = new THREE.Mesh(hbGeo, hbMat);
            healthBar.position.y = 2.5;
            healthBar.rotation.y = Math.PI/2;
            this.userData.healthBar = healthBar;
            this.add(healthBar);
        }
    }

    // Método para crear el mesh 3D
    buildMesh(stats) {
        // Cuerpo del vehículo (Low-Poly con materiales metálicos)
        const bodyGeo = new THREE.BoxGeometry(stats.width, 0.7, stats.length);
        const bodyMat = new THREE.MeshStandardMaterial({color:stats.color, metalness:0.9, roughness:0.15}); 
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = 0.7; 
        body.castShadow = true;
        body.receiveShadow = true;
        this.add(body);
        
        // ... (Aquí iría la lógica de alerón, luces, etc. de tu código original)
        // Luces Traseras (Emissivas)
        const tailLightMat = BLOOM_ENABLED ? new THREE.MeshBasicMaterial({color:0xff0000, emissive:0xff0000, emissiveIntensity:1.5}) : new THREE.MeshBasicMaterial({color:0xff0000});
        const tailLightGeo = new THREE.BoxGeometry(stats.width * 0.7, 0.3, 0.1);
        const tailLights = new THREE.Mesh(tailLightGeo, tailLightMat);
        tailLights.position.set(0, 0.8, stats.length/2 - 0.05); 
        this.add(tailLights);

        // Neón trasero (Jugador)
        if (!this.userData.isAI && stats.color !== 0x888888) { // Excluir tráfico
            const neon = new THREE.PointLight(0xff00ff, BLOOM_ENABLED ? 6 : 4, 5); 
            neon.position.set(0, 0.5, stats.length/2 + 0.5);
            this.userData.neonLight = neon;
            this.add(neon);
        }

        // Almacenar referencia al mesh principal para feedback visual
        this.userData.mainMesh = body;
    }

    // --- 3. FUNCIÓN CRÍTICA DE DAÑO (LUJO DE DETALLE) ---
    applyDamage(amount, componentKey = 'chasis_frontal') {
        if (this.userData.health <= 0) return;
        
        // A. Daño al componente específico
        const comp = this.componentes[componentKey];
        if (comp && comp.vida > 0) {
            comp.vida -= amount;
            comp.vida = Math.max(0, comp.vida);

            // Determinar nuevo estado
            if (comp.vida <= 0) comp.estado = 'DESTRUIDO';
            else if (comp.vida <= 30) comp.estado = 'CRÍTICO';
            else if (comp.vida <= 60) comp.estado = 'DAÑADO';
            else comp.estado = 'OK';
        }

        // B. Daño al Integridad Estructural general
        this.userData.health -= amount * 0.5; // El daño al chasis afecta la integridad
        this.userData.health = Math.max(0, this.userData.health);

        // Feedback visual: color rojo por impacto
        this.userData.mainMesh.material.color.setHex(0xaaaaaa); 
        setTimeout(() => {
            if(this.userData.health > 0){
                this.userData.mainMesh.material.color.setHex(VEHICLE_STATS[this.userData.type].color);
            }
        }, 50);
        
        return this.userData.health <= 0;
    }

    // --- 4. CÁLCULO DE EFECTOS DEL DAÑO (FÍSICA AFECTADA) ---
    getPhysicsModifier() {
        let maxSpeedMod = 1.0;
        let rotSpeedMod = 1.0;

        // Efecto del motor (reduce la velocidad máxima)
        if (this.componentes.motor.estado !== 'OK') {
            maxSpeedMod *= 0.5 + (this.componentes.motor.vida / 100) * 0.5; // De 50% a 100% de la velocidad
        }
        
        // Efecto de ruedas/puntería (reduce la velocidad de giro)
        if (this.componentes.ruedas_traseras.estado !== 'OK') {
             rotSpeedMod *= 0.3 + (this.componentes.ruedas_traseras.vida / 100) * 0.7; // El giro se ve muy afectado
        }

        // Efecto de chasis (hace que el coche frene más rápido por arrastre)
        if (this.componentes.chasis_frontal.estado === 'CRÍTICO' || this.componentes.chasis_frontal.estado === 'DESTRUIDO') {
            // Simulación de 'Desgarro Estructural': fricción adicional
            this.userData.speed *= 0.95; 
        }

        return { maxSpeedMod, rotSpeedMod };
    }
}

// =========================================================================
// == CÓDIGO THREE.JS ORIGINAL (Modificado)                               ==
// =========================================================================

(async function(){
  // ---------- CONFIGURACIÓN GENERAL ----------
  const holder = document.getElementById('holder');
  const CITY_SIZE = 200; 
  const ROAD_WIDTH = 12; 
  const SIDEWALK_WIDTH = 3; 
  const BUILDING_SPACING = 2; 
  const BULLET_COOLDOWN_MS = 400; 
  const AI_CARS = [];
  const TRAFFIC_CARS = [];
  const POWER_UPS = [];
  const UI_COMP_EL = document.getElementById('componentes'); // Elemento de diagnóstico

  // Definiciones de vehículos (CON DATOS DE COMPONENTES)
  const VEHICLE_STATS = {
      'Muscle Car': { color: 0xff5555, width: 2.8, length: 5.0, health: 100, maxSpeed: 1.2, rotSpeed: 0.040, maxAmmo: 15 },
      'Sport': { color: 0x5555ff, width: 2.2, length: 4.0, health: 80, maxSpeed: 1.4, rotSpeed: 0.055, maxAmmo: 10 },
      'Pickup': { color: 0x55ff55, width: 3.2, length: 5.5, health: 150, maxSpeed: 0.9, rotSpeed: 0.030, maxAmmo: 20 },
      'Traffic': { color: 0x888888, width: 2.5, length: 4.5, health: 50, maxSpeed: 0.7, rotSpeed: 0.020, maxAmmo: 0 }
  };
  let CURRENT_CAR_TYPE = 'Sport'; 
  const BLOOM_ENABLED = hasBloomSupport(); 
  if(!BLOOM_ENABLED) console.warn("BLOOM DISABLED: UnrealBloomPass no cargó. Renderizando sin efecto Neón.");


  // ---------- THREEJS SETUP CON FALLBACK DE BLOOM ----------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a0a1a);
  scene.fog = new THREE.Fog(scene.background, 50, 400);
  
  const renderer = new THREE.WebGLRenderer({antialias:true, alpha:false});
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
  holder.appendChild(renderer.domElement);
  
  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 5000);
  camera.position.set(0, 12, 24);

  let composer = null;
  if(BLOOM_ENABLED){
      composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.4, 0.85); 
      bloomPass.renderToScreen = true;
      composer.addPass(bloomPass);
  }

  // Luces (General)
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.1); 
  dirLight.position.set(0, 50, 100);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.width = 1024;
  dirLight.shadow.mapSize.height = 1024;
  dirLight.shadow.camera.left = -CITY_SIZE/2;
  dirLight.shadow.camera.right = CITY_SIZE/2;
  dirLight.shadow.camera.top = CITY_SIZE/2;
  dirLight.shadow.camera.bottom = -CITY_SIZE/2;
  scene.add(dirLight);
  scene.add(new THREE.AmbientLight(0xffffff, 0.08)); 

  // --- GENERACIÓN DE CIUDAD (Sin Cambios) ---
  const roadMat = new THREE.MeshStandardMaterial({color:0x181825, roughness:0.7, metalness:0.3});
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(CITY_SIZE, CITY_SIZE, 1, 1), roadMat);
  ground.rotation.x = -Math.PI/2;
  ground.position.y = 0;
  ground.receiveShadow = true;
  scene.add(ground);

  // Líneas
  const lineMat = new THREE.MeshBasicMaterial({color:0xcccccc, emissive:0xcccccc, emissiveIntensity:1});
  const dashedLineGeo = new THREE.PlaneGeometry(0.2, 2);
  for(let i = -CITY_SIZE/2; i < CITY_SIZE/2; i += 6) {
      const line = new THREE.Mesh(dashedLineGeo, lineMat);
      line.position.set(0, 0.01, i);
      line.rotation.x = -Math.PI/2;
      scene.add(line);
  }

  // Aceras
  const sidewalkMat = new THREE.MeshStandardMaterial({color:0x303030, roughness:0.6, metalness:0.1, emissive:0x202020, emissiveIntensity:0.2});
  const sidewalkLeft = new THREE.Mesh(new THREE.BoxGeometry(SIDEWALK_WIDTH, 0.5, CITY_SIZE), sidewalkMat);
  sidewalkLeft.position.set(-ROAD_WIDTH/2 - SIDEWALK_WIDTH/2, 0.25, 0);
  scene.add(sidewalkLeft);
  const sidewalkRight = new THREE.Mesh(new THREE.BoxGeometry(SIDEWALK_WIDTH, 0.5, CITY_SIZE), sidewalkMat);
  sidewalkRight.position.set(ROAD_WIDTH/2 + SIDEWALK_WIDTH/2, 0.25, 0);
  scene.add(sidewalkRight);

  // Edificios (Simplificado - La lógica completa de la función createBuilding se mantiene igual)
  const buildingColors = [0x1a1a2e, 0x1e1e3a, 0x15152a]; 
  const windowColors = [0x00ffff, 0xff00ff, 0xffff00]; 
  function createBuilding(x, z, sizeX, sizeZ, height){
      const buildingGroup = new THREE.Group();
      const bodyMat = new THREE.MeshStandardMaterial({color: buildingColors[Math.floor(Math.random()*buildingColors.length)], roughness:0.7, metalness:0.2});
      const bodyGeo = new THREE.BoxGeometry(sizeX, height, sizeZ);
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = height / 2 + 0.5;
      body.castShadow = true;
      buildingGroup.add(body);

      // Ventanas emisivas
      const windowMat = BLOOM_ENABLED
        ? new THREE.MeshBasicMaterial({color:windowColors[Math.floor(Math.random()*windowColors.length)], emissive:windowColors[Math.floor(Math.random()*windowColors.length)], emissiveIntensity:1.5})
        : new THREE.MeshBasicMaterial({color:windowColors[Math.floor(Math.random()*windowColors.length)]}); 
      
      const numWindowsX = Math.floor(sizeX / 4);
      const numWindowsY = Math.floor(height / 4);
      
      // ... Lógica de ventanas (omito por brevedad, es la misma)
      
      buildingGroup.position.set(x, 0, z);
      scene.add(buildingGroup);
  }

  // Generar edificios
  const numBuildingsZ = Math.floor(CITY_SIZE / 15);
  for(let i = -numBuildingsZ; i <= numBuildingsZ; i++){
      const zPos = i * (15 + BUILDING_SPACING);
      const xPosLeft = -ROAD_WIDTH/2 - SIDEWALK_WIDTH - (Math.random() * 20 + 10) / 2 - BUILDING_SPACING;
      createBuilding(xPosLeft, zPos, Math.random() * 10 + 10, Math.random() * 8 + 8, Math.random() * 30 + 15);
      const xPosRight = ROAD_WIDTH/2 + SIDEWALK_WIDTH + (Math.random() * 20 + 10) / 2 + BUILDING_SPACING;
      createBuilding(xPosRight, zPos, Math.random() * 10 + 10, Math.random() * 8 + 8, Math.random() * 30 + 15);
  }
  
  // Farolas (omito la función, se mantiene igual)

  // ---------- VEHÍCULOS Y LÓGICA DE JUEGO ----------
  
  // Player car (USANDO LA NUEVA CLASE)
  const car = new CarController(CURRENT_CAR_TYPE, false);
  car.position.set(0, 0, 0);
  scene.add(car);

  // IA Cars (USANDO LA NUEVA CLASE)
  const ai1 = new CarController('Muscle Car', true);
  ai1.position.set(20, 0, 50);
  ai1.rotation.y = Math.PI;
  scene.add(ai1); AI_CARS.push(ai1);

  const ai2 = new CarController('Pickup', true);
  ai2.position.set(-20, 0, -50);
  ai2.rotation.y = 0;
  scene.add(ai2); AI_CARS.push(ai2);

  // Tráfico (vehículos pasivos - USANDO LA NUEVA CLASE)
  for(let i = 0; i < 5; i++){
      const traffic = new CarController('Traffic', true);
      traffic.position.set((Math.random() < 0.5 ? 1 : -1) * (ROAD_WIDTH/4 + Math.random() * ROAD_WIDTH/4), 0, Math.random() * CITY_SIZE - CITY_SIZE/2);
      traffic.rotation.y = Math.random() < 0.5 ? 0 : Math.PI;
      traffic.userData.maxSpeed *= (0.8 + Math.random() * 0.4);
      TRAFFIC_CARS.push(traffic);
      scene.add(traffic);
  }

  // Estado del jugador
  const state = {
      forward:0, turn:0, turbo:false, 
      speed: car.userData.speed, 
      health: car.userData.health, 
      ammo: car.userData.ammo || VEHICLE_STATS[CURRENT_CAR_TYPE].maxAmmo
  };
  
  // ---------- SISTEMA DE ARMAS Y POWER-UPS (Mínimos Cambios) ----------
  const bulletPool = [];
  const maxBullets = 20;
  
  function getBullet(){
      // ... Lógica de pool
  }
  
  function releaseBullet(b){
      // ... Lógica de liberación
  }
  
  // Generación de Power-Ups (sin cambios)
  createPowerUp('Ammo', new THREE.Vector3(10, 0, 10));
  createPowerUp('Health', new THREE.Vector3(-10, 0, -10));
  
  // --- LÓGICA DE DAÑO: AHORA UTILIZA EL MÉTODO DEL CONTROLADOR ---
  function applyDamage(target, amount, component = 'chasis_frontal'){
      const isDead = target.applyDamage(amount, component);
      
      if(target === car) state.health = car.userData.health;

      if(isDead){
          const explosionLight = new THREE.PointLight(0xff8800, 5, 20);
          explosionLight.position.copy(target.position);
          scene.add(explosionLight);
          
          // Reinicio (Respawn)
          setTimeout(()=>{
              scene.remove(explosionLight); 
              target.position.set(
                  (Math.random() < 0.5 ? 1 : -1) * (ROAD_WIDTH/4 + Math.random() * ROAD_WIDTH/4),
                  0,
                  Math.random() * CITY_SIZE - CITY_SIZE/2
              );
              target.rotation.y = Math.random() * Math.PI * 2;
              target.userData.health = target.userData.maxHealth;
              target.componentes = JSON.parse(JSON.stringify(VEHICLE_STATS[target.userData.type].initialComponents || {})); // Resetear componentes
              target.userData.mainMesh.material.color.setHex(VEHICLE_STATS[target.userData.type].color);
          }, 500);
      }
  }

  // Colisión de Balas/Power-Ups/Coches
  function checkCollisions(dt){
      // 1. Balas vs. Enemigos/Jugador/Tráfico
      for(let i=bulletPool.length-1;i>=0;i--){
          const bullet = bulletPool[i];
          if(!bullet.visible) continue;
          let hit = false;
          
          const targets = [car, ...AI_CARS, ...TRAFFIC_CARS];
          for(const target of targets){
              if(target.position.distanceTo(bullet.position) < 3.0 && target.userData.health > 0){ 
                  // **SIMULACIÓN DE IMPACTO LOCALIZADO**
                  // Simulación básica de zona impactada (frontal vs trasero)
                  const dot = new THREE.Vector3().subVectors(target.position, bullet.position).normalize().dot(new THREE.Vector3(0,0,-1).applyQuaternion(target.quaternion));
                  const componentHit = dot > 0.5 ? 'chasis_frontal' : (dot < -0.5 ? 'motor' : 'ruedas_traseras'); 
                  
                  applyDamage(target, bullet.userData.damage, componentHit);
                  hit = true;
                  break;
              }
          }

          if(hit || bullet.position.length() > CITY_SIZE * 2){
              releaseBullet(bullet);
          } else {
              bullet.position.add(bullet.userData.dir.clone().multiplyScalar(bullet.userData.speed * dt));
          }
      }
      
      // ... Lógica de Power-Ups y Bordes (sin cambios significativos)
      
      state.health = car.userData.health; 
  }
  
  // Camera Follow
  function updateCamera(){
    // ... Lógica de cámara
  }

  // Actualización del HUD (AHORA INCLUYE DIAGNÓSTICO DE COMPONENTES)
  function updateHUD(){
      document.getElementById('healthBar').style.width = (state.health / car.userData.maxHealth * 100) + '%';
      document.getElementById('ammoBar').style.width = (state.ammo / car.userData.maxAmmo * 100) + '%';
      document.getElementById('ammoCount').textContent = state.ammo;
      document.getElementById('carType').textContent = CURRENT_CAR_TYPE;
      
      const kmh = Math.round(Math.abs(car.userData.speed) / car.userData.maxSpeed * 200);
      document.getElementById('speedDisplay').textContent = kmh;
      
      // **ACTUALIZACIÓN DEL DIAGNÓSTICO DE COMPONENTES (LUJO DE DETALLE)**
      let html = '';
      for (const key in car.componentes) {
          const comp = car.componentes[key];
          let className = 'estado-ok';
          if (comp.estado === 'CRÍTICO') className = 'estado-critico';
          else if (comp.estado === 'DAÑADO') className = 'estado-danado';

          html += `<p class="componente-estado"><strong>${comp.efecto.toUpperCase()}:</strong> <span class="${className}">${comp.estado} (${comp.vida}%)</span></p>`;
      }
      UI_COMP_EL.innerHTML = html;
  }

  // ---------- INPUTS Y CONTROLES (Sin cambios) ----------
  const joy = document.getElementById('joy'), stickEl = document.getElementById('stick');
  let touchId = null, baseX=0, baseY=0;
  let stick = {x:0,y:0};
  // ... Lógica de joystick y botones (omito por brevedad)
  
  function doFire(){
      // ... Lógica de disparo
  }
  
  function spawnBullet(pos, dir){
    // ... Lógica de spawn de bala
  }

  // ---------- RENDER LOOP (MÁS IMPORTANTE) ----------
  let last = performance.now(); let lastFireTime = 0; let frames = 0; let fpsNow = 0;
  function animate(){
    const now = performance.now();
    const dt = Math.min(50, now-last) / 16.666;
    last = now;
    
    // Player movement
    if(state.health > 0){
        state.forward = Math.max(-1, Math.min(1, stick.y));
        state.turn = Math.max(-1, Math.min(1, stick.x));
        
        // **FÍSICA AFECTADA POR EL DAÑO (LUJO DE DETALLE)**
        const physicsMod = car.getPhysicsModifier();
        let maxSpeed = car.userData.maxSpeed * physicsMod.maxSpeedMod * (state.turbo ? 1.8 : 1.0); 
        
        // Aceleración y Fricción
        if(state.forward > 0.05) car.userData.speed += 0.018 * state.forward * dt;
        else if(state.forward < -0.05) car.userData.speed -= 0.03 * (-state.forward) * dt;
        else car.userData.speed *= 0.96;
        
        // Clamp de Velocidad
        car.userData.speed = Math.max(-maxSpeed * 0.5, Math.min(maxSpeed, car.userData.speed));
        
        // Rotación y Giro Afectado
        const currentSpeedFactor = Math.abs(car.userData.speed / car.userData.maxSpeed);
        let rotationMultiplier = 1;
        if(currentSpeedFactor > 0.6 && Math.abs(state.turn) > 0.4) rotationMultiplier = 0.5 + 0.5 * (1 - Math.abs(state.turn)); 
        
        car.rotation.y += -state.turn * car.userData.rotSpeed * physicsMod.rotSpeedMod * (0.9 + currentSpeedFactor) * dt * rotationMultiplier;
        
        const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion);
        car.position.add(fwd.multiplyScalar(car.userData.speed * dt * 0.82));
        car.userData.neonLight.intensity = state.turbo ? (BLOOM_ENABLED ? 8 : 5) : (BLOOM_ENABLED ? 2 : 1.5);
        
        // ... Lógica de IA y Tráfico (modificada para usar car.userData.speed)
        
        checkCollisions(dt);
    }
    
    updateCamera();
    updateHUD();
    
    // RENDERIZADO CON O SIN BLOOM
    if(composer){
        composer.render();
    } else {
        renderer.render(scene, camera);
    }
    
    frames++; if(now - fpsLast >= 500){ fpsNow = Math.round((frames*1000)/(now-fpsLast)); frames = 0; fpsLast = now; document.getElementById('fps').textContent = `FPS: ${fpsNow}`; }
    requestAnimationFrame(animate);
  }
  let fpsLast = performance.now();

  // ---------- INITIALIZATION ----------
  document.getElementById('loading').style.display = 'none';
  requestAnimationFrame(animate);

  window.addEventListener('resize', ()=>{ 
    renderer.setSize(window.innerWidth, window.innerHeight); 
    camera.aspect = innerWidth/innerHeight; 
    camera.updateProjectionMatrix(); 
    if(composer) composer.setSize(window.innerWidth, window.innerHeight);
  });

})();
</script>
</body>
</html>
