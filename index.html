<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>SinFiltro ‚Äî Jardines de Morelos (OPTIMIZADO para M√≥vil)</title>
<style>
  /* AJUSTES DE DISE√ëO GAMER */
  :root{--bg:#05060a;--muted:#9fb0bf;--accent1:#ff3333;--accent2:#ff8833;--shadow:rgba(0,0,0,0.8)}
  html,body{height:100%;margin:0;background:linear-gradient(#05060a,#071226);font-family:Inter,system-ui,-apple-system,Arial;color:#eaf7ff;overflow:hidden}
  #holder{width:100%;height:100%;position:relative;touch-action:none}
  
  /* top UI */
  .topbar{position:fixed;left:8px;right:8px;top:10px;height:40px;display:flex;align-items:center;justify-content:space-between;gap:8px;z-index:120;pointer-events:auto;font-size:12px}
  .badge{background:var(--shadow);padding:6px 10px;border-radius:6px;font-weight:600;border:1px solid rgba(255,255,255,0.1)}
  .controls{display:flex;gap:6px}
  .chip{padding:6px 10px;border-radius:6px;background:linear-gradient(90deg,var(--accent1),var(--accent2));color:#111;font-weight:700;cursor:pointer;box-shadow:0 3px 10px var(--shadow);border:1px solid #ffaa44}
  
  /* joystick */
  .joy { position:fixed; left:12px; bottom:12px; width:100px; height:100px; border-radius:50px; background:var(--shadow); display:flex; align-items:center; justify-content:center; pointer-events:auto; z-index:100; border:2px solid rgba(255,255,255,0.1) }
  .stick { width:40px; height:40px; border-radius:50%; background:rgba(255,255,255,0.15); transform:translate(0,0) }
  
  /* fire button - M√ÅS GRANDE Y CENTRAL */
  .fire { position:fixed; right:120px; bottom:20px; width:70px; height:70px; border-radius:50%; background:linear-gradient(135deg,var(--accent1),#ff0000); display:flex;align-items:center;justify-content:center;z-index:100;pointer-events:auto;box-shadow:0 0 20px #ff0000; font-size:30px; border:3px solid #fff }
  
  /* minimap - M√ÅS PEQUE√ëO */
  .minimap{position:fixed;right:12px;bottom:12px;width:88px;height:88px;border-radius:8px;background:var(--shadow);z-index:110;display:flex;align-items:center;justify-content:center;pointer-events:auto;box-shadow:0 6px 15px var(--shadow); border:1px solid rgba(255,255,255,0.1)}
  
  /* Info/FPS */
  .fps{position:fixed;left:12px;bottom:120px;background:var(--shadow);padding:4px 8px;border-radius:4px;font-weight:600;z-index:110;font-size:12px}
  .info{position:fixed;left:12px;bottom:148px;background:var(--shadow);padding:4px 8px;border-radius:4px;z-index:110;font-size:12px}
  
  /* small responsive adjustments */
  @media (max-width:420px){ 
    .joy{width:90px;height:90px;left:8px;bottom:8px;} 
    .minimap{width:80px;height:80px;right:8px;bottom:8px;}
    .fire{right:100px;bottom:12px;width:60px;height:60px;font-size:24px}
    .fps{left:8px;bottom:100px;} 
    .info{left:8px;bottom:128px;}
  }
  
  /* loader */
  #loading{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:130;background:var(--shadow);padding:14px 18px;border-radius:12px}
</style>
</head>
<body>
  <div id="holder"></div>

  <div class="topbar">
    <div style="display:flex;gap:8px;align-items:center">
      <div class="badge">Jardines de Morelos (Ecatepec)</div>
      <div id="statusTiles" class="badge" style="display:none">V√≠as: <span id="tilesCount">0</span></div>
    </div>
    <div class="controls">
      <div id="btnToggleRoads" class="chip">MAPA: ON</div>
      <div id="btnToggleSat" class="chip">SAT: OFF</div>
      <div id="btnRecenter" class="chip">RESET</div>
    </div>
  </div>

  <div id="loading">Cargando calles y edificios...</div>

  <div class="joy" id="joy"><div class="stick" id="stick"></div></div>
  <div class="fire" id="fire">üéØ</div>
  <div class="minimap" id="minimap">Mini</div>
  <div class="fps" id="fps">FPS: --</div>
  <div class="info" id="info">Modo DEMO ‚Äî Optimizando</div>

<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<script>
(async function(){
  // ---------- CONFIG ----------
  const holder = document.getElementById('holder');
  // Bounding box for JARDINES DE MORELOS, ECATEPEC (Zona Playa Azul, Nicol√°s Bravo)
  const BBOX = [19.593, -99.002, 19.613, -98.982]; 
  const OVERPASS_URL = 'https://overpass-api.de/api/interpreter';
  const ESRI_TILE = 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}';

  // --- AJUSTES DE ESCALA Y COLOR ---
  const SCENE_SCALE = 0.08; 
  const CAR_WIDTH = 2.4;    
  const STREET_COLOR = 0x282c35; 
  const BUILDING_COLOR_BASE = 0x3d414a; 
  const BUILDING_COLOR_ACCENT = 0x5a6068; 
  const BULB_COLOR = 0xffe9a1; // Color c√°lido de farola
  // ----------------------------------------

  // ---------- THREEJS basic scene ----------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x05060a);
  // NIEBLA DE BAJO COSTO (Sin Post-FX)
  scene.fog = new THREE.Fog(scene.background, 10, 150); 
  
  const renderer = new THREE.WebGLRenderer({antialias:true, alpha:false});
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;
  // ** [OPTIMIZACI√ìN: Sombra de bajo costo] **
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap; // PCF para sombras suaves
  holder.appendChild(renderer.domElement);
  
  // camera
  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 5000);
  camera.position.set(0, 12, 24);

  // lights
  const dir = new THREE.DirectionalLight(0xffffff, 0.9);
  dir.position.set(5,10,7); 
  dir.castShadow = true;
  dir.shadow.mapSize.width = 1024;
  dir.shadow.mapSize.height = 1024;
  dir.shadow.camera.near = 0.5;
  dir.shadow.camera.far = 50;
  dir.shadow.camera.left = -50;
  dir.shadow.camera.right = 50;
  dir.shadow.camera.top = 50;
  dir.shadow.camera.bottom = -50;
  scene.add(dir);
  scene.add(new THREE.AmbientLight(0xffffff, 0.15)); 

  // ground plane base (Recibe sombras)
  const groundMat = new THREE.MeshStandardMaterial({color:0x111217, roughness:0.9, metalness:0.1});
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000,1,1), groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.position.y = 0;
  ground.receiveShadow = true; 
  scene.add(ground);

  // world transform
  const latCenter = (BBOX[0] + BBOX[2]) / 2;
  const lonCenter = (BBOX[1] + BBOX[3]) / 2;
  const EARTH_RADIUS = 6378137;

  function metersPerDegLat(){ return (Math.PI/180) * EARTH_RADIUS; }
  function metersPerDegLon(lat){ return (Math.PI/180) * EARTH_RADIUS * Math.cos(lat * Math.PI/180); }

  const mPerDegLat = metersPerDegLat();
  const mPerDegLon = metersPerDegLon(latCenter);

  function ll2xy(lat, lon){
    const dx = (lon - lonCenter) * mPerDegLon;
    const dz = (lat - latCenter) * mPerDegLat;
    const SCALE = SCENE_SCALE; 
    return new THREE.Vector3(dx * SCALE, 0, -dz * SCALE);
  }

  // Player car 
  const car = new THREE.Group();
  const body = new THREE.Mesh(new THREE.BoxGeometry(CAR_WIDTH,0.7,4.2), new THREE.MeshStandardMaterial({color:0xff5555}));
  body.position.y = 0.7; 
  body.castShadow = true; // El carro proyecta sombras
  car.add(body);
  const wheelGeo = new THREE.CylinderGeometry(0.35,0.35,0.5,8);
  const wheelMat = new THREE.MeshStandardMaterial({color:0x111111});
  for(let i=0;i<4;i++){
    const w = new THREE.Mesh(wheelGeo, wheelMat);
    w.rotation.z = Math.PI/2; w.position.y = 0.25;
    w.position.x = (i%2===0)?-(CAR_WIDTH/2 - 0.2): (CAR_WIDTH/2 - 0.2);
    w.position.z = (i<2)?1.2:-1.2;
    w.castShadow = true;
    car.add(w);
  }
  car.position.set(0,0,0);
  scene.add(car);

  // movement state (joystick)
  const state = {forward:0, turn:0, speed:0, maxSpeed:0.9, rotSpeed:0.045};
  
  // ** [MEJORA: Vuelve el sistema de "disparo" simple] **
  const bullets = [];
  function spawnBullet(origin, dir){
    const g = new THREE.SphereGeometry(0.12,8,8);
    const m = new THREE.MeshStandardMaterial({emissive:0xffcc77,color:0x222222});
    const b = new THREE.Mesh(g,m);
    b.position.copy(origin);
    b.userData.dir = dir.clone();
    b.userData.speed = 2.4;
    scene.add(b); bullets.push(b);
  }

  // camera follow
  function updateCamera(){
    const desired = car.position.clone().add(new THREE.Vector3(0,4,10).applyQuaternion(car.quaternion));
    camera.position.lerp(desired, 0.12);
    camera.lookAt(car.position.clone().add(new THREE.Vector3(0,1.2,0)));
  }

  // ---------- fetch OSM via Overpass (roads + buildings) ----------
  function overpassQuery(bbox){
    const [s,w,n,e] = bbox;
    const q = `
      [out:json][timeout:25];
      (
        way["highway"](${s},${w},${n},${e});
        way["building"](${s},${w},${n},${e});
      );
      (._;>;);
      out body;
    `;
    return q;
  }

  async function fetchOSM(){
    const query = overpassQuery(BBOX);
    const res = await fetch(OVERPASS_URL, {method:'POST',body:query});
    if(!res.ok) throw new Error('Overpass error');
    const data = await res.json();
    return data;
  }

  function parseOverpass(data){
    const nodes = new Map();
    const ways = [];
    for(const el of data.elements){
      if(el.type === 'node'){
        nodes.set(el.id, el);
      }
    }
    for(const el of data.elements){
      if(el.type === 'way'){
        const tags = el.tags || {};
        ways.push({id:el.id, nodes: el.nodes, tags});
      }
    }
    return {nodes, ways};
  }

  // build scene geometry for roads + buildings
  const roadsGroup = new THREE.Group();
  const buildingsGroup = new THREE.Group();
  scene.add(roadsGroup); scene.add(buildingsGroup);

  const roadPolylines = []; 

  // Add simple lamp posts to scene (for visual)
  function addLampAt(pos){
    // ** [OPTIMIZACI√ìN: Punto de luz para simular Bloom] **
    const pointLight = new THREE.PointLight(BULB_COLOR, 10, 15, 2);
    pointLight.position.copy(pos).add(new THREE.Vector3(0, 2.2, 0));
    scene.add(pointLight);

    const stick = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,2,6), new THREE.MeshStandardMaterial({color:0x111111}));
    stick.position.copy(pos).add(new THREE.Vector3(0,1,0));
    stick.castShadow = true;
    scene.add(stick);
    
    // ** [OPTIMIZACI√ìN: MeshBasicMaterial para el bulbo (m√°s eficiente)] **
    const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.08,8,8), new THREE.MeshBasicMaterial({color:BULB_COLOR}));
    bulb.position.copy(pos).add(new THREE.Vector3(0,2,0));
    scene.add(bulb);
  }

  function buildRoads(nodes, ways){
    const keep = new Set(['motorway','trunk','primary','secondary','tertiary','unclassified','residential','service','living_street']);
    let segmentCount = 0, wayCount = 0;
    roadsGroup.children.slice().forEach(c=>roadsGroup.remove(c));

    for(const w of ways){
      if(!w.tags || !w.tags.highway) continue;
      if(!keep.has(w.tags.highway) && w.tags.highway!=='residential') continue;
      const pts = [];
      for(const nid of w.nodes){
        const n = nodes.get(nid);
        if(!n) continue;
        pts.push(ll2xy(n.lat, n.lon));
      }
      if(pts.length < 2) continue;
      const simplified = [];
      for(let i=0;i<pts.length;i+=1){ simplified.push(pts[i]); }
      
      for(let i=0;i<simplified.length-1;i++){
        const a = simplified[i], b = simplified[i+1];
        const seg = new THREE.Vector3().copy(b).sub(a);
        const len = seg.length();
        const mid = a.clone().add(b).multiplyScalar(0.5);
        const width = (w.tags.highway === 'motorway' || w.tags.highway === 'trunk') ? 4.5 : 3.0;
        const geom = new THREE.BoxGeometry(width, 0.02, Math.max(len,0.1));
        const mat = new THREE.MeshStandardMaterial({color:STREET_COLOR, roughness:0.9});
        const m = new THREE.Mesh(geom, mat);
        m.position.copy(mid); m.position.y = 0.01;
        m.lookAt(b); m.rotateX(Math.PI/2); 
        m.receiveShadow = true;
        roadsGroup.add(m);
        segmentCount++;

        // ** [OPTIMIZACI√ìN: Farolas s√≥lo en segmentos largos] **
        if (len > 12 && i % 4 === 0) { 
             addLampAt(a);
        }
      }
      const poly = simplified.map(p=> new THREE.Vector3(p.x,0,p.z));
      roadPolylines.push(poly);
      wayCount++;
    }
    return {segmentCount, wayCount};
  }

  function buildBuildings(nodes, ways){
    buildingsGroup.children.slice().forEach(c=>buildingsGroup.remove(c));
    let count = 0;
    for(const w of ways){
      if(!w.tags || !w.tags.building) continue;
      const pts = [];
      for(const nid of w.nodes){
        const n = nodes.get(nid);
        if(!n) continue;
        pts.push(ll2xy(n.lat, n.lon));
      }
      if(pts.length < 3) continue;
      let minx=1e9,minz=1e9,maxx=-1e9,maxz=-1e9;
      for(const p of pts){ minx=Math.min(minx,p.x); maxx=Math.max(maxx,p.x); minz=Math.min(minz,p.z); maxz=Math.max(maxz,p.z); }
      const wth = Math.max(1.0, (maxx-minx));
      const lng = Math.max(1.0, (maxz-minz));
      const height = (w.tags['building:levels'] ? Math.max(2, +w.tags['building:levels']) : Math.floor(2 + Math.random()*4)) * 1.8;
      const g = new THREE.BoxGeometry(wth, height, lng);
      
      const color = count % 2 === 0 ? BUILDING_COLOR_BASE : BUILDING_COLOR_ACCENT;
      const mat = new THREE.MeshStandardMaterial({color:color, roughness:0.9});
      
      const b = new THREE.Mesh(g, mat);
      b.position.set((minx+maxx)/2, height/2, (minz+maxz)/2);
      b.castShadow = true; // Los edificios proyectan sombras
      b.receiveShadow = true;
      buildingsGroup.add(b);
      count++;
    }
    return count;
  }

  // ---------- Load OSM, build scene ----------
  async function initMapData(){
    try{
      const raw = await fetchOSM();
      const {nodes, ways} = parseOverpass(raw);
      const roadsInfo = buildRoads(nodes, ways);
      const bcount = buildBuildings(nodes, ways);
      
      document.getElementById('tilesCount').textContent = roadPolylines.length;
      document.getElementById('statusTiles').style.display = 'inline-block';
      document.getElementById('info').textContent = `Calles: ${roadPolylines.length} | Edificios: ${bcount}`;
      document.getElementById('loading').style.display = 'none';
      return true;
    }catch(err){
      console.error(err);
      document.getElementById('loading').textContent = 'Error cargando mapa. Intenta recargar o ajustar el BBOX.';
      return false;
    }
  }

  // ---------- Road-following / soft collision constraint ----------
  function constrainToRoad(pos){
    let best = {dist:1e9, nearest:null};
    for(const poly of roadPolylines){
      for(let i=0;i<poly.length-1;i++){
        const a = poly[i], b = poly[i+1];
        const ap = pos.clone().sub(a);
        const ab = b.clone().sub(a);
        const t = Math.max(0, Math.min(1, ap.dot(ab)/ab.lengthSq()));
        const proj = a.clone().add(ab.multiplyScalar(t));
        const d = proj.distanceTo(pos);
        if(d < best.dist){ best.dist = d; best.nearest = proj; }
      }
    }
    if(!best.nearest) return {constrained:false};
    const maxLat = 1.6; 
    if(best.dist > maxLat){
      const dir = best.nearest.clone().sub(pos).multiplyScalar(0.22);
      pos.add(dir);
      return {constrained:true};
    }
    return {constrained:false};
  }

  // ---------- Satellite texture (single tile approximation) ----------
  let satTexture = null, satEnabled = false;
  async function loadSatellite(){
    try{
      const z = 16;
      function lon2tile(lon,z){ return Math.floor((lon+180)/360*Math.pow(2,z)); }
      function lat2tile(lat,z){ return Math.floor((1-Math.log(Math.tan(lat*Math.PI/180)+1/Math.cos(lat*Math.PI/180))/Math.PI)/2 * Math.pow(2,z)); }
      const tx = lon2tile(lonCenter, z);
      const ty = lat2tile(latCenter, z);
      const url = ESRI_TILE.replace('{z}',z).replace('{x}',tx).replace('{y}',ty);
      const img = await new Promise((res,rej)=>{ const i=new Image(); i.crossOrigin='anonymous'; i.onload=()=>res(i); i.onerror=rej; i.src=url; });
      const tex = new THREE.CanvasTexture(img);
      tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
      tex.encoding = THREE.sRGBEncoding;
      satTexture = tex;
      return true;
    }catch(e){ console.warn('sat load failed', e); return false; }
  }

  function enableSatellite(on){
    if(on && satTexture){
      ground.material = new THREE.MeshBasicMaterial({map: satTexture});
      satEnabled = true;
      document.getElementById('btnToggleSat').textContent = 'SAT: ON';
    } else {
      ground.material = groundMat;
      satEnabled = false;
      document.getElementById('btnToggleSat').textContent = 'SAT: OFF';
    }
  }

  // ---------- Minimap (Optimizado) ----------
  const minimap = document.getElementById('minimap');
  const mmCanvas = document.createElement('canvas');
  mmCanvas.width = mmCanvas.height = 256;
  minimap.innerHTML = ''; minimap.appendChild(mmCanvas);
  const mmCtx = mmCanvas.getContext('2d');

  function updateMinimap(){
    const scale = 0.35; 
    mmCtx.clearRect(0,0,256,256);
    mmCtx.fillStyle = '#07101a'; mmCtx.fillRect(0,0,256,256);
    mmCtx.strokeStyle = '#ffaa44'; // Color de ruta m√°s visible
    mmCtx.lineWidth = 4;
    mmCtx.beginPath();
    for(const poly of roadPolylines){
      if(poly.length<2) continue;
      for(let i=0;i<poly.length;i++){
        const p = poly[i];
        const x = 128 + p.x * scale;
        const y = 128 + p.z * scale;
        if(i===0) mmCtx.moveTo(x,y); else mmCtx.lineTo(x,y);
      }
    }
    mmCtx.stroke();
    const px = 128 + car.position.x * scale;
    const py = 128 + car.position.z * scale;
    mmCtx.fillStyle = '#ff3333'; // Marcador de carro rojo
    mmCtx.beginPath(); mmCtx.arc(px,py,6,0,Math.PI*2); mmCtx.fill();
  }

  // ---------- Input: joystick handling (touch + pointer) ----------
  const joy = document.getElementById('joy'), stickEl = document.getElementById('stick');
  let touchId = null, baseX=0, baseY=0;
  let stick = {x:0,y:0};
  function resetStick(){ stick={x:0,y:0}; stickEl.style.transform = `translate(0px,0px)`; }

  joy.addEventListener('touchstart', e=>{ e.preventDefault(); const t = e.changedTouches[0]; touchId = t.identifier; baseX=t.clientX; baseY=t.clientY; }, {passive:false});
  joy.addEventListener('touchmove', e=>{ e.preventDefault(); for(const t of e.changedTouches){ if(t.identifier===touchId){ const dx=t.clientX-baseX, dy=t.clientY-baseY; const max=36; const nx=Math.max(-1,Math.min(1,dx/max)); const ny=Math.max(-1,Math.min(1,dy/max)); stick.x = nx; stick.y = -ny; stickEl.style.transform = `translate(${nx*28}px,${-ny*28}px)`; } } }, {passive:false});
  joy.addEventListener('touchend', e=>{ for(const t of e.changedTouches){ if(t.identifier===touchId){ touchId=null; resetStick(); } } }, {passive:false});
  let md=false;
  joy.addEventListener('pointerdown', e=>{ md=true; baseX=e.clientX; baseY=e.clientY; joy.setPointerCapture(e.pointerId); });
  joy.addEventListener('pointermove', e=>{ if(!md) return; const dx=e.clientX-baseX, dy=e.clientY-baseY; const max=36; const nx=Math.max(-1,Math.min(1,dx/max)); const ny=Math.max(-1,Math.min(1,dy/max)); stick.x=nx; stick.y=-ny; stickEl.style.transform=`translate(${nx*28}px,${-ny*28}px)`; });
  joy.addEventListener('pointerup', e=>{ md=false; resetStick(); });
  
  // ** [MEJORA: Bot√≥n de disparo funcional] **
  const fireBtn = document.getElementById('fire');
  fireBtn.addEventListener('touchstart', e=>{ e.preventDefault(); doFire(); }, {passive:false});
  fireBtn.addEventListener('mousedown', doFire);

  function doFire(){
    const dir = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion).normalize();
    const origin = car.position.clone().add(new THREE.Vector3(0,1,-2).applyQuaternion(car.quaternion));
    spawnBullet(origin, dir);
  }

  // ---------- UI toggles ----------
  let roadsVisible = true;
  document.getElementById('btnToggleRoads').addEventListener('click', ()=>{
    roadsVisible = !roadsVisible;
    roadsGroup.visible = roadsVisible;
    document.getElementById('btnToggleRoads').textContent = `MAPA: ${roadsVisible ? 'ON' : 'OFF'}`;
  });

  document.getElementById('btnToggleSat').addEventListener('click', async ()=>{
    if(!satTexture){ document.getElementById('btnToggleSat').textContent = 'SAT: Cargando...'; await loadSatellite(); }
    enableSatellite(!satEnabled);
  });

  document.getElementById('btnRecenter').addEventListener('click', ()=> {
    car.position.set(0,0,0); car.rotation.set(0,0,0);
    camera.position.set(0,12,24);
  });

  // ---------- render loop ----------
  let last = performance.now(); let frames = 0; let fpsNow = 0;
  function animate(){
    const now = performance.now();
    const dt = Math.min(50, now-last) / 16.666;
    last = now;
    
    state.forward = Math.max(-1, Math.min(1, stick.y));
    state.turn = Math.max(-1, Math.min(1, stick.x));
    
    if(state.forward > 0.05) state.speed += 0.018 * state.forward * dt;
    else if(state.forward < -0.05) state.speed -= 0.03 * (-state.forward) * dt;
    else state.speed *= 0.96;
    state.speed = Math.max(-state.maxSpeed, Math.min(state.maxSpeed, state.speed));
    
    car.rotation.y += -state.turn * state.rotSpeed * (0.9 + Math.abs(state.speed)) * dt;
    
    const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion);
    car.position.add(fwd.multiplyScalar(state.speed * dt * 0.82));
    
    constrainToRoad(car.position);

    // Actualizaci√≥n de balas
    for(let i=bullets.length-1;i>=0;i--){
      const b = bullets[i];
      b.position.add(b.userData.dir.clone().multiplyScalar(b.userData.speed * dt));
      if(b.position.length() > 800) { scene.remove(b); bullets.splice(i,1); }
    }
    
    updateCamera();
    updateMinimap();
    
    // ** [RENDERIZADO DIRECTO para M√°ximo Rendimiento] **
    renderer.render(scene, camera);
    
    // fps
    frames++; if(now - fpsLast >= 500){ fpsNow = Math.round((frames*1000)/(now-fpsLast)); frames = 0; fpsLast = now; document.getElementById('fps').textContent = `FPS: ${fpsNow}`; }
    requestAnimationFrame(animate);
  }
  let fpsLast = performance.now();

  // ---------- initialization ----------
  const ok = await initMapData();
  loadSatellite().then(()=>{ /*sat preloaded*/ }).catch(()=>{/*ignore*/});
  requestAnimationFrame(animate);

  // ---------- simple cleanup / resize ----------
  window.addEventListener('resize', ()=>{ 
    renderer.setSize(window.innerWidth, window.innerHeight); 
    camera.aspect = innerWidth/innerHeight; 
    camera.updateProjectionMatrix(); 
  });

  if(roadPolylines.length && roadPolylines[0].length){
    car.position.copy(roadPolylines[0][ Math.floor(roadPolylines[0].length/2) ]);
  }

  document.getElementById('tilesCount').textContent = roadPolylines.length;

})();
</script>
</body>
</html>
