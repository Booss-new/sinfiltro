<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>SinFiltro â€” Playa Azul (demo)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
<style>
  :root{--bg:#05060a;--ui:#0b1014;--accent-c:#00d1ff;--accent-v:#8a6eff;--muted:#9fb0bf}
  html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,system-ui,Arial;color:#eaf7ff;overflow:hidden}
  #holder{position:fixed;inset:0;background:linear-gradient(180deg,#05060a,#071226)}
  canvas{display:block}
  /* UI overlays */
  .topbar{position:fixed;left:12px;right:12px;top:12px;height:56px;display:flex;align-items:center;justify-content:space-between;z-index:120}
  .brand{background:rgba(255,255,255,0.03);padding:8px 12px;border-radius:12px;font-weight:700}
  .controls{display:flex;gap:8px}
  .btn{padding:8px 12px;border-radius:12px;background:linear-gradient(90deg,var(--accent-c),var(--accent-v));color:#001;font-weight:600;border:none}
  .smallBtn{padding:8px 10px;border-radius:10px;background:rgba(255,255,255,0.03);color:var(--muted);border:none}
  /* joystick */
  .joy{position:fixed;left:18px;bottom:18px;width:110px;height:110px;border-radius:60px;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;pointer-events:auto;z-index:110}
  .stick{width:48px;height:48px;border-radius:50%;background:rgba(255,255,255,0.06);transform:translate(0,0)}
  .fire{position:fixed;right:18px;bottom:32px;width:72px;height:72px;border-radius:50%;background:linear-gradient(135deg,var(--accent-c),var(--accent-v));z-index:110;display:flex;align-items:center;justify-content:center;color:#001;font-size:22px}
  /* minimap */
  #minimap{position:fixed;right:12px;bottom:110px;width:96px;height:96px;border-radius:12px;background:rgba(0,0,0,0.45);z-index:120;padding:6px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
  #infoBox{position:fixed;left:12px;bottom:12px;padding:8px 12px;border-radius:12px;background:rgba(0,0,0,0.55);z-index:120;color:var(--muted);font-size:13px}
  /* small notifications */
  .badge{position:fixed;right:12px;top:74px;background:linear-gradient(90deg,var(--accent-c),var(--accent-v));padding:6px 10px;border-radius:12px;color:#001;font-weight:700;z-index:120}
  @media(max-width:420px){ .joy{width:96px;height:96px}.stick{width:42px;height:42px}.fire{width:64px;height:64px} }
</style>
</head>
<body>
  <div id="holder"></div>

  <div class="topbar">
    <div class="brand">SinFiltro â€” Playa Azul (demo)</div>
    <div class="controls">
      <button id="toggleRoads" class="btn">Calles: ON</button>
      <button id="toggleSat" class="smallBtn">SatÃ©lite: OFF</button>
      <button id="recenter" class="smallBtn">Re-cent.</button>
    </div>
  </div>

  <div id="minimap"><canvas id="miniCanvas" width="192" height="192" style="width:100%;height:100%;border-radius:8px;display:block"></canvas></div>
  <div class="badge" id="fpsBadge">FPS: --</div>

  <div class="joy" id="joy" aria-hidden="false"><div class="stick" id="stick"></div></div>
  <button id="fireBtn" class="fire">ðŸ”«</button>

  <div id="infoBox">Modo demo â€” calles y satÃ©lite cargados localmente</div>

  <!-- three.js -->
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

<script>
/*
  SinFiltro â€” Playa Azul (demo)
  - Texturiza el suelo con tiles OSM (o ESRI satÃ©lite) para la zona (Playas JM)
  - Mantiene la escena 3D y controles tÃ¡ctiles
  - Toggle Calles / SatÃ©lite, minimapa, FPS
  - Carga solo 3x3 tiles alrededor del centro para optimizaciÃ³n
*/

/* -------- CONFIG -------- */
const CENTER = { lat: 19.605200, lon: -99.000289 }; // Playa Azul (ejemplo)
const TILE_Z = 16;            // zoom tiles (puedes subir a 17 para +detalle)
const TILE_GRID = 3;         // 3x3 tiles
const TILE_SIZE = 512;       // tile px (we'll draw into canvas)
const USE_ESRI_SAT = true;   // toggle option uses ESRI imagery when SAT enabled

/* -------- helpers for tile math (WebMercator) -------- */
function long2tile(lon,zoom){ return Math.floor((lon+180)/360 * Math.pow(2,zoom)); }
function lat2tile(lat,zoom){
  const rad = lat*Math.PI/180;
  return Math.floor((1 - Math.log(Math.tan(rad) + 1/Math.cos(rad)) / Math.PI) / 2 * Math.pow(2,zoom));
}
function tile2long(x,z){ return x/Math.pow(2,z)*360-180; }
function tile2lat(y,z){
  const n = Math.PI - 2*Math.PI*y/Math.pow(2,z);
  return 180/Math.PI*Math.atan(0.5*(Math.exp(n)-Math.exp(-n)));
}

/* -------- tile URL providers (no API key) -------- */
function osmTileURL(x,y,z){
  // OpenStreetMap standard tile server (public). Respect usage policy for production.
  return `https://tile.openstreetmap.org/${z}/${x}/${y}.png`;
}
function esriSatTile(x,y,z){
  // ESRI WorldImagery (works publicly in many contexts)
  return `https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/${z}/${y}/${x}`;
}

/* -------- prepare canvas texture by loading a TILE_GRID x TILE_GRID block -------- */
async function loadTileGridTexture(centerLat, centerLon, zoom, grid, tileSize, satellite=false){
  const cx = long2tile(centerLon,zoom);
  const cy = lat2tile(centerLat,zoom);
  const half = Math.floor(grid/2);
  const width = tileSize * grid;
  const height = tileSize * grid;
  const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#0b0f12'; ctx.fillRect(0,0,width,height);

  // load images
  const requests = [];
  for(let ry=-half; ry<=half; ry++){
    for(let rx=-half; rx<=half; rx++){
      const tx = cx + rx;
      const ty = cy + ry;
      const url = satellite ? esriSatTile(tx,ty,zoom) : osmTileURL(tx,ty,zoom);
      requests.push({x:rx+half,y:ry+half,url});
    }
  }
  // fetch sequentially to avoid flooding tile server
  for(const req of requests){
    try{
      const img = await loadImg(req.url);
      ctx.drawImage(img, req.x*tileSize, req.y*tileSize, tileSize, tileSize);
    } catch(e){
      // on fail, draw placeholder
      ctx.fillStyle = '#111';
      ctx.fillRect(req.x*tileSize, req.y*tileSize, tileSize, tileSize);
    }
  }
  // return canvas texture and metadata (tile origin lat/lon)
  const topLeftTileX = cx - half;
  const topLeftTileY = cy - half;
  const topLeftLon = tile2long(topLeftTileX,zoom);
  const topLeftLat = tile2lat(topLeftTileY,zoom);
  return {canvas, topLeftTileX, topLeftTileY, topLeftLon, topLeftLat, zoom, tileSize, grid};
}
function loadImg(url){
  return new Promise((res,rej)=>{
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = ()=>res(img);
    img.onerror = ()=>rej(new Error('img fail:'+url));
    img.src = url;
  });
}

/* -------- Three.js scene (vehicle + ground) -------- */
let renderer, scene, camera;
let car, bot;
let groundMesh;
let clock = new THREE.Clock();

function initThree(container){
  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x05060a, 0.002);

  renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.6));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.shadowMap.enabled = false; // keep perf for mobile
  container.appendChild(renderer.domElement);

  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 5000);
  camera.position.set(0,6,12);

  // lights
  const dl = new THREE.DirectionalLight(0xffffff, 0.8);
  dl.position.set(10,20,10); scene.add(dl);
  scene.add(new THREE.AmbientLight(0xffffff, 0.25));

  // create car
  car = new THREE.Group();
  const body = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.7,4.2), new THREE.MeshStandardMaterial({color:0xff4e4e, metalness:0.3, roughness:0.6}));
  body.position.y = 0.7; car.add(body);
  const wheelGeo = new THREE.CylinderGeometry(0.36,0.36,0.5,8);
  const wheelMat = new THREE.MeshStandardMaterial({color:0x111111});
  for(let i=0;i<4;i++){ const w = new THREE.Mesh(wheelGeo, wheelMat); w.rotation.z = Math.PI/2; w.position.y = 0.25; w.position.x = (i%2===0)?-1:1; w.position.z = (i<2)?1.2:-1.2; car.add(w); }
  car.position.set(0,0,0);
  scene.add(car);

  // simple bot
  bot = car.clone(true);
  bot.children[0].material = new THREE.MeshStandardMaterial({color:0x3ea6ff});
  bot.position.set(8,0,-6);
  scene.add(bot);

  // small invisible boundary plane (placeholder)
  // groundMesh will be added later after texture load
  window.addEventListener('resize', onResize);
  renderer.domElement.style.touchAction = 'none'; // allow custom touch
}

function onResize(){
  if(!renderer) return;
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
}

/* ------ world control state ------ */
const state = {stick:{x:0,y:0},speed:0,turn:0,maxSpeed:0.9,rotSpeed:0.045};
let lastTime = performance.now();
const bullets = [];

/* joystick handlers (kept simple) */
function setupJoystick(){
  const joy = document.getElementById('joy'), stickEl = document.getElementById('stick');
  let touchId = null, baseX=0, baseY=0, md=false;
  function reset(){ state.stick.x=0; state.stick.y=0; stickEl.style.transform='translate(0px,0px)'; }
  joy.addEventListener('touchstart', e=>{ e.preventDefault(); const t = e.changedTouches[0]; touchId=t.identifier; baseX=t.clientX; baseY=t.clientY; }, {passive:false});
  joy.addEventListener('touchmove', e=>{ e.preventDefault(); for(const t of e.changedTouches) if(t.identifier===touchId){ const dx=t.clientX-baseX, dy=t.clientY-baseY, max=36; const nx=Math.max(-1,Math.min(1,dx/max)), ny=Math.max(-1,Math.min(1,dy/max)); state.stick.x=nx; state.stick.y=-ny; stickEl.style.transform=`translate(${nx*28}px,${-ny*28}px)`; } }, {passive:false});
  joy.addEventListener('touchend', e=>{ for(const t of e.changedTouches) if(t.identifier===touchId){ touchId=null; reset(); } }, {passive:false});
  // pointer
  joy.addEventListener('pointerdown', e=>{ md=true; baseX=e.clientX;baseY=e.clientY; joy.setPointerCapture(e.pointerId); });
  joy.addEventListener('pointermove', e=>{ if(!md) return; const dx=e.clientX-baseX, dy=e.clientY-baseY, max=36; const nx=Math.max(-1,Math.min(1,dx/max)), ny=Math.max(-1,Math.min(1,dy/max)); state.stick.x=nx; state.stick.y=-ny; stickEl.style.transform=`translate(${nx*28}px,${-ny*28}px)`; });
  joy.addEventListener('pointerup', e=>{ md=false; state.stick.x=0; state.stick.y=0; stickEl.style.transform='translate(0px,0px)'; });
}

function firingSetup(){
  const fire = document.getElementById('fireBtn');
  fire.addEventListener('touchstart', e=>{ e.preventDefault(); doFire(); }, {passive:false});
  fire.addEventListener('mousedown', ()=>doFire());
}
function doFire(){
  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion).normalize();
  const origin = car.position.clone().add(new THREE.Vector3(0,1,-2).applyQuaternion(car.quaternion));
  const g = new THREE.SphereGeometry(0.12,8,8);
  const m = new THREE.MeshStandardMaterial({emissive:0xffcc77,color:0x222222});
  const b = new THREE.Mesh(g,m); b.position.copy(origin); b.userData.dir = dir.clone(); b.userData.speed = 2.2;
  scene.add(b); bullets.push(b);
}

/* ------ animate loop ------ */
function animateLoop(){
  const now = performance.now();
  const dt = Math.min(50, now - lastTime) / 16.666; lastTime = now;
  // joystick -> state
  const forward = state.stick.y; const turn = state.stick.x;
  if(forward > 0.05) state.speed += 0.02 * forward * dt;
  else if(forward < -0.05) state.speed -= 0.03 * (-forward) * dt;
  else state.speed *= 0.975;
  state.speed = Math.max(-state.maxSpeed, Math.min(state.maxSpeed, state.speed));
  car.rotation.y += -turn * state.rotSpeed * (0.9 + Math.abs(state.speed)) * dt;

  const forwardVec = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion);
  car.position.add(forwardVec.multiplyScalar(state.speed * dt * 0.8));

  // camera follow
  const desired = car.position.clone().add(new THREE.Vector3(0,4,10).applyQuaternion(car.quaternion));
  camera.position.lerp(desired, 0.12);
  camera.lookAt(car.position.clone().add(new THREE.Vector3(0,1.5,0)));

  // bot simple
  bot.position.x = Math.cos(performance.now()*0.0006)*12;
  bot.position.z = Math.sin(performance.now()*0.0006)*12;
  bot.lookAt(car.position);

  // bullets
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i]; b.position.add(b.userData.dir.clone().multiplyScalar(b.userData.speed * dt));
    if(b.position.distanceTo(bot.position) < 1.4){ scene.remove(b); bullets.splice(i,1);
      const hit = new THREE.Mesh(new THREE.SphereGeometry(0.25,6,6), new THREE.MeshStandardMaterial({emissive:0xff5522,color:0x111111}));
      hit.position.copy(bot.position); scene.add(hit); setTimeout(()=>scene.remove(hit),600);
      continue;
    }
    if(b.position.length() > 1000){ scene.remove(b); bullets.splice(i,1); }
  }

  renderer.render(scene, camera);
  requestAnimationFrame(animateLoop);
}

/* ------ ground creation from tile canvas ------ */
function createGroundFromCanvas(canvas, meta){
  // remove previous ground
  if(groundMesh){ scene.remove(groundMesh); groundMesh.geometry.dispose(); groundMesh.material.map.dispose(); }

  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
  texture.encoding = THREE.sRGBEncoding;
  const mat = new THREE.MeshStandardMaterial({map: texture, roughness:0.9, metalness:0.02});
  // define physical size: we'll map tile canvas width -> world meters. choose scale
  const WORLD_SCALE = 0.6; // tweak: reduces world size for mobile perf
  const w = canvas.width * WORLD_SCALE, h = canvas.height * WORLD_SCALE;
  const geo = new THREE.PlaneGeometry(w, h, 1, 1);
  const mesh = new THREE.Mesh(geo, mat);
  mesh.rotation.x = -Math.PI/2;
  mesh.position.set(0,0,0); // anchor at center
  scene.add(mesh);
  groundMesh = mesh;

  // reposition car above center of map: compute center offset from top-left tile meta
  // compute center lat/lon and map pixel offset to place car at zero
  // For simplicity we place car at world center (0,0) which corresponds to center tile block
  car.position.set(0,0,0); bot.position.set(8,0,-6);
}

/* ------ minimap paint (just scale down same canvas) ------ */
function paintMini(canvas){
  const mini = document.getElementById('miniCanvas');
  const ctx = mini.getContext('2d');
  ctx.clearRect(0,0,mini.width,mini.height);
  try{ ctx.drawImage(canvas,0,0,mini.width,mini.height); } catch(e){}
}

/* ------ load sequence and UI wiring ------ */
let currentTextureMeta = null;
let currentCanvas = null;
let roadsOn = true;
let satelliteOn = false;

async function loadAndApply(){
  // show loading briefly
  document.getElementById('infoBox').textContent = 'Cargando tiles...';
  const res = await loadTileGridTexture(CENTER.lat, CENTER.lon, TILE_Z, TILE_GRID, TILE_SIZE, satelliteOn);
  currentCanvas = res.canvas;
  currentTextureMeta = res;
  // optionally, if roadsOff we could process image to hide roads - but we simply toggle by reloading with sat param or masked style
  createGroundFromCanvas(res.canvas, res);
  paintMini(res.canvas);
  document.getElementById('infoBox').textContent = 'Calles cargadas: ' + (res.grid*res.grid) + ' tiles';
}

document.getElementById('toggleRoads').addEventListener('click', async ()=>{
  roadsOn = !roadsOn;
  document.getElementById('toggleRoads').textContent = 'Calles: ' + (roadsOn?'ON':'OFF');
  // For demo, "Calles OFF" will switch to a desaturated style; here we just reload same tiles or satellite
  await loadAndApply();
});
document.getElementById('toggleSat').addEventListener('click', async ()=>{
  satelliteOn = !satelliteOn;
  document.getElementById('toggleSat').textContent = 'SatÃ©lite: ' + (satelliteOn?'ON':'OFF');
  await loadAndApply();
});
document.getElementById('recenter').addEventListener('click', ()=>{ car.position.set(0,0,0); camera.position.set(0,6,12); });

/* FPS counter */
let fpsLast = performance.now(), fpsCount = 0;
function fpsTick(){
  fpsCount++;
  const now = performance.now();
  if(now - fpsLast >= 500){
    const fps = Math.round((fpsCount*1000)/(now - fpsLast));
    document.getElementById('fpsBadge').textContent = `FPS: ${fps}`;
    fpsCount = 0; fpsLast = now;
  }
  requestAnimationFrame(fpsTick);
}

/* ------ init everything ------ */
async function start(){
  const container = document.getElementById('holder');
  initThree(container);
  setupJoystick();
  firingSetup();
  await loadAndApply();
  animateLoop();
  fpsTick();
}

/* start */
start().catch(err=>{ console.error(err); document.getElementById('infoBox').textContent = 'Error: ' + (err.message||err); });

/* small safety: prevent the page from stealing gestures */
document.addEventListener('touchmove', function(e){ /* allow default for scrolling disabled */ }, {passive:false});

</script>
</body>
</html>
