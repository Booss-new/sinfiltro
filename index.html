<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Battle Arena â€” Mustang (MÃ³vil Prototype)</title>
<meta name="description" content="Prototype: arena cerrada, mustang low-poly, armas, joystick, minimap. Optimizado mÃ³vil (Three.js)." />
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#05060a; --muted:#9fb0bf; --accent1:#00d1ff; --accent2:#8a6eff; --glass: rgba(255,255,255,0.03);
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#071226);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;color:#eaf7ff;overflow:hidden;-webkit-tap-highlight-color:transparent}
  #holder{width:100%;height:100%;position:relative;touch-action:none}
  /* top UI */
  .topbar{position:fixed;left:8px;right:8px;top:10px;height:56px;display:flex;align-items:center;justify-content:space-between;gap:8px;z-index:140;pointer-events:auto}
  .brand{padding:8px 12px;border-radius:12px;background:var(--glass);font-weight:700}
  .controls{display:flex;gap:8px}
  .chip{padding:8px 12px;border-radius:12px;background:linear-gradient(90deg,var(--accent1),var(--accent2));color:#001;font-weight:700;cursor:pointer;box-shadow:0 10px 40px rgba(0,0,0,0.45)}
  /* joystick + fire */
  .joy { position:fixed; left:18px; bottom:18px; width:110px; height:110px; border-radius:60px; background:rgba(255,255,255,0.03); display:flex; align-items:center; justify-content:center; pointer-events:auto; z-index:120 }
  .stick { width:48px; height:48px; border-radius:50%; background:rgba(255,255,255,0.06); transform:translate(0,0); box-shadow:0 6px 18px rgba(0,0,0,0.5) }
  .fire { position:fixed; right:18px; bottom:28px; width:72px; height:72px; border-radius:50%; background:linear-gradient(135deg,var(--accent1),var(--accent2)); display:flex;align-items:center;justify-content:center;z-index:120;pointer-events:auto;box-shadow:0 14px 60px rgba(0,0,0,0.6);font-size:22px }
  /* HUD */
  .minimap{position:fixed;right:12px;bottom:128px;width:110px;height:110px;border-radius:12px;background:rgba(0,0,0,0.5);z-index:125;display:flex;align-items:center;justify-content:center;pointer-events:auto;box-shadow:0 12px 30px rgba(0,0,0,0.6)}
  .fps{position:fixed;left:12px;bottom:128px;background:rgba(0,0,0,0.5);padding:6px 10px;border-radius:10px;font-weight:600;z-index:125}
  .health{position:fixed;left:12px;bottom:88px;background:rgba(0,0,0,0.35);padding:8px 10px;border-radius:10px;z-index:125}
  .info{position:fixed;left:12px;top:76px;background:rgba(0,0,0,0.25);padding:6px 8px;border-radius:8px;z-index:125;font-size:13px}
  .loader{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:200;background:rgba(0,0,0,0.6);padding:12px 16px;border-radius:12px}
  /* viewer modal */
  #viewer{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.85);z-index:230}
  #viewer img{max-width:90%;height:auto;border-radius:12px}
  /* responsive tweaks */
  @media(max-width:420px){ .joy{width:96px;height:96px} .stick{width:42px;height:42px} .fire{width:64px;height:64px} .minimap{width:88px;height:88px} .chip{padding:6px 8px;font-size:13px}}
</style>
</head>
<body>
  <div id="holder"></div>

  <div class="topbar">
    <div style="display:flex;gap:8px;align-items:center">
      <div class="brand" id="brandBtn">Battle Arena â€” Mustang</div>
      <div class="info" id="modeInfo">Arena cerrada Â· texturas reales</div>
    </div>
    <div class="controls">
      <div id="btnSat" class="chip">SatÃ©lite: OFF</div>
      <div id="btnReset" class="chip">Re-center</div>
    </div>
  </div>

  <div class="joy" id="joy"><div class="stick" id="stick"></div></div>
  <div class="fire" id="fire">ðŸ”«</div>
  <div class="minimap" id="minimap"></div>
  <div class="fps" id="fps">FPS: --</div>
  <div class="health" id="health">Salud: 100%</div>
  <div class="loader" id="loader">Cargando escenaâ€¦</div>

  <div id="viewer" role="dialog" aria-hidden="true">
    <div style="text-align:center">
      <img id="viewerImg" src="" alt="preview"><br><br>
      <button id="closeViewer" style="padding:8px 12px;border-radius:8px">Cerrar</button>
    </div>
  </div>

  <!-- three.js -->
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

<script>
/* ===========================================================
   Battle Arena (Mobile prototype)
   - Arena cerrada, Mustang low-poly, joystick, disparo, daÃ±os
   - Minimap, FPS, satellite toggle
   - Optimizaciones para mÃ³vil (pixel ratio cap, simple meshes)
   =========================================================== */

(async function(){
  // DOM
  const holder = document.getElementById('holder');
  const loader = document.getElementById('loader');
  const fpsEl = document.getElementById('fps');
  const healthEl = document.getElementById('health');
  const minimapEl = document.getElementById('minimap');
  const btnSat = document.getElementById('btnSat');
  const btnReset = document.getElementById('btnReset');
  const brandBtn = document.getElementById('brandBtn');
  const viewer = document.getElementById('viewer'), viewerImg = document.getElementById('viewerImg'), closeViewer = document.getElementById('closeViewer');

  // Scene
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x071226, 0.0025);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.5));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;
  holder.appendChild(renderer.domElement);
  renderer.domElement.style.touchAction = 'none';

  // Camera
  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
  camera.position.set(0,6,10);

  // Lights
  const dir = new THREE.DirectionalLight(0xffffff, 0.9);
  dir.position.set(5,10,7); scene.add(dir);
  scene.add(new THREE.AmbientLight(0xffffff, 0.35));

  // Ground (arena)
  const arenaSize = 120; // meters (scene units)
  const groundMatDefault = new THREE.MeshStandardMaterial({color:0x12161b, roughness:1, metalness:0.0});
  let ground = new THREE.Mesh(new THREE.PlaneGeometry(arenaSize, arenaSize, 1,1), groundMatDefault);
  ground.rotation.x = -Math.PI/2; ground.position.y = 0; scene.add(ground);

  // arena boundaries (invisible collision walls)
  const walls = new THREE.Group();
  const wallMat = new THREE.MeshBasicMaterial({color:0x000000, visible:false});
  const wallThickness = 1;
  const wallHeight = 6;
  // create four boundary boxes
  const createWall = (w,h,x,z,rot=0) => {
    const g = new THREE.BoxGeometry(w,h,wallThickness);
    const m = new THREE.Mesh(g, wallMat);
    m.position.set(x,h/2,z); m.rotation.y = rot;
    walls.add(m);
  };
  createWall(arenaSize, wallHeight, 0, -arenaSize/2, 0); // north
  createWall(arenaSize, wallHeight, 0, arenaSize/2, 0); // south
  createWall(arenaSize, wallHeight, -arenaSize/2, 0, Math.PI/2); // west
  createWall(arenaSize, wallHeight, arenaSize/2, 0, Math.PI/2); // east
  scene.add(walls);

  // Stadium details (simple props)
  function addPropBox(x,z,sx,sz,h,color=0x0f1720){
    const geo = new THREE.BoxGeometry(sx,h,sz);
    const mat = new THREE.MeshStandardMaterial({color, roughness:0.9});
    const m = new THREE.Mesh(geo, mat); m.position.set(x,h/2,z); scene.add(m);
  }
  for(let i=0;i<18;i++){
    const a = (Math.random()-0.5)*(arenaSize-20);
    const b = (Math.random()-0.5)*(arenaSize-20);
    addPropBox(a,b, 2+Math.random()*6, 2+Math.random()*6, 2+Math.random()*8, 0x0e1622);
  }

  // Player car: Mustang-like low-poly (approximated)
  const car = new THREE.Group();
  const bodyMat = new THREE.MeshStandardMaterial({color:0xff3333, metalness:0.35, roughness:0.45});
  const body = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.7,4.2), bodyMat);
  body.position.y = 0.7; car.add(body);
  // hood slope
  const hood = new THREE.Mesh(new THREE.BoxGeometry(2.0,0.35,1.4), new THREE.MeshStandardMaterial({color:0xff4444, metalness:0.3, roughness:0.45}));
  hood.position.set(0,0.95,1.0); hood.rotation.x = -0.12; car.add(hood);
  // roof
  const roof = new THREE.Mesh(new THREE.BoxGeometry(1.6,0.35,1.6), new THREE.MeshStandardMaterial({color:0xff4f4f}));
  roof.position.set(0,1.05,-0.2); car.add(roof);
  // wheels
  const wheelGeo = new THREE.CylinderGeometry(0.35,0.35,0.6,12);
  const wheelMat = new THREE.MeshStandardMaterial({color:0x111111});
  for(let i=0;i<4;i++){
    const w = new THREE.Mesh(wheelGeo, wheelMat); w.rotation.z = Math.PI/2;
    w.position.y = 0.25;
    w.position.x = (i%2===0)?-1:1;
    w.position.z = (i<2)?1.3:-1.3;
    car.add(w);
  }
  car.position.set(0,0,0);
  scene.add(car);

  // small turret/weapon mount (visual)
  const turret = new THREE.Mesh(new THREE.CylinderGeometry(0.07,0.12,0.4,8), new THREE.MeshStandardMaterial({color:0x222222}));
  turret.rotation.x = Math.PI/2; turret.position.set(0,1.55,-1.0);
  car.add(turret);

  // enemy bot (single simple opponent) - optional for demo
  const bot = car.clone();
  bot.children.forEach((c,i)=>{ if(c.material) c.material = c.material.clone(); });
  bot.children[0].material.color.setHex(0x2eaaff);
  bot.position.set(10,0,-6); scene.add(bot);

  // physics-like state
  const state = {forward:0, turn:0, speed:0, maxSpeed:1.2, rotSpeed:0.05, health:100};

  // bullets
  const bullets = [];

  function spawnBullet(origin, dir){
    const g = new THREE.SphereGeometry(0.12,8,8);
    const m = new THREE.MeshStandardMaterial({emissive:0xffb86b, color:0x222222});
    const b = new THREE.Mesh(g,m);
    b.position.copy(origin); b.userData.dir = dir.clone(); b.userData.speed = 3.2;
    scene.add(b); bullets.push(b);
  }

  // Minimap canvas
  const mmCanvas = document.createElement('canvas'); mmCanvas.width = mmCanvas.height = 256;
  minimapEl.innerHTML = ''; minimapEl.appendChild(mmCanvas);
  const mmCtx = mmCanvas.getContext('2d');

  function updateMinimap(){
    const scale = 1.6; // tuning
    mmCtx.clearRect(0,0,256,256);
    mmCtx.fillStyle = '#07101a'; mmCtx.fillRect(0,0,256,256);
    // draw props (approx)
    mmCtx.strokeStyle = '#8fbfde'; mmCtx.lineWidth = 2;
    mmCtx.beginPath();
    // arena bounds
    mmCtx.rect(18,18,220,220);
    mmCtx.stroke();
    // draw player
    const px = 128 + car.position.x*scale, py = 128 + car.position.z*scale;
    mmCtx.fillStyle = '#ff6666'; mmCtx.beginPath(); mmCtx.arc(px,py,5,0,Math.PI*2); mmCtx.fill();
  }

  // Camera follow function (third person chase)
  function updateCamera(){
    const desired = car.position.clone().add(new THREE.Vector3(0,4,10).applyQuaternion(car.quaternion));
    camera.position.lerp(desired, 0.12);
    camera.lookAt(car.position.clone().add(new THREE.Vector3(0,1.2,0)));
  }

  // Joystick handling
  const joy = document.getElementById('joy'), stickEl = document.getElementById('stick');
  let touchId = null, baseX=0, baseY=0;
  let stick = {x:0,y:0};
  function resetStick(){ stick={x:0,y:0}; stickEl.style.transform = `translate(0px,0px)`; }

  joy.addEventListener('touchstart', e=>{ e.preventDefault(); const t=e.changedTouches[0]; touchId=t.identifier; baseX=t.clientX; baseY=t.clientY; }, {passive:false});
  joy.addEventListener('touchmove', e=>{ e.preventDefault(); for(const t of e.changedTouches){ if(t.identifier===touchId){ const dx = t.clientX-baseX, dy = t.clientY-baseY; const max=36; const nx = Math.max(-1, Math.min(1, dx/max)); const ny = Math.max(-1, Math.min(1, dy/max)); stick.x=nx; stick.y=-ny; stickEl.style.transform = `translate(${nx*28}px,${-ny*28}px)`; } } }, {passive:false});
  joy.addEventListener('touchend', e=>{ for(const t of e.changedTouches){ if(t.identifier===touchId){ touchId=null; resetStick(); } } }, {passive:false});
  // pointer events for desktop
  let md=false;
  joy.addEventListener('pointerdown', e=>{ md=true; baseX=e.clientX; baseY=e.clientY; joy.setPointerCapture(e.pointerId); });
  joy.addEventListener('pointermove', e=>{ if(!md) return; const dx=e.clientX-baseX, dy=e.clientY-baseY; const max=36; const nx=Math.max(-1,Math.min(1,dx/max)); const ny=Math.max(-1,Math.min(1,dy/max)); stick.x=nx; stick.y=-ny; stickEl.style.transform=`translate(${nx*28}px,${-ny*28}px)`; });
  joy.addEventListener('pointerup', e=>{ md=false; resetStick(); });

  // Fire button
  const fireBtn = document.getElementById('fire');
  fireBtn.addEventListener('touchstart', e=>{ e.preventDefault(); doFire(); }, {passive:false});
  fireBtn.addEventListener('mousedown', ()=> doFire());

  function doFire(){
    // spawn bullet slightly above hood and in car forward direction
    const dir = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion).normalize();
    const origin = car.position.clone().add(new THREE.Vector3(0,1,-2).applyQuaternion(car.quaternion));
    spawnBullet(origin, dir);
  }

  // Satellite texture toggle
  const ESRI_TILE = 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}';
  let satTex = null, satOn = false;
  async function loadSatellite(){
    try{
      const z=15; // choose z
      // compute tile for center  (we use arbitrary coords since this is demo)
      const centerLat = 19.605; const centerLon = -99.000; // placeholder
      function lon2tile(lon,z){ return Math.floor((lon+180)/360*Math.pow(2,z)); }
      function lat2tile(lat,z){ return Math.floor((1-Math.log(Math.tan(lat*Math.PI/180)+1/Math.cos(lat*Math.PI/180))/Math.PI)/2 * Math.pow(2,z)); }
      const tx = lon2tile(centerLon,z), ty = lat2tile(centerLat,z);
      const url = ESRI_TILE.replace('{z}',z).replace('{x}',tx).replace('{y}',ty);
      const img = await new Promise((res,rej)=>{ const i=new Image(); i.crossOrigin='anonymous'; i.onload=()=>res(i); i.onerror=rej; i.src=url; });
      satTex = new THREE.CanvasTexture(img);
      satTex.encoding = THREE.sRGBEncoding;
      return true;
    }catch(e){ console.warn('sat load failed', e); return false; }
  }
  function toggleSatellite(on){
    if(on && satTex){
      ground.material.dispose();
      ground.material = new THREE.MeshBasicMaterial({map: satTex});
      btnSat.textContent = 'SatÃ©lite: ON';
      satOn = true;
    } else {
      ground.material.dispose();
      ground.material = groundMatDefault;
      btnSat.textContent = 'SatÃ©lite: OFF';
      satOn = false;
    }
  }
  btnSat.addEventListener('click', async ()=>{
    if(!satTex){ btnSat.textContent = 'SatÃ©lite: Cargando...'; await loadSatellite(); }
    toggleSatellite(!satOn);
  });

  // reset center
  btnReset.addEventListener('click', ()=>{
    car.position.set(0,0,0); car.rotation.set(0,0,0); camera.position.set(0,6,10);
  });
  brandBtn.addEventListener('click', ()=>{
    viewerImg.src = 'https://picsum.photos/900/520?random=' + Math.floor(Math.random()*9999);
    viewer.style.display = 'flex'; viewer.setAttribute('aria-hidden','false');
  });
  closeViewer.addEventListener('click', ()=> { viewer.style.display = 'none'; viewer.setAttribute('aria-hidden','true'); });

  // simple collision with walls - keep car inside arena
  function keepInBounds(obj){
    const limit = arenaSize/2 - 1.2;
    if(obj.position.x > limit) obj.position.x = limit;
    if(obj.position.x < -limit) obj.position.x = -limit;
    if(obj.position.z > limit) obj.position.z = limit;
    if(obj.position.z < -limit) obj.position.z = -limit;
  }

  // small damage visuals: smoke sprite using simple particle (plane)
  const particleGroup = new THREE.Group(); scene.add(particleGroup);
  function spawnSmoke(pos){
    const g = new THREE.PlaneGeometry(0.8,0.8);
    const mat = new THREE.MeshBasicMaterial({color:0x222222, transparent:true, opacity:0.55, depthWrite:false});
    const p = new THREE.Mesh(g, mat);
    p.position.copy(pos).position.y += 1.1;
    p.lookAt(camera.position);
    particleGroup.add(p);
    setTimeout(()=> particleGroup.remove(p), 900);
  }

  // render loop
  let lastTime = performance.now();
  let frames = 0, fpsLast = performance.now();
  function animate(){
    const now = performance.now();
    const dt = Math.min(50, now - lastTime) / 16.666;
    lastTime = now;

    // update state from stick
    state.forward = Math.max(-1, Math.min(1, stick.y));
    state.turn = Math.max(-1, Math.min(1, stick.x));

    // speed physics
    if(state.forward > 0.05) state.speed += 0.02 * state.forward * dt;
    else if(state.forward < -0.05) state.speed -= 0.03 * (-state.forward) * dt;
    else state.speed *= 0.96;
    state.speed = Math.max(-state.maxSpeed, Math.min(state.maxSpeed, state.speed));

    // rotation + movement
    car.rotation.y += -state.turn * state.rotSpeed * (0.9 + Math.abs(state.speed)) * dt;
    const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion);
    car.position.add(fwd.multiplyScalar(state.speed * dt * 0.9));
    // keep in arena
    keepInBounds(car);

    // update bullets
    for(let i=bullets.length-1;i>=0;i--){
      const b = bullets[i];
      b.position.add(b.userData.dir.clone().multiplyScalar(b.userData.speed * dt));
      // hit bot demo
      if(b.position.distanceTo(bot.position) < 1.2){
        // spawn hit effect
        const hit = new THREE.Mesh(new THREE.SphereGeometry(0.25,6,6), new THREE.MeshStandardMaterial({emissive:0xff5522, color:0x111111}));
        hit.position.copy(bot.position);
        scene.add(hit); setTimeout(()=> scene.remove(hit), 500);
        scene.remove(b); bullets.splice(i,1);
        continue;
      }
      if(b.position.length() > 2000){ scene.remove(b); bullets.splice(i,1); }
    }

    // soft damage when colliding with props (simple)
    // (not heavy collision detection; we keep minimal)
    // if speed > threshold and hits wall, reduce health and spawn smoke
    // detect near wall (approx)
    const limit = arenaSize/2 - 1.2;
    const spd = Math.abs(state.speed);
    if(Math.abs(car.position.x) >= limit-0.01 || Math.abs(car.position.z) >= limit-0.01){
      if(spd > 0.3){
        state.health = Math.max(0, state.health - spd * 2.2);
        spawnSmoke(car.position.clone());
      }
    }

    // update HUD
    const healthPct = Math.max(0, Math.round(state.health));
    healthEl.textContent = `Salud: ${healthPct}%`;
    if(healthPct <= 40 && Math.random() < 0.008) spawnSmoke(car.position.clone());

    // bot simple AI: circle & follow a bit
    bot.position.x = Math.cos(now*0.0005)*10;
    bot.position.z = Math.sin(now*0.0006)*10;
    bot.lookAt(car.position);

    updateCamera();
    updateMinimap(); renderer.render(scene, camera);

    // fps
    frames++; if(now - fpsLast >= 500){ const fps = Math.round((frames*1000)/(now-fpsLast)); fpsEl.textContent = `FPS: ${fps}`; fpsLast = now; frames=0; }

    requestAnimationFrame(animate);
  }

  // finalize load
  loader.style.display = 'none';
  // center car on scene
  car.position.set(0,0,0);
  camera.position.set(0,6,10);

  // start loop
  requestAnimationFrame(animate);

  // keyboard shortcuts for desktop debugging
  window.addEventListener('keydown', e=>{
    if(e.key === 'w') stick.y = 1;
    if(e.key === 's') stick.y = -1;
    if(e.key === 'a') stick.x = -1;
    if(e.key === 'd') stick.x = 1;
    if(e.key === ' ') doFire();
  });
  window.addEventListener('keyup', e=>{
    if(['w','s'].includes(e.key)) stick.y = 0;
    if(['a','d'].includes(e.key)) stick.x = 0;
  });

  // resize
  window.addEventListener('resize', ()=>{ renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); });

  // Small UX: tap anywhere (except UI) to give small boost (for mobile testers)
  renderer.domElement.addEventListener('touchstart', e=>{
    // if user touches UI elements avoid interference (basic)
    // small quick tap forward
    if(e.touches.length===1){
      // if tapped on left half -> joystick area handled separately
      // no conflict here, we keep default
    }
  }, {passive:true});

  // Expose some debug toggles via console if needed
  window.__arena = {scene, car, bot, bullets};

})(); // end IIFE
</script>
</body>
</html>
