<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Metal Streets: Battle Arena (Estilo Neón)</title>
<style>
  /* Base Style - ESTILO AAA ESTILIZADO */
  :root{
    --bg:#020306;
    --red:#e74c3c;
    --blue:#3498db;
    --green:#2ecc71;
    --shadow:rgba(0,0,0,0.8);
    --text-color:#ecf0f1;
    --panel-bg:rgba(20,20,30,0.7);
    --panel-border:rgba(255,255,255,0.15);
  }
  html,body{height:100%;margin:0;background:linear-gradient(#020306,#050a1a);font-family:'Montserrat', sans-serif;color:var(--text-color);overflow:hidden}
  #holder{width:100%;height:100%;position:relative;touch-action:none}
  
  @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700;800&display=swap');

  /* HUD - Estilo de consola de juego */
  .hud{position:fixed;top:10px;left:10px;right:10px;display:flex;justify-content:space-between;z-index:120;font-size:13px;pointer-events:none;text-shadow:0 0 5px var(--shadow)}
  .panel{background:var(--panel-bg);padding:8px 14px;border-radius:8px;font-weight:600;border:1px solid var(--panel-border);pointer-events:auto;box-shadow:0 4px 15px var(--shadow);backdrop-filter:blur(3px)}
  .panel h2{font-size:16px;margin:0 0 5px 0;color:#fff}

  /* Health and Ammo Bars */
  .bar-container{width:130px;height:14px;background:#1a1a2e;border-radius:3px;overflow:hidden;margin-top:5px;border:1px solid rgba(255,255,255,0.2)}
  .health-bar{height:100%;width:100%;background:linear-gradient(90deg, #e74c3c, #c0392b);transition:width 0.2s}
  .ammo-bar{height:100%;width:100%;background:linear-gradient(90deg, #2ecc71, #27ae60);transition:width 0.2s}
  
  /* Velocímetro */
  .speedometer{
    position:fixed;right:10px; bottom:120px; width:120px;height:120px; background:var(--panel-bg); border-radius:50%; border:1px solid var(--panel-border); box-shadow:0 4px 15px var(--shadow); display:flex;flex-direction:column;align-items:center;justify-content:center; pointer-events:none; z-index:115; backdrop-filter:blur(3px);
  }
  .speed-value{font-size:36px;font-weight:800;color:#fff;text-shadow:0 0 8px rgba(255,255,255,0.4)}
  .speed-unit{font-size:12px;color:var(--text-color)}
  
  /* Controles */
  .joy { position:fixed; left:12px; bottom:12px; width:100px; height:100px; border-radius:50px; background:var(--shadow); display:flex; align-items:center; justify-content:center; pointer-events:auto; z-index:100; border:2px solid rgba(255,255,255,0.1) }
  .stick { width:40px; height:40px; border-radius:50%; background:rgba(255,255,255,0.15); transform:translate(0,0) }
  .fire { position:fixed; right:120px; bottom:20px; width:70px; height:70px; border-radius:50%; background:linear-gradient(135deg,var(--red),#ff0000); display:flex;align-items:center;justify-content:center;z-index:110;pointer-events:auto;box-shadow:0 0 15px var(--red); font-size:30px; border:3px solid #fff; transition:transform 0.1s }
  .fire.cooldown { background:linear-gradient(135deg, #333, #555); box-shadow:none; transform: scale(0.9); pointer-events: none; }
  .turbo { position:fixed; right:12px; bottom:12px; width:90px; height:90px; border-radius:50%; background:linear-gradient(135deg,var(--blue),#00f); display:flex;align-items:center;justify-content:center;z-index:110;pointer-events:auto;box-shadow:0 0 10px var(--blue); font-size:20px; border:3px solid #fff; }
  
  /* FPS/Loader */
  .fps{position:fixed;left:12px;bottom:120px;background:var(--panel-bg);padding:4px 8px;border-radius:4px;font-weight:600;z-index:110;font-size:12px;backdrop-filter:blur(3px)}
  #loading{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:130;background:var(--shadow);padding:14px 18px;border-radius:12px;font-weight:600}

  @media (max-width:420px){ 
    .joy{width:90px;height:90px;left:8px;bottom:8px;} 
    .fire{right:95px;bottom:12px;width:60px;height:60px;font-size:24px}
    .turbo{right:8px;bottom:8px;width:70px;height:70px;font-size:16px}
    .fps{left:8px;bottom:100px;} 
    .speedometer{width:100px;height:100px;right:8px;bottom:100px;}
    .speed-value{font-size:30px}
  }
</style>
</head>
<body>
  <div id="holder"></div>

  <div class="hud">
    <div class="panel">
      <h2>VEHÍCULO: <span id="carType">Sport</span></h2>
      Salud:
      <div class="bar-container"><div id="healthBar" class="health-bar"></div></div>
    </div>

    <div class="panel">
      <h2>ARENA DE COMBATE</h2>
      Munición: <span id="ammoCount">10</span>
      <div class="bar-container"><div id="ammoBar" class="ammo-bar"></div></div>
    </div>
  </div>
  
  <div class="speedometer">
    <div class="speed-value" id="speedDisplay">0</div>
    <div class="speed-unit">KM/H</div>
  </div>

  <div id="loading">Cargando Metal Streets Arena...</div>

  <div class="joy" id="joy"><div class="stick" id="stick"></div></div>
  <div class="fire" id="fire">💥</div>
  <div class="turbo" id="turbo">🚀</div>
  <div class="fps" id="fps">FPS: --</div>

<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/shaders/CopyShader.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

<script>
// Función para verificar si el EffectComposer se cargó
function hasBloomSupport() {
    return typeof EffectComposer !== 'undefined';
}

(async function(){
  // ---------- CONFIGURACIÓN GENERAL ----------
  const holder = document.getElementById('holder');
  const ARENA_SIZE = 100;
  const START_POS = new THREE.Vector3(0, 0, 0); 
  const BULLET_COOLDOWN_MS = 400; 
  const AI_CARS = [];
  const POWER_UPS = [];

  // Definiciones de vehículos 
  const VEHICLE_STATS = {
      'Muscle Car': { color: 0xff5555, width: 2.8, length: 5.0, health: 100, maxSpeed: 1.2, rotSpeed: 0.040, maxAmmo: 15 },
      'Sport': { color: 0x5555ff, width: 2.2, length: 4.0, health: 80, maxSpeed: 1.4, rotSpeed: 0.055, maxAmmo: 10 },
      'Pickup': { color: 0x55ff55, width: 3.2, length: 5.5, health: 150, maxSpeed: 0.9, rotSpeed: 0.030, maxAmmo: 20 }
  };
  let CURRENT_CAR_TYPE = 'Sport'; 
  const BLOOM_ENABLED = hasBloomSupport(); 
  if(!BLOOM_ENABLED) console.warn("BLOOM DISABLED: UnrealBloomPass no cargó. Renderizando sin efecto Neón. Asegúrate de que los enlaces Three.js no estén bloqueados.");


  // ---------- THREEJS SETUP CON FALLBACK DE BLOOM ----------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x020306); 
  scene.fog = new THREE.Fog(scene.background, 10, 150); 
  
  const renderer = new THREE.WebGLRenderer({antialias:true, alpha:false});
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = false; 
  holder.appendChild(renderer.domElement);
  
  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 5000);
  camera.position.set(0, 12, 24);

  let composer = null;
  if(BLOOM_ENABLED){
      // INICIALIZACIÓN DEL BLOOM
      composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.0, 0.4, 0.85); 
      bloomPass.renderToScreen = true;
      composer.addPass(bloomPass);
  }

  // Lights (Ambiente Nocturno)
  scene.add(new THREE.DirectionalLight(0xffffff, 0.2)); 
  scene.add(new THREE.AmbientLight(0xffffff, 0.05)); 

  // Luces de neón/ambientales para el estilo urbano - AUMENTADAS
  const neonLight = new THREE.PointLight(0x00ffff, 3.5, 60); neonLight.position.set(40, 5, 40); scene.add(neonLight);
  const neonLight2 = new THREE.PointLight(0xff00ff, 3.5, 60); neonLight2.position.set(-40, 5, -40); scene.add(neonLight2);


  // ---------- ARENA DE COMBATE ESTILIZADA ----------
  
  // Suelo (Asfalto Brillante/Metálico)
  const groundMat = new THREE.MeshStandardMaterial({color:0x101015, roughness:0.7, metalness:0.4}); // Más oscuro y metálico
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(ARENA_SIZE * 2, ARENA_SIZE * 2, 1, 1), groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.position.y = 0;
  scene.add(ground);
  
  // Edificios/Obstáculos (Estilo Low-Poly)
  const wallHeight = 15; 
  const buildingMat = new THREE.MeshStandardMaterial({color:0x12121e, roughness:0.8, metalness:0.1}); // Aún más oscuros
  
  const windowColor = 0x00ffcc; // Un cian/verde eléctrico
  // Usamos BasicMaterial con Emissive si BLOOM está activado, si no, solo Basic
  const windowMat = BLOOM_ENABLED 
      ? new THREE.MeshBasicMaterial({color:windowColor, emissive:windowColor, emissiveIntensity:2.0}) // Emisión más alta
      : new THREE.MeshBasicMaterial({color:windowColor}); 

  function createBuilding(x, z, w, d, h = wallHeight){
      const group = new THREE.Group();
      const bodyGeo = new THREE.BoxGeometry(w, h, d);
      const body = new THREE.Mesh(bodyGeo, buildingMat);
      body.position.set(x, h/2, z);
      group.add(body);
      
      // Simular algunas ventanas brillantes
      for(let i=0; i<3; i++){
          const windowGeo = new THREE.BoxGeometry(w*0.1, h*0.1, 0.05);
          const windowMesh = new THREE.Mesh(windowGeo, windowMat);
          windowMesh.position.set(x + Math.random()*w*0.5 - w*0.25, h*0.5 + Math.random()*h*0.4 - h*0.2, z + d/2 + 0.05);
          group.add(windowMesh);
      }
      scene.add(group);
      return body; 
  }
  
  // Bordes del mapa (Arena)
  createBuilding(0, ARENA_SIZE - 2, ARENA_SIZE * 2, 5, 20); // Norte
  createBuilding(0, -ARENA_SIZE + 2, ARENA_SIZE * 2, 5, 20); // Sur
  createBuilding(ARENA_SIZE - 2, 0, 5, ARENA_SIZE * 2, 20); // Este
  createBuilding(-ARENA_SIZE + 2, 0, 5, ARENA_SIZE * 2, 20); // Oeste
  
  // Obstáculos/Bloques de Combate
  createBuilding(ARENA_SIZE / 2, ARENA_SIZE / 2, 10, 10, 10);
  createBuilding(-ARENA_SIZE / 2, ARENA_SIZE / 2, 10, 10, 10);


  // ---------- VEHÍCULOS Y LÓGICA DE JUEGO ----------
  
  function createCar(type, isAI = false){
    const stats = VEHICLE_STATS[type];
    const carGroup = new THREE.Group();
    
    // Cuerpo del vehículo (Low-Poly con materiales metálicos)
    const bodyGeo = new THREE.BoxGeometry(stats.width, 0.7, stats.length);
    const bodyMat = new THREE.MeshStandardMaterial({color:stats.color, metalness:0.9, roughness:0.15}); 
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0.7; 
    carGroup.add(body);
    
    // Alerón trasero 
    if (type !== 'Pickup' && !isAI) { 
        const spoilerGeo = new THREE.BoxGeometry(stats.width * 0.8, 0.2, 0.8);
        const spoilerMat = new THREE.MeshStandardMaterial({color: 0x222222, metalness:0.8, roughness:0.2});
        const spoiler = new THREE.Mesh(spoilerGeo, spoilerMat);
        spoiler.position.set(0, 1.3, -stats.length / 2 + 0.5);
        carGroup.add(spoiler);
    }
    
    // Luces Traseras (Emissivas si BLOOM está activo)
    const tailLightMat = BLOOM_ENABLED 
        ? new THREE.MeshBasicMaterial({color:0xff0000, emissive:0xff0000, emissiveIntensity:1.5})
        : new THREE.MeshBasicMaterial({color:0xff0000});
        
    const tailLightGeo = new THREE.BoxGeometry(stats.width * 0.7, 0.3, 0.1);
    const tailLights = new THREE.Mesh(tailLightGeo, tailLightMat);
    tailLights.position.set(0, 0.8, stats.length/2 - 0.05); 
    carGroup.add(tailLights);

    // Lógica interna del vehículo
    carGroup.userData.isAI = isAI;
    carGroup.userData.type = type;
    carGroup.userData.maxHealth = stats.health;
    carGroup.userData.health = stats.health;
    carGroup.userData.maxAmmo = stats.maxAmmo;
    carGroup.userData.ammo = stats.maxAmmo;
    carGroup.userData.maxSpeed = stats.maxSpeed;
    carGroup.userData.rotSpeed = stats.rotSpeed;
    
    // Barra de salud visible (IA)
    if(isAI){
        const hbMat = new THREE.MeshBasicMaterial({color:0x00ff00});
        const hbGeo = new THREE.BoxGeometry(stats.width * 0.8, 0.2, 0.1);
        const healthBar = new THREE.Mesh(hbGeo, hbMat);
        healthBar.position.y = 2.5;
        healthBar.rotation.y = Math.PI/2;
        carGroup.userData.healthBar = healthBar;
        carGroup.add(healthBar);
    }
    
    // HEADLIGHTS (Player)
    if (!isAI) {
        const headlightL = new THREE.SpotLight(0xffffff, 80, 50, Math.PI/6, 0.5, 0.5); 
        headlightL.position.set(stats.width/2 - 0.2, 0.8, -stats.length/2 + 0.5);
        headlightL.target.position.set(stats.width/2 - 0.2, 0.8, -100);
        carGroup.add(headlightL); carGroup.add(headlightL.target);
        
        const headlightR = new THREE.SpotLight(0xffffff, 80, 50, Math.PI/6, 0.5, 0.5); 
        headlightR.position.set(-stats.width/2 + 0.2, 0.8, -stats.length/2 + 0.5);
        headlightR.target.position.set(-stats.width/2 + 0.2, 0.8, -100);
        carGroup.add(headlightR); carGroup.add(headlightR.target);

        // Efecto de neón/turbo en la parte trasera
        const neon = new THREE.PointLight(0xff00ff, BLOOM_ENABLED ? 6 : 4, 5); // Intensidad más alta
        neon.position.set(0, 0.5, stats.length/2 + 0.5);
        carGroup.userData.neonLight = neon;
        carGroup.add(neon);
    }

    return carGroup;
  }

  // Player car
  const car = createCar(CURRENT_CAR_TYPE, false);
  car.position.copy(START_POS);
  scene.add(car);

  // IA Cars (2 enemigos)
  const ai1 = createCar('Muscle Car', true);
  ai1.position.set(30, 0, 0);
  scene.add(ai1); AI_CARS.push(ai1);

  const ai2 = createCar('Pickup', true);
  ai2.position.set(-30, 0, 0);
  scene.add(ai2); AI_CARS.push(ai2);


  // Estado del jugador
  const state = {forward:0, turn:0, speed:0, turbo:false, health: car.userData.health, ammo: car.userData.ammo || VEHICLE_STATS[CURRENT_CAR_TYPE].maxAmmo};
  
  // ---------- SISTEMA DE ARMAS Y POWER-UPS ----------
  
  // Object Pooling para balas (con un material brillante para el Bloom)
  const bulletPool = [];
  const maxBullets = 20;
  
  function getBullet(){
      for(const b of bulletPool){
          if(!b.visible){
              b.visible = true;
              return b;
          }
      }
      if(bulletPool.length < maxBullets){
          const g = new THREE.SphereGeometry(0.2,8,8); 
          const bulletColor = 0xffa500; // Naranja brillante
          // Material de bala brillante si hay Bloom
          const m = BLOOM_ENABLED
            ? new THREE.MeshStandardMaterial({emissive:bulletColor, emissiveIntensity:4, color:0x222222}) // Emisión más alta
            : new THREE.MeshBasicMaterial({color:bulletColor}); 
          const b = new THREE.Mesh(g,m);
          b.userData.dir = new THREE.Vector3();
          b.userData.speed = 4.0;
          b.userData.damage = 10;
          b.userData.isBullet = true;
          b.visible = false;
          scene.add(b);
          bulletPool.push(b);
          return b;
      }
      return null;
  }
  
  function releaseBullet(b){
      b.visible = false;
      b.position.set(0, -100, 0); 
  }
  
  // Generación de Power-Ups 
  function createPowerUp(type, position){
      let color, scale;
      if(type === 'Ammo'){ color = 0x00ff00; scale = 0.8; }
      else if(type === 'Health'){ color = 0xffa500; scale = 1.0; }
      
      const g = new THREE.BoxGeometry(scale, scale, scale);
      // Power-Ups Emissivos si hay Bloom
      const m = BLOOM_ENABLED
        ? new THREE.MeshStandardMaterial({color:color, emissive:color, emissiveIntensity:2.0}) 
        : new THREE.MeshBasicMaterial({color:color}); 
        
      const pu = new THREE.Mesh(g, m);
      pu.position.copy(position);
      pu.position.y = scale / 2 + 0.1;
      pu.userData.type = type;
      pu.userData.active = true;
      scene.add(pu);
      POWER_UPS.push(pu);
  }
  
  // Inicializar Power-Ups
  createPowerUp('Ammo', new THREE.Vector3(20, 0, 20));
  createPowerUp('Health', new THREE.Vector3(-20, 0, -20));
  
  // ---------- LÓGICA DE JUEGO PRINCIPAL (No modificada) ----------
  
  function applyDamage(target, amount){
      if(target.userData.health <= 0) return;
      target.userData.health = Math.max(0, target.userData.health - amount);
      
      target.children[0].material.color.setHex(0xaaaaaa); 
      setTimeout(() => {
          if(target.userData.health > 0){
             target.children[0].material.color.setHex(VEHICLE_STATS[target.userData.type].color);
          }
      }, 50);

      if(target.userData.health <= 0){
          const explosionLight = new THREE.PointLight(0xff8800, 5, 20);
          explosionLight.position.copy(target.position);
          scene.add(explosionLight);
          
          setTimeout(()=>{
              scene.remove(explosionLight); 
              target.position.set(Math.random() * 50 - 25, 0, Math.random() * 50 - 25);
              target.rotation.y = Math.random() * Math.PI * 2;
              target.userData.health = target.userData.maxHealth;
              target.children[0].material.color.setHex(VEHICLE_STATS[target.userData.type].color);
          }, 500);
      }
  }

  function checkCollisions(dt){
      for(let i=bulletPool.length-1;i>=0;i--){
          const bullet = bulletPool[i];
          if(!bullet.visible) continue;
          let hit = false;
          
          const targets = [car, ...AI_CARS];
          for(const target of targets){
              if(target.position.distanceTo(bullet.position) < 3.0 && target.userData.health > 0){ 
                  applyDamage(target, bullet.userData.damage);
                  hit = true;
                  break;
              }
          }

          if(hit || bullet.position.length() > ARENA_SIZE * 2){ 
              releaseBullet(bullet);
          } else {
              bullet.position.add(bullet.userData.dir.clone().multiplyScalar(bullet.userData.speed * dt));
          }
      }
      
      for(let i=POWER_UPS.length-1;i>=0;i--){
          const pu = POWER_UPS[i];
          if(!pu.userData.active) continue;
          
          if(car.position.distanceTo(pu.position) < 2.0){ 
              pu.userData.active = false;
              pu.visible = false;
              
              if(pu.userData.type === 'Ammo'){
                  state.ammo = Math.min(car.userData.maxAmmo, state.ammo + 5);
                  car.userData.ammo = state.ammo;
              } else if(pu.userData.type === 'Health'){
                  state.health = Math.min(car.userData.maxHealth, state.health + 20);
                  car.userData.health = state.health;
              }
              
              setTimeout(() => {
                  pu.position.set(Math.random() * 80 - 40, 0, Math.random() * 80 - 40);
                  pu.userData.active = true;
                  pu.visible = true;
              }, 5000);
          }
      }
      
      if(car.position.x > ARENA_SIZE - 2 || car.position.x < -ARENA_SIZE + 2){
          car.position.x = Math.min(ARENA_SIZE - 2, Math.max(-ARENA_SIZE + 2, car.position.x));
          state.speed *= -0.5; 
          applyDamage(car, 5);
      }
      if(car.position.z > ARENA_SIZE - 2 || car.position.z < -ARENA_SIZE + 2){
          car.position.z = Math.min(ARENA_SIZE - 2, Math.max(-ARENA_SIZE + 2, car.position.z));
          state.speed *= -0.5; 
          applyDamage(car, 5);
      }
      state.health = car.userData.health; 
  }
  
  // Camera Follow
  function updateCamera(){
    const desired = car.position.clone().add(new THREE.Vector3(0,4,12).applyQuaternion(car.quaternion)); 
    camera.position.lerp(desired, 0.15);
    camera.lookAt(car.position.clone().add(new THREE.Vector3(0,1.2,0)));
  }

  // Actualización del HUD
  function updateHUD(){
      document.getElementById('healthBar').style.width = (state.health / car.userData.maxHealth * 100) + '%';
      document.getElementById('ammoBar').style.width = (state.ammo / car.userData.maxAmmo * 100) + '%';
      document.getElementById('ammoCount').textContent = state.ammo;
      document.getElementById('carType').textContent = CURRENT_CAR_TYPE;
      
      const kmh = Math.round(Math.abs(state.speed) / car.userData.maxSpeed * 200);
      document.getElementById('speedDisplay').textContent = kmh;
  }

  // ---------- INPUTS Y CONTROLES (No modificados) ----------
  const joy = document.getElementById('joy'), stickEl = document.getElementById('stick');
  let touchId = null, baseX=0, baseY=0;
  let stick = {x:0,y:0};
  function resetStick(){ stick={x:0,y:0}; stickEl.style.transform = `translate(0px,0px)`; }
  joy.addEventListener('touchstart', e=>{ e.preventDefault(); const t = e.changedTouches[0]; touchId = t.identifier; baseX=t.clientX; baseY=t.clientY; }, {passive:false});
  joy.addEventListener('touchmove', e=>{ e.preventDefault(); for(const t of e.changedTouches){ if(t.identifier===touchId){ const dx=t.clientX-baseX, dy=t.clientY-baseY; const max=36; const nx=Math.max(-1,Math.min(1,dx/max)); const ny=Math.max(-1,Math.min(1,dy/max)); stick.x = nx; stick.y = -ny; stickEl.style.transform = `translate(${nx*28}px,${-ny*28}px)`; } } }, {passive:false});
  joy.addEventListener('touchend', e=>{ for(const t of e.changedTouches){ if(t.identifier===touchId){ touchId=null; resetStick(); } } }, {passive:false});
  let md=false;
  joy.addEventListener('pointerdown', e=>{ md=true; baseX=e.clientX; baseY=e.clientY; joy.setPointerCapture(e.pointerId); });
  joy.addEventListener('pointermove', e=>{ if(!md) return; const dx=e.clientX-baseX, dy=e.clientY-baseY; const max=36; const nx=Math.max(-1,Math.min(1,dx/max)); const ny=Math.max(-1,Math.min(1,dy/max)); stick.x=nx; stick.y=-ny; stickEl.style.transform=`translate(${nx*28}px,${-ny*28}px)`; });
  joy.addEventListener('pointerup', e=>{ md=false; resetStick(); });

  const fireBtn = document.getElementById('fire');
  fireBtn.addEventListener('touchstart', e=>{ e.preventDefault(); doFire(); }, {passive:false});
  fireBtn.addEventListener('mousedown', doFire);
  
  const turboBtn = document.getElementById('turbo');
  turboBtn.addEventListener('touchstart', e=>{ e.preventDefault(); state.turbo = true; }, {passive:false});
  turboBtn.addEventListener('touchend', e=>{ e.preventDefault(); state.turbo = false; }, {passive:false});
  
  function doFire(){
      const now = performance.now();
      if(now - lastFireTime < BULLET_COOLDOWN_MS || state.ammo <= 0) return;

      lastFireTime = now;
      state.ammo--;
      car.userData.ammo = state.ammo;
      
      fireBtn.classList.add('cooldown');
      setTimeout(() => { fireBtn.classList.remove('cooldown'); }, BULLET_COOLDOWN_MS);

      const dir = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion).normalize();
      const origin = car.position.clone().add(new THREE.Vector3(0,0.7,-3.0).applyQuaternion(car.quaternion));
      spawnBullet(origin, dir); 
  }
  
  function spawnBullet(pos, dir){
    const b = getBullet();
    if(b){
        b.position.copy(pos);
        b.userData.dir.copy(dir);
    }
  }

  // ---------- RENDER LOOP ----------
  let last = performance.now(); let lastFireTime = 0; let frames = 0; let fpsNow = 0;
  function animate(){
    const now = performance.now();
    const dt = Math.min(50, now-last) / 16.666;
    last = now;
    
    if(state.health > 0){
        // Player movement/AI logic (omitted for brevity, same as previous working code)
        state.forward = Math.max(-1, Math.min(1, stick.y));
        state.turn = Math.max(-1, Math.min(1, stick.x));
        let maxSpeed = car.userData.maxSpeed * (state.turbo ? 1.8 : 1.0); 
        if(state.forward > 0.05) state.speed += 0.018 * state.forward * dt;
        else if(state.forward < -0.05) state.speed -= 0.03 * (-state.forward) * dt;
        else state.speed *= 0.96;
        state.speed = Math.max(-maxSpeed * 0.5, Math.min(maxSpeed, state.speed));
        const currentSpeedFactor = Math.abs(state.speed / car.userData.maxSpeed);
        let rotationMultiplier = 1;
        if(currentSpeedFactor > 0.6 && Math.abs(state.turn) > 0.4) rotationMultiplier = 0.5 + 0.5 * (1 - Math.abs(state.turn)); 
        car.rotation.y += -state.turn * car.userData.rotSpeed * (0.9 + currentSpeedFactor) * dt * rotationMultiplier;
        const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion);
        car.position.add(fwd.multiplyScalar(state.speed * dt * 0.82));
        car.userData.neonLight.intensity = state.turbo ? (BLOOM_ENABLED ? 8 : 5) : (BLOOM_ENABLED ? 2 : 1.5);
        
        // IA MOVEMENT (Same as before)
        for(const ai of AI_CARS){
            const targetPos = START_POS;
            const targetDir = targetPos.clone().sub(ai.position).normalize();
            const currentDir = new THREE.Vector3(0,0,-1).applyQuaternion(ai.quaternion).normalize();
            const angle = currentDir.angleTo(targetDir);
            const cross = new THREE.Vector3().crossVectors(currentDir, targetDir);
            let turnAmount = 0;
            if(angle > 0.1){ turnAmount = Math.min(1, angle / Math.PI * 2); if(cross.y < 0) turnAmount *= -1; }
            ai.rotation.y -= turnAmount * 0.03 * dt;
            ai.userData.speed = ai.userData.maxSpeed * 0.8; 
            const aiFwd = new THREE.Vector3(0,0,-1).applyQuaternion(ai.quaternion);
            ai.position.add(aiFwd.multiplyScalar(ai.userData.speed * dt * 0.82));
            if(Math.abs(ai.position.x) > ARENA_SIZE - 2 || Math.abs(ai.position.z) > ARENA_SIZE - 2){
                ai.position.x = Math.min(ARENA_SIZE - 2, Math.max(-ARENA_SIZE + 2, ai.position.x));
                ai.position.z = Math.min(ARENA_SIZE - 2, Math.max(-ARENA_SIZE + 2, ai.position.z));
                ai.userData.speed *= -0.5; 
            }
            ai.userData.healthBar.scale.x = ai.userData.health / ai.userData.maxHealth;
        }

        checkCollisions(dt);
    }
    
    updateCamera();
    updateHUD();
    
    // RENDERIZADO CON O SIN BLOOM
    if(composer){
        composer.render();
    } else {
        renderer.render(scene, camera);
    }
    
    frames++; if(now - fpsLast >= 500){ fpsNow = Math.round((frames*1000)/(now-fpsLast)); frames = 0; fpsLast = now; document.getElementById('fps').textContent = `FPS: ${fpsNow}`; }
    requestAnimationFrame(animate);
  }
  let fpsLast = performance.now();

  // ---------- INITIALIZATION ----------
  document.getElementById('loading').style.display = 'none';
  requestAnimationFrame(animate);

  window.addEventListener('resize', ()=>{ 
    renderer.setSize(window.innerWidth, window.innerHeight); 
    camera.aspect = innerWidth/innerHeight; 
    camera.updateProjectionMatrix(); 
    if(composer) composer.setSize(window.innerWidth, window.innerHeight);
  });

})();
</script>
</body>
</html>
