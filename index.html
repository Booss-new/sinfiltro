(async function(){
  // ... (código anterior sin cambios hasta la sección de CONFIG)
  
  // ---------- CONFIG ----------
  const holder = document.getElementById('holder');
  // Bounding box for Playas Jardines de Morelos, Coacalco (approx. 1.5km x 1.5km area)
  // Format: [south, west, north, east]
  const BBOX = [19.615, -99.04, 19.625, -99.02];
  const OVERPASS_URL = 'https://overpass-api.de/api/interpreter';
  const ESRI_TILE = 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}';

  // NUEVOS PARÁMETROS DE ESCALA Y COLOR
  const SCENE_SCALE = 0.08; // Aumentado a 0.08 (de 0.06) para escalar el mundo ligeramente más.
  const CAR_WIDTH = 2.4;    // Ancho del vehículo, ajusta según el tamaño de las calles.
  const STREET_COLOR = 0x282c35; // Asfalto: Un gris oscuro más neutro/azulado.
  const BUILDING_COLOR_BASE = 0x3d414a; // Edificios: Un gris oscuro más claro para diferenciarlos.
  const BUILDING_COLOR_ACCENT = 0x5a6068; // Para variar los colores de los edificios.

  // ---------- THREEJS basic scene ----------
  // ... (código que define la escena, renderer, cámara y luces)

  // ground plane base
  const groundMat = new THREE.MeshStandardMaterial({color:0x111217, roughness:0.9, metalness:0.1});
  // ... (código que define el mesh 'ground')

  // world transform: lat/lon -> planar meters approx
  // ... (código que define latCenter, lonCenter, EARTH_RADIUS, metersPerDegLat, metersPerDegLon)

  function ll2xy(lat, lon){
    // convert to meters offset from center
    const dx = (lon - lonCenter) * mPerDegLon;
    const dz = (lat - latCenter) * mPerDegLat;
    // scaling down to keep world manageable for mobile (divide by factor)
    // Se usa el nuevo parámetro de escala
    const SCALE = SCENE_SCALE; 
    return new THREE.Vector3(dx * SCALE, 0, -dz * SCALE);
  }

  // Player car (low-poly box)
  const car = new THREE.Group();
  // El ancho del cuerpo del carro se ajusta para mejor proporción
  const body = new THREE.Mesh(new THREE.BoxGeometry(CAR_WIDTH,0.7,4.2), new THREE.MeshStandardMaterial({color:0xff5555}));
  body.position.y = 0.7; car.add(body);
  const wheelGeo = new THREE.CylinderGeometry(0.35,0.35,0.5,8);
  const wheelMat = new THREE.MeshStandardMaterial({color:0x111111});
  for(let i=0;i<4;i++){
    const w = new THREE.Mesh(wheelGeo, wheelMat);
    w.rotation.z = Math.PI/2; w.position.y = 0.25;
    // Las ruedas se ajustan al nuevo ancho del carro
    w.position.x = (i%2===0)?-(CAR_WIDTH/2 - 0.2): (CAR_WIDTH/2 - 0.2);
    w.position.z = (i<2)?1.2:-1.2;
    car.add(w);
  }
  // ... (código que añade el carro a la escena)

  // ... (código para fetchOSM, parseOverpass)

  // Create road geometry by connecting node segments -> thin boxes to approximate road surface
  function buildRoads(nodes, ways){
    // ... (código de filtrado de vías)
    roadsGroup.clear?.(); 
    roadsGroup.children.slice().forEach(c=>roadsGroup.remove(c));

    for(const w of ways){
      // ... (código para obtener puntos)
      
      for(let i=0;i<simplified.length-1;i++){
        const a = simplified[i], b = simplified[i+1];
        const seg = new THREE.Vector3().copy(b).sub(a);
        const len = seg.length();
        const mid = a.clone().add(b).multiplyScalar(0.5);
        // create a thin box
        // ANCHO DE CALLE AJUSTADO: Se aumentó la proporción de las calles
        const width = (w.tags.highway === 'motorway' || w.tags.highway === 'trunk') ? 4.5 : 3.0; 
        const geom = new THREE.BoxGeometry(width, 0.02, Math.max(len,0.1));
        
        // COLOR DE ASFALTO AJUSTADO
        const mat = new THREE.MeshStandardMaterial({color:STREET_COLOR, roughness:0.9}); 
        
        const m = new THREE.Mesh(geom, mat);
        m.position.copy(mid); m.position.y = 0.01;
        // rotate to match segment
        m.lookAt(b); m.rotateX(Math.PI/2); // align geometry plane
        roadsGroup.add(m);
        segmentCount++;
      }
      // ... (código para almacenar polylines)
    }
    return {segmentCount, wayCount};
  }

  // Create simple buildings: extrude vertical boxes from building footprints
  function buildBuildings(nodes, ways){
    buildingsGroup.clear?.(); buildingsGroup.children.slice().forEach(c=>buildingsGroup.remove(c));
    let count = 0;
    for(const w of ways){
      if(!w.tags || !w.tags.building) continue;
      // ... (código para obtener puntos y calcular bounding box)
      const wth = Math.max(1.0, (maxx-minx));
      const lng = Math.max(1.0, (maxz-minz));
      const height = (w.tags['building:levels'] ? Math.max(2, +w.tags['building:levels']) : Math.floor(2 + Math.random()*4)) * 1.8;
      const g = new THREE.BoxGeometry(wth, height, lng);
      
      // COLOR DE EDIFICIOS AJUSTADO (con ligera variación para hacerlos más visibles)
      // Alternar entre dos tonos para evitar que todos los edificios sean idénticos
      const color = count % 2 === 0 ? BUILDING_COLOR_BASE : BUILDING_COLOR_ACCENT;
      const mat = new THREE.MeshStandardMaterial({color:color, roughness:0.9});
      
      const b = new THREE.Mesh(g, mat);
      b.position.set((minx+maxx)/2, height/2, (minz+maxz)/2);
      buildingsGroup.add(b);
      count++;
    }
    return count;
  }
  // ... (el resto del código sigue sin cambios)
})();
</script>
