<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>SinFiltro - Arena Vehicular (Calles nocturno, colisiones suaves)</title>
<style>
  :root{--bg:#05060a;--uiGlass:rgba(255,255,255,0.03);--accent1:#00d1ff;--accent2:#8a6eff}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#071226);color:#eaf7ff;font-family:Inter,system-ui,-apple-system,Arial;overflow:hidden}
  #canvasHolder{width:100%;height:100%;touch-action:none}
  /* UI overlay - keep same layout as approved */
  #overlayUI{position:fixed;inset:0;pointer-events:none;z-index:60}
  .topBar{position:fixed;left:12px;right:12px;top:12px;display:flex;justify-content:space-between;align-items:center;pointer-events:auto;z-index:92}
  .logo{font-weight:700;padding:8px 12px;border-radius:10px;background:var(--uiGlass)}
  .miniBtns{display:flex;gap:8px}
  .icon{padding:8px;border-radius:10px;background:var(--uiGlass);cursor:pointer}
  .joy{ position:fixed; left:18px; bottom:18px; width:110px; height:110px; border-radius:60px; background:rgba(255,255,255,0.03); display:flex; align-items:center; justify-content:center; pointer-events:auto; z-index:90 }
  .stick{ width:48px; height:48px; border-radius:50%; background:rgba(255,255,255,0.07); transform:translate(0,0) }
  .btnFire{ position:fixed; right:20px; bottom:34px; width:72px; height:72px; border-radius:50%; background:linear-gradient(135deg,var(--accent1),var(--accent2)); color:#001; font-weight:700; font-size:28px; display:flex; align-items:center; justify-content:center; pointer-events:auto; z-index:90; box-shadow:0 12px 40px rgba(0,0,0,0.5); cursor:pointer }
  #viewer{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.85);z-index:100}
  #viewer img{max-width:90%;height:auto;border-radius:12px}
  .hint{position:fixed;left:12px;right:12px;bottom:8px;font-size:13px;color:rgba(255,255,255,0.6);z-index:90;pointer-events:none}
  @media(max-width:420px){ .joy{width:96px;height:96px} .stick{width:42px;height:42px} .btnFire{width:64px;height:64px} }
</style>
</head>
<body>
  <div id="canvasHolder"></div>

  <!-- UI -->
  <div id="overlayUI">
    <div class="topBar">
      <div class="logo">SinFiltro - Arena (demo)</div>
      <div class="miniBtns">
        <div class="icon" id="btnMenu">â˜°</div>
        <div class="icon" id="btnStart">â–¶</div>
      </div>
    </div>

    <div class="joy" id="joy">
      <div class="stick" id="stick"></div>
    </div>

    <div class="btnFire" id="btnFire">ðŸ”«</div>

    <div class="hint">Modo demo â€” calles cargadas con colisiones invisibles (suavizadas)</div>
  </div>

  <div id="viewer" role="dialog" aria-hidden="true">
    <div style="text-align:center">
      <img id="viewerImg" src="" alt="preview"><br><br>
      <button id="closeViewer" style="padding:8px 12px;border-radius:8px">Cerrar</button>
    </div>
  </div>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

  <script>
  (function(){
    // BASIC SCENE
    const holder = document.getElementById('canvasHolder');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x05060a, 0.0022);

    const renderer = new THREE.WebGLRenderer({antialias:true, powerPreference:'high-performance'});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.25)); // mobile friendly
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.shadowMap.enabled = false;
    holder.appendChild(renderer.domElement);
    renderer.domElement.style.touchAction = 'none'; // important to allow our UI touches

    // CAMERA
    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
    camera.position.set(0,6,10);

    // LIGHTS (night)
    const dir = new THREE.DirectionalLight(0xffffff, 0.55);
    dir.position.set(5,10,7); scene.add(dir);
    scene.add(new THREE.AmbientLight(0x8aa3b0, 0.22));

    // GROUND
    const groundMat = new THREE.MeshStandardMaterial({color:0x0b0f12, roughness:0.95, metalness:0.05});
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000,1,1), groundMat);
    ground.rotation.x = -Math.PI/2; ground.position.y = 0; scene.add(ground);

    // ROAD SYSTEM: We'll build simplified roads that resemble a neighborhood grid.
    // Each road is an extruded shape (low poly). We'll also generate colliders (invisible boxes) along road edges.
    const roads = [];     // visual meshes
    const colliders = []; // {box:THREE.Box3, mesh(optional)}

    // Example simplified set of centerlines that emulate "calles" layout (you asked Playas JM; this is a stylized approximation)
    // Each polyline = array of {x,z}
    const centerlines = [
      // main horizontal avenue
      [ {x:-60,z:-20}, {x:80,z:-20} ],
      // parallel street
      [ {x:-60,z:10}, {x:80,z:10} ],
      // vertical street cross
      [ {x:-10,z:-120}, {x:-10,z:120} ],
      [ {x:40,z:-120}, {x:40,z:120} ],
      // a small diagonal connector
      [ {x:-60,z:60}, {x:0,z:20}, {x:60,z:60} ]
    ];

    // road width in world units:
    const ROAD_WIDTH = 6;

    function buildRoadFromLine(line){
      // create a simple extruded rectangle around each segment
      const roadGroup = new THREE.Group();
      for(let i=0;i<line.length-1;i++){
        const a = line[i], b = line[i+1];
        const dx = b.x - a.x, dz = b.z - a.z;
        const len = Math.hypot(dx,dz);
        const angle = Math.atan2(dz,dx);
        const geom = new THREE.PlaneGeometry(len, ROAD_WIDTH);
        const mat = new THREE.MeshStandardMaterial({color:0x111214, roughness:0.9, metalness:0.03});
        const m = new THREE.Mesh(geom, mat);
        m.rotation.x = -Math.PI/2;
        m.position.set( (a.x+b.x)/2, 0.01, (a.z+b.z)/2 );
        m.rotation.y = -angle;
        roadGroup.add(m);

        // collider: box slightly taller than ground to detect leaving road
        // We'll create a Box3 for the segment area expanded a bit.
        const halfW = ROAD_WIDTH/2 + 0.2;
        const minX = Math.min(a.x,b.x) - halfW, maxX = Math.max(a.x,b.x) + halfW;
        const minZ = Math.min(a.z,b.z) - halfW, maxZ = Math.max(a.z,b.z) + halfW;
        const box = new THREE.Box3(new THREE.Vector3(minX, -2, minZ), new THREE.Vector3(maxX, 2, maxZ));
        colliders.push(box);
      }
      roads.push(roadGroup);
      scene.add(roadGroup);
    }

    centerlines.forEach(buildRoadFromLine);

    // decorative street stripes / separators (thin darker strips) using narrow planes
    centerlines.forEach(line=>{
      for(let i=0;i<line.length-1;i++){
        const a=line[i], b=line[i+1];
        const dx=b.x-a.x, dz=b.z-a.z; const len=Math.hypot(dx,dz);
        const angle=Math.atan2(dz,dx);
        const stripe = new THREE.Mesh(new THREE.PlaneGeometry(len,0.22), new THREE.MeshStandardMaterial({color:0x0b0f12}));
        stripe.rotation.x = -Math.PI/2; stripe.rotation.y = -angle;
        stripe.position.set((a.x+b.x)/2,0.02,(a.z+b.z)/2);
        scene.add(stripe);
      }
    });

    // Street lamps to help orientation (low poly)
    const lampGeo = new THREE.CylinderGeometry(0.05,0.05,3,6);
    const lampMat = new THREE.MeshStandardMaterial({color:0x0a0a0a});
    const lampBulb = new THREE.SphereGeometry(0.12,8,8);
    const bulbMat = new THREE.MeshStandardMaterial({emissive:0xfff5c0, emissiveIntensity: 0.9, color:0x333333});
    const lampPositions = [];
    // place bulbs along main avenue
    for(let x=-50;x<=70;x+=12){
      lampPositions.push({x:x,z:-20});
      lampPositions.push({x:x,z:10});
    }
    lampPositions.push({x:-10,z:-40},{x:40,z:-40},{x:-10,z:40},{x:40,z:40});
    lampPositions.forEach(p=>{
      const pole = new THREE.Mesh(lampGeo, lampMat); pole.position.set(p.x,1.5,p.z);
      const bulb = new THREE.Mesh(lampBulb, bulbMat); bulb.position.set(p.x,2.8,p.z);
      scene.add(pole); scene.add(bulb);
      // subtle point light
      const pl = new THREE.PointLight(0xfff2d0, 0.12, 12);
      pl.position.set(p.x,2.6,p.z);
      scene.add(pl);
    });

    // PLAYER CAR (low poly) - keep as previously approved
    const car = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.7,4.2), new THREE.MeshStandardMaterial({color:0xff5555, metalness:0.4, roughness:0.6}));
    body.position.y = 0.7; car.add(body);
    const wheelGeo = new THREE.CylinderGeometry(0.35,0.35,0.5,8);
    const wheelMat = new THREE.MeshStandardMaterial({color:0x111111});
    for(let i=0;i<4;i++){ const w = new THREE.Mesh(wheelGeo, wheelMat); w.rotation.z = Math.PI/2; w.position.y = 0.25; w.position.x = (i%2===0)?-1:1; w.position.z = (i<2)?1.2:-1.2; car.add(w); }
    car.position.set(0,0,0); scene.add(car);

    // BOT copy
    const bot = car.clone(); bot.children[0].material = new THREE.MeshStandardMaterial({color:0x55aaff}); bot.position.set(8,0,-6); scene.add(bot);

    // movement state
    const state = {speed:0, forward:0, turn:0, maxSpeed:0.9, rotSpeed:0.045};

    // bullets
    const bullets = [];

    function spawnBullet(origin, dir){
      const g = new THREE.SphereGeometry(0.12,8,8);
      const m = new THREE.MeshStandardMaterial({emissive:0xffcc77, color:0x222222});
      const b = new THREE.Mesh(g,m);
      b.position.copy(origin);
      b.userData.dir = dir.clone();
      b.userData.speed = 2.6;
      scene.add(b); bullets.push(b);
    }

    // Joystick (robust)
    const joy = document.getElementById('joy'), stickEl = document.getElementById('stick');
    let touchId=null, baseX=0, baseY=0, stick={x:0,y:0};
    function resetStick(){ stick={x:0,y:0}; stickEl.style.transform='translate(0px,0px)'; }
    joy.addEventListener('touchstart', e=>{ e.preventDefault(); const t=e.changedTouches[0]; touchId=t.identifier; baseX=t.clientX; baseY=t.clientY; }, {passive:false});
    joy.addEventListener('touchmove', e=>{ e.preventDefault(); for(const t of e.changedTouches){ if(t.identifier===touchId){ const dx=t.clientX-baseX, dy=t.clientY-baseY; const max=36; const nx=Math.max(-1,Math.min(1,dx/max)); const ny=Math.max(-1,Math.min(1,dy/max)); stick.x=nx; stick.y=-ny; stickEl.style.transform=`translate(${nx*28}px,${-ny*28}px)`; } } }, {passive:false});
    joy.addEventListener('touchend', e=>{ for(const t of e.changedTouches){ if(t.identifier===touchId){ touchId=null; resetStick(); } } }, {passive:false});
    // pointer fallback
    let md=false; joy.addEventListener('pointerdown', e=>{ md=true; baseX=e.clientX; baseY=e.clientY; joy.setPointerCapture(e.pointerId); });
    joy.addEventListener('pointermove', e=>{ if(!md) return; const dx=e.clientX-baseX, dy=e.clientY-baseY; const max=36; const nx=Math.max(-1,Math.min(1,dx/max)); const ny=Math.max(-1,Math.min(1,dy/max)); stick.x=nx; stick.y=-ny; stickEl.style.transform=`translate(${nx*28}px,${-ny*28}px)`; });
    joy.addEventListener('pointerup', e=>{ md=false; resetStick(); });

    // fire
    const fireBtn = document.getElementById('btnFire');
    function doFire(){ const dir = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion).normalize(); const origin = car.position.clone().add(new THREE.Vector3(0,1,-2).applyQuaternion(car.quaternion)); spawnBullet(origin, dir); }
    fireBtn.addEventListener('touchstart', e=>{ e.preventDefault(); doFire(); }, {passive:false});
    fireBtn.addEventListener('mousedown', ()=> doFire());

    // Collision detection helper: check if position is inside any collider box.
    // We'll do: if car center is OUTSIDE all road colliders => apply gentle correction toward nearest road centerline
    function isOnRoad(pos){
      for(const b of colliders){ if(b.containsPoint(new THREE.Vector3(pos.x,pos.y,pos.z))) return true; }
      return false;
    }

    // Find nearest point on any centerline (approx) -> used for soft correction / guidance
    function nearestPointOnCenterlines(pos){
      let best = {d:1e9, pt:new THREE.Vector3(), lineIdx:-1};
      for(const line of centerlines){
        for(let i=0;i<line.length-1;i++){
          const a = new THREE.Vector3(line[i].x,0,line[i].z), b = new THREE.Vector3(line[i+1].x,0,line[i+1].z);
          // project pos onto segment ab
          const ab = b.clone().sub(a);
          const t = Math.max(0, Math.min(1, pos.clone().sub(a).dot(ab) / ab.lengthSq()));
          const proj = a.clone().add(ab.multiplyScalar(t));
          const d = proj.distanceTo(pos);
          if(d < best.d){ best = {d, pt:proj, lineIdx:i}; }
        }
      }
      return best;
    }

    // MAIN LOOP
    let lastTime = performance.now();
    function animate(){
      const now = performance.now();
      const dt = Math.min(50, now - lastTime) / 16.666;
      lastTime = now;

      // state from stick
      const forward = Math.max(-1, Math.min(1, stick.y));
      const turn = Math.max(-1, Math.min(1, stick.x));

      // speed update
      if(forward > 0.06) state.speed += 0.02 * forward * dt;
      else if(forward < -0.06) state.speed -= 0.03 * (-forward) * dt;
      else state.speed *= 0.985;

      state.speed = Math.max(-state.maxSpeed, Math.min(state.maxSpeed, state.speed));

      // rotation based on input and speed
      car.rotation.y += -turn * state.rotSpeed * (0.8 + Math.abs(state.speed)) * dt;

      // move forward
      const forwardVec = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion);
      car.position.add(forwardVec.multiplyScalar(state.speed * dt * 0.85));

      // SOFT COLLISION / ROAD BOUNDS:
      // If car is outside any road collider, compute nearest centerline point and gently push toward it
      if(!isOnRoad(car.position)){
        const nearest = nearestPointOnCenterlines(car.position);
        // apply correction vector toward nearest point proportional to distance
        const v = nearest.pt.clone().sub(car.position);
        const dist = v.length();
        if(dist > 0.05){
          // scale correction: small force so it feels like guardrail
          const correctionStrength = Math.min(0.6, 0.02 + 0.03 * Math.sqrt(dist));
          car.position.add(v.normalize().multiplyScalar(correctionStrength * dt));
          // also dampen forward speed so it slows near edge
          state.speed *= 0.92;
        }
      }

      // camera follow smooth
      const desiredCam = car.position.clone().add(new THREE.Vector3(0,4,9).applyQuaternion(car.quaternion));
      camera.position.lerp(desiredCam, 0.12);
      const lookAt = car.position.clone().add(new THREE.Vector3(0,1.5,0));
      camera.lookAt(lookAt);

      // bullets update & simple bot-hit detection
      for(let i=bullets.length-1;i>=0;i--){
        const b = bullets[i];
        b.position.add(b.userData.dir.clone().multiplyScalar(b.userData.speed * dt));
        if(b.position.distanceTo(bot.position) < 1.4){
          scene.remove(b); bullets.splice(i,1);
          const hit = new THREE.Mesh(new THREE.SphereGeometry(0.22,6,6), new THREE.MeshStandardMaterial({emissive:0xff5522, color:0x111111}));
          hit.position.copy(bot.position); scene.add(hit);
          setTimeout(()=>scene.remove(hit),500);
          continue;
        }
        if(b.position.length() > 2000){ scene.remove(b); bullets.splice(i,1); }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    // UI actions
    document.getElementById('btnMenu').addEventListener('click', ()=> { alert('MenÃº demo â€” ajustes, perfil (placeholders)'); });
    document.getElementById('btnStart').addEventListener('click', ()=> { alert('Iniciar partida demo: modos 1v1 / 4v4 (simulaciÃ³n)'); });

    // viewer demo
    const viewer = document.getElementById('viewer'), viewerImg = document.getElementById('viewerImg'), closeViewer = document.getElementById('closeViewer');
    document.querySelector('.logo').addEventListener('click', ()=>{
      viewerImg.src = 'https://picsum.photos/800/420?random=12';
      viewer.style.display='flex'; viewer.setAttribute('aria-hidden','false');
    });
    closeViewer.addEventListener('click', ()=>{ viewer.style.display='none'; viewer.setAttribute('aria-hidden','true'); });

    // window resize
    window.addEventListener('resize', ()=>{ renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); });

    // Debugging: (comment out in production)
    //console.log('Roads:', centerlines.length, 'colliders:', colliders.length);

  })();
  </script>
</body>
</html>
