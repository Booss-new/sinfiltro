<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>SinFiltro - Arena Vehicular (calles con colisiones)</title>
<style>
  html,body{height:100%;margin:0;background:#05060a;color:#eaf7ff;font-family:Inter,system-ui;overflow:hidden;-webkit-font-smoothing:antialiased}
  #canvasHolder{width:100%;height:100%}
  /* joystick */
  .joy { position:fixed; left:18px; bottom:18px; width:110px; height:110px; border-radius:60px; background:rgba(255,255,255,0.03); display:flex; align-items:center; justify-content:center; pointer-events:auto; z-index:30 }
  .stick { width:48px; height:48px; border-radius:50%; background:rgba(255,255,255,0.08); transform:translate(0,0) }
  /* fire button */
  .btnFire { position:fixed; right:20px; bottom:34px; width:72px; height:72px; border-radius:50%; background:linear-gradient(135deg,#00d1ff,#8a6eff); color:#001; font-weight:700; font-size:28px; display:flex; align-items:center; justify-content:center; pointer-events:auto; z-index:30; box-shadow:0 12px 40px rgba(0,0,0,0.5) }
  /* top UI */
  .topBar{position:fixed;left:12px;right:12px;top:12px;display:flex;justify-content:space-between;align-items:center;pointer-events:auto;z-index:40}
  .logo{font-weight:700;padding:8px 12px;border-radius:10px;background:rgba(255,255,255,0.02);cursor:pointer}
  .miniBtns{display:flex;gap:8px}
  .icon{padding:8px;border-radius:10px;background:rgba(255,255,255,0.02);cursor:pointer}
  /* viewer overlay */
  #viewer{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.85);z-index:50}
  #viewer img{max-width:90%;height:auto;border-radius:12px}
  /* performance notice */
  .perfHint{position:fixed;left:12px;bottom:12px;color:#9fb0bf;font-size:12px;z-index:60}
  @media(max-width:420px){ .joy{width:96px;height:96px} .stick{width:42px;height:42px} .btnFire{width:64px;height:64px} }
</style>
</head>
<body>
  <div id="canvasHolder" role="application" aria-label="Escena 3D"></div>

  <!-- UI -->
  <div class="topBar">
    <div class="logo" id="logoBtn">SinFiltro - Arena</div>
    <div class="miniBtns">
      <div class="icon" id="btnMenu">â˜°</div>
      <div class="icon" id="btnStart">â–¶</div>
    </div>
  </div>

  <div class="joy" id="joy" aria-hidden="false">
    <div class="stick" id="stick" aria-hidden="false"></div>
  </div>

  <div class="btnFire" id="btnFire" aria-label="Disparar">ðŸ”«</div>

  <div id="viewer" role="dialog" aria-hidden="true">
    <div style="text-align:center">
      <img id="viewerImg" src="" alt="preview"><br><br>
      <button id="closeViewer" style="padding:8px 12px;border-radius:8px">Cerrar</button>
    </div>
  </div>

  <div class="perfHint" id="perfHint">Modo demo â€” calles cargadas con colisiones invisibles</div>

  <!-- Three.js CDN -->
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

  <script>
  (function(){
    // ---------- Init scene ----------
    const holder = document.getElementById('canvasHolder');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x05060a, 0.0025);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.domElement.style.touchAction = 'none'; // important so UI touch works
    holder.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 4000);
    camera.position.set(0,6,10);

    // lights
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(10,20,10); scene.add(dir);
    scene.add(new THREE.AmbientLight(0xffffff, 0.22));

    // ground base
    const groundMat = new THREE.MeshStandardMaterial({color:0x0b0f14, metalness:0.05, roughness:0.95});
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), groundMat);
    ground.rotation.x = -Math.PI/2; ground.position.y = 0; scene.add(ground);

    // ---------- Helper groups ----------
    const roadsGroup = new THREE.Group(); // visible road meshes
    const propsGroup = new THREE.Group(); // lampposts, small props
    scene.add(roadsGroup, propsGroup);

    // ---------- Player car (same proven base) ----------
    const car = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.7,4.2), new THREE.MeshStandardMaterial({color:0xff5555, metalness:0.3, roughness:0.6}));
    body.position.y = 0.7; car.add(body);
    const wheelGeo = new THREE.CylinderGeometry(0.35,0.35,0.5,8);
    const wheelMat = new THREE.MeshStandardMaterial({color:0x111111});
    for(let i=0;i<4;i++){
      const w = new THREE.Mesh(wheelGeo, wheelMat);
      w.rotation.z = Math.PI/2;
      w.position.y = 0.25;
      w.position.x = (i%2===0)?-1:1;
      w.position.z = (i<2)?1.2:-1.2;
      car.add(w);
    }
    car.position.set(0,0,0);
    scene.add(car);

    // bot
    const bot = car.clone();
    bot.children[0].material = new THREE.MeshStandardMaterial({color:0x55aaff, metalness:0.2, roughness:0.6});
    bot.position.set(8,0,-6);
    scene.add(bot);

    // ---------- Street system (grid of rectangular roads approximating "manzanas") ----------
    // We'll create a simplified map: several parallel N-S roads and several E-W roads to form blocks.
    // Each road is a rectangle (mesh) and we'll create a corresponding collision box (allowed driving area).
    const allowedAreas = []; // array of THREE.Box3 representing driveable road rectangles

    function addRoadRect(centerX, centerZ, width, length, rotation = 0){
      // Road visual
      const geo = new THREE.PlaneGeometry(length, width);
      const mat = new THREE.MeshStandardMaterial({color:0x22282d, metalness:0.02, roughness:0.9});
      const mesh = new THREE.Mesh(geo, mat);
      mesh.rotation.x = -Math.PI/2;
      mesh.position.set(centerX, 0.001, centerZ);
      mesh.rotation.z = rotation;
      roadsGroup.add(mesh);

      // Edges (banqueta) - thin raised box
      const curbGeo = new THREE.BoxGeometry(length, 0.12, 0.4);
      const curbMat = new THREE.MeshStandardMaterial({color:0x10161a, metalness:0.02, roughness:0.95});
      // two curbs along left/right (we approximate by rotating)
      const curbL = new THREE.Mesh(curbGeo, curbMat);
      curbL.rotation.y = rotation;
      curbL.position.set(centerX,0.06,centerZ - (width/2 + 0.2));
      roadsGroup.add(curbL);
      const curbR = curbL.clone();
      curbR.position.set(centerX,0.06,centerZ + (width/2 + 0.2));
      roadsGroup.add(curbR);

      // Create allowed area as Box3 in world coordinates
      // Use an oriented box transform -> approximate by computing bounding box after applying rotation/translation
      const tempGeom = geo.clone();
      // compute axis-aligned bounding box by transforming corners
      const halfL = length/2, halfW = width/2;
      const corners = [
        new THREE.Vector3(-halfL,0, -halfW),
        new THREE.Vector3(halfL,0,-halfW),
        new THREE.Vector3(halfL,0, halfW),
        new THREE.Vector3(-halfL,0, halfW)
      ];
      const rot = new THREE.Euler(-Math.PI/2, 0, rotation);
      const worldCorners = corners.map(c=>{
        const v = c.clone();
        v.applyEuler(rot);
        v.add(new THREE.Vector3(centerX, 0.001, centerZ));
        return v;
      });
      const box = new THREE.Box3().setFromPoints(worldCorners);
      // slightly expand vertically so we can test in 3D
      box.min.y = -2; box.max.y = 6;
      allowedAreas.push(box);
    }

    // Build map: a small grid resembling neighborhood blocks (approx Jardines de Morelos pattern)
    // We'll create 5 vertical roads and 5 horizontal roads forming ~16 blocks. Dimensions tuned for the car scale.
    const ROAD_WIDTH = 8; // in world units
    const ROAD_SEP = 24;  // distance between parallel roads (block size)
    const count = 5;
    const origin = - (count-1)/2 * ROAD_SEP;
    for(let r=0;r<count;r++){
      const x = origin + r*ROAD_SEP;
      // vertical (N-S) roads (long length)
      addRoadRect(x, 0, ROAD_WIDTH, count*ROAD_SEP + 40, 0); // rotation 0 -> along Z
    }
    for(let c=0;c<count;c++){
      const z = origin + c*ROAD_SEP;
      // horizontal (E-W) roads
      addRoadRect(0, z, ROAD_WIDTH, count*ROAD_SEP + 40, Math.PI/2); // rotation 90deg -> along X
    }

    // add some lampposts at intersections for visual reference (light + pole)
    function addLamp(x,z){
      const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,3,6), new THREE.MeshStandardMaterial({color:0x111216}));
      pole.position.set(x,1.5,z);
      propsGroup.add(pole);
      const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.18,8,6), new THREE.MeshStandardMaterial({emissive:0xfff0c8, emissiveIntensity:1, color:0x222222}));
      bulb.position.set(x,2.6,z);
      propsGroup.add(bulb);
      const pl = new THREE.PointLight(0xfff0c8, 0.6, 12, 2);
      pl.position.set(x,2.6,z);
      scene.add(pl);
    }
    // lamps at intersections
    for(let r=0;r<count;r++){
      for(let c=0;c<count;c++){
        const x = origin + r*ROAD_SEP;
        const z = origin + c*ROAD_SEP;
        addLamp(x + ROAD_SEP/2 - 3, z + ROAD_SEP/2 - 3); // offset slightly to look natural
      }
    }

    // ---------- Movement state (base that worked well) ----------
    const state = {forward:0, turn:0, speed:0, maxSpeed: 1.0, rotSpeed: 0.045};
    let lastTime = performance.now();

    // bullets
    const bullets = [];
    function spawnBullet(origin, dir){
      const g = new THREE.SphereGeometry(0.12, 6,6);
      const m = new THREE.MeshStandardMaterial({emissive:0xffcc77, color:0x222222});
      const b = new THREE.Mesh(g,m);
      b.position.copy(origin);
      b.userData.dir = dir.clone();
      b.userData.speed = 2.2;
      scene.add(b); bullets.push(b);
    }

    // ---------- Input (joystick) ----------
    const joy = document.getElementById('joy'), stickEl = document.getElementById('stick');
    let touchId = null, baseX=0, baseY=0;
    let stick = {x:0,y:0};
    function resetStick(){ stick={x:0,y:0}; stickEl.style.transform = `translate(0px,0px)`; }
    joy.addEventListener('touchstart', e=>{
      e.preventDefault();
      const t = e.changedTouches[0]; touchId = t.identifier; baseX = t.clientX; baseY = t.clientY;
    }, {passive:false});
    joy.addEventListener('touchmove', e=>{
      e.preventDefault();
      for(const t of e.changedTouches){
        if(t.identifier === touchId){
          const dx = t.clientX - baseX;
          const dy = t.clientY - baseY;
          const max = 36;
          const nx = Math.max(-1, Math.min(1, dx/max));
          const ny = Math.max(-1, Math.min(1, dy/max));
          stick.x = nx; stick.y = -ny; // invert y
          stickEl.style.transform = `translate(${nx*28}px,${-ny*28}px)`;
        }
      }
    }, {passive:false});
    joy.addEventListener('touchend', e=>{ for(const t of e.changedTouches) if(t.identifier===touchId) { touchId=null; resetStick(); } }, {passive:false});
    // pointer as fallback
    let md=false;
    joy.addEventListener('pointerdown', e=>{ md=true; baseX=e.clientX; baseY=e.clientY; joy.setPointerCapture(e.pointerId); });
    joy.addEventListener('pointermove', e=>{ if(!md) return; const dx=e.clientX-baseX, dy=e.clientY-baseY; const max=36; const nx=Math.max(-1,Math.min(1,dx/max)); const ny=Math.max(-1,Math.min(1,dy/max)); stick.x=nx; stick.y=-ny; stickEl.style.transform=`translate(${nx*28}px,${-ny*28}px)`; });
    joy.addEventListener('pointerup', e=>{ md=false; resetStick(); });

    // fire
    const fireBtn = document.getElementById('btnFire');
    fireBtn.addEventListener('touchstart', e=> { e.preventDefault(); doFire(); }, {passive:false});
    fireBtn.addEventListener('mousedown', ()=> doFire());
    function doFire(){
      const dir = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion).normalize();
      const origin = car.position.clone().add(new THREE.Vector3(0,1, -2).applyQuaternion(car.quaternion));
      spawnBullet(origin, dir);
    }

    // ---------- Collision: test if point within any allowed area ----------
    function pointInAllowedAreas(pos){
      for(const b of allowedAreas){
        if(pos.x >= b.min.x && pos.x <= b.max.x && pos.z >= b.min.z && pos.z <= b.max.z && pos.y >= b.min.y && pos.y <= b.max.y){
          return true;
        }
      }
      return false;
    }

    // Helper: compute nearest point to combined allowed area (simple approach: clamp to union bounding box)
    // We'll compute the nearest Box3 among allowedAreas and clamp the position to inside that box.
    function clampToNearestAllowed(pos){
      let nearest = null; let bestDist = Infinity;
      for(const b of allowedAreas){
        // distance from point to box (0 if inside)
        const dx = Math.max(b.min.x - pos.x, 0, pos.x - b.max.x);
        const dz = Math.max(b.min.z - pos.z, 0, pos.z - b.max.z);
        const d = Math.sqrt(dx*dx + dz*dz);
        if(d < bestDist){ bestDist = d; nearest = b; }
      }
      if(nearest){
        const clamped = pos.clone();
        clamped.x = Math.max(nearest.min.x + 0.1, Math.min(nearest.max.x - 0.1, clamped.x));
        clamped.z = Math.max(nearest.min.z + 0.1, Math.min(nearest.max.z - 0.1, clamped.z));
        return clamped;
      }
      return pos;
    }

    // ---------- Simple bot movement ----------
    let botAngle = 0;

    // ---------- Resize ----------
    window.addEventListener('resize', ()=>{ renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); });

    // ---------- MAIN LOOP ----------
    let last = performance.now();
    function animate(){
      const now = performance.now();
      const dt = Math.min(50, now - last) / 16.666;
      last = now;

      // joystick -> state
      state.forward = Math.max(-1, Math.min(1, stick.y));
      state.turn = Math.max(-1, Math.min(1, stick.x));

      // speed physics
      if(state.forward > 0.05) state.speed += 0.02 * state.forward * dt;
      else if(state.forward < -0.05) state.speed -= 0.03 * (-state.forward) * dt;
      else state.speed *= 0.96;

      state.speed = Math.max(-state.maxSpeed, Math.min(state.maxSpeed, state.speed));
      // rotation influenced by turn and speed
      car.rotation.y += -state.turn * state.rotSpeed * (0.9 + Math.abs(state.speed)) * dt;

      // compute forward movement
      const forwardVec = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion);
      const move = forwardVec.clone().multiplyScalar(state.speed * dt * 0.8);

      // predicted position
      const predicted = car.position.clone().add(move);

      // check allowed area
      if(pointInAllowedAreas(predicted)){
        // ok - move freely
        car.position.copy(predicted);
      } else {
        // outside roads: gently push back and reduce speed
        const clamped = clampToNearestAllowed(predicted);
        // move a portion toward clamped position (so it's smooth)
        const push = clamped.clone().sub(car.position).multiplyScalar(0.35);
        car.position.add(push);
        // dampen speed strongly
        state.speed *= 0.4;
      }

      // camera follow smooth
      const desiredCam = car.position.clone().add(new THREE.Vector3(0,4,10).applyQuaternion(car.quaternion));
      camera.position.lerp(desiredCam, 0.12);
      const lookAt = car.position.clone().add(new THREE.Vector3(0,1.5,0));
      camera.lookAt(lookAt);

      // bot movement + look at car
      botAngle += 0.002 * dt * 30;
      bot.position.x = Math.cos(botAngle) * 8;
      bot.position.z = Math.sin(botAngle) * 8;
      bot.lookAt(car.position);

      // bullets update + simple collision vs bot
      for(let i=bullets.length-1;i>=0;i--){
        const b = bullets[i];
        b.position.add(b.userData.dir.clone().multiplyScalar(b.userData.speed * dt));
        if(b.position.distanceTo(bot.position) < 1.4){
          scene.remove(b); bullets.splice(i,1);
          const hit = new THREE.Mesh(new THREE.SphereGeometry(0.25,6,6), new THREE.MeshStandardMaterial({emissive:0xff5522, color:0x111111}));
          hit.position.copy(bot.position);
          scene.add(hit);
          setTimeout(()=> scene.remove(hit), 500);
          continue;
        }
        if(b.position.length() > 2000){ scene.remove(b); bullets.splice(i,1); }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    // ---------- UI actions ----------
    document.getElementById('btnMenu').addEventListener('click', ()=> { alert('Menu demo (placeholder).'); });
    document.getElementById('btnStart').addEventListener('click', ()=> { alert('Iniciar demo: modos 1v1 / 4v4 (placeholder).'); });
    document.getElementById('logoBtn').addEventListener('click', ()=>{
      const viewer = document.getElementById('viewer'), viewerImg = document.getElementById('viewerImg');
      viewerImg.src = 'https://picsum.photos/800/420?random=' + Math.floor(Math.random()*1000);
      viewer.style.display='flex'; viewer.setAttribute('aria-hidden','false');
    });
    document.getElementById('closeViewer').addEventListener('click', ()=> {
      const viewer = document.getElementById('viewer');
      viewer.style.display='none'; viewer.setAttribute('aria-hidden','true');
    });

    // ---------- Performance & notes ----------
    // - Road geometry is kept simple (plain planes + a few boxes).
    // - allowedAreas is an array of axis-aligned boxes approximating driveable roads (fast checks).
    // - Collision reaction: smooth clamp back + speed reduction (no rigid-body heavy physics).
    // - This preserves the mobile-friendly input & responsiveness you had before.

    // Expose debug (optional)
    window._sinfiltro = { scene, car, allowedAreas, roadsGroup, propsGroup };
  })();
  </script>
</body>
</html>
