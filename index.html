<!-- index.html â€” SinFiltro : Playa Azul (REAL, optimizado mÃ³vil) -->
<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>SinFiltro â€” Playa Azul (real, demo)</title>
<style>
  :root{
    --bg:#05060a; --muted:#9fb0bf; --accent1:#00d1ff; --accent2:#8a6eff;
  }
  html,body{height:100%;margin:0;background:linear-gradient(#05060a,#071226);font-family:Inter,system-ui,Arial;color:#eaf7ff;overflow:hidden}
  #holder{width:100%;height:100%;position:relative;touch-action:none}
  /* Top UI */
  .topbar{position:fixed;left:8px;right:8px;top:10px;height:56px;display:flex;align-items:center;justify-content:space-between;gap:8px;z-index:120;pointer-events:auto}
  .badge{background:rgba(255,255,255,0.03);padding:8px 12px;border-radius:12px;font-weight:600}
  .controls{display:flex;gap:8px}
  .chip{padding:8px 12px;border-radius:12px;background:linear-gradient(90deg,var(--accent1),var(--accent2));color:#001;font-weight:700;cursor:pointer;box-shadow:0 8px 30px rgba(0,0,0,0.45)}
  /* joystick + fire */
  .joy { position:fixed; left:18px; bottom:18px; width:110px; height:110px; border-radius:60px; background:rgba(255,255,255,0.03); display:flex; align-items:center; justify-content:center; pointer-events:auto; z-index:100 }
  .stick { width:48px; height:48px; border-radius:50%; background:rgba(255,255,255,0.06); transform:translate(0,0) }
  .fire { position:fixed; right:18px; bottom:26px; width:70px; height:70px; border-radius:50%; background:linear-gradient(135deg,var(--accent1),var(--accent2)); display:flex;align-items:center;justify-content:center;z-index:100;pointer-events:auto;box-shadow:0 18px 60px rgba(0,0,0,0.6) }
  /* minimap + HUD */
  .minimap{position:fixed;right:12px;bottom:120px;width:110px;height:110px;border-radius:12px;background:rgba(0,0,0,0.6);z-index:110;display:flex;align-items:center;justify-content:center;pointer-events:auto;box-shadow:0 12px 30px rgba(0,0,0,0.6)}
  .fps{position:fixed;left:12px;bottom:120px;background:rgba(0,0,0,0.6);padding:6px 10px;border-radius:10px;font-weight:600;z-index:110}
  .info{position:fixed;left:12px;bottom:80px;background:rgba(0,0,0,0.4);padding:8px 10px;border-radius:10px;z-index:110;max-width:70%}
  .loading{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:130;background:rgba(0,0,0,0.7);padding:12px 16px;border-radius:12px}
  @media (max-width:420px){ .joy{width:92px;height:92px} .stick{width:40px;height:40px} .fire{width:60px;height:60px} .minimap{width:88px;height:88px} }
</style>
</head>
<body>
  <div id="holder"></div>

  <div class="topbar">
    <div style="display:flex;gap:8px;align-items:center">
      <div class="badge" id="title">SinFiltro â€” Playa Azul (real demo)</div>
      <div id="statusTiles" class="badge" style="display:none">Calles: <span id="tilesCount">0</span></div>
    </div>
    <div class="controls">
      <div id="btnToggleRoads" class="chip">Calles: ON</div>
      <div id="btnToggleSat" class="chip">SatÃ©lite: OFF</div>
      <div id="btnRecenter" class="chip">Re-cent.</div>
    </div>
  </div>

  <div id="loading" class="loading">Cargando datos de mapaâ€¦</div>

  <div class="joy" id="joy"><div class="stick" id="stick"></div></div>
  <div class="fire" id="fire" title="Disparar">ðŸ”«</div>

  <div class="minimap" id="minimap">Mini</div>
  <div class="fps" id="fps">FPS: --</div>
  <div class="info" id="info">Modo real â€” cargando...</div>

  <!-- three.js -->
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

  <script>
  (async function(){
    // ---------------- CONFIG ----------------
    const holder = document.getElementById('holder');

    // Bounding box small area around Playa Azul (tweakable)
    // Format [south, west, north, east]
    const BBOX = [19.6032, -99.0028, 19.6068, -98.9988]; // focused area of Playa Azul
    const OVERPASS_URL = 'https://overpass-api.de/api/interpreter';
    const ESRI_TILE = 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}';

    // ---------------- THREEJS scene ----------------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x05060a);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    holder.appendChild(renderer.domElement);

    // camera
    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 5000);
    camera.position.set(0,12,24);

    // lights
    const dir = new THREE.DirectionalLight(0xffffff, 0.95);
    dir.position.set(5,10,7); scene.add(dir);
    scene.add(new THREE.AmbientLight(0xffffff, 0.28));

    // ground plane base (we will override material if satellite enabled)
    const groundMat = new THREE.MeshStandardMaterial({color:0x0b1220, roughness:0.95, metalness:0.05});
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000,1,1), groundMat);
    ground.rotation.x = -Math.PI/2; ground.position.y = 0;
    scene.add(ground);

    // ---------------- coordinate helpers ----------------
    // simple equirectangular yard scale conversion (centered)
    const latCenter = (BBOX[0] + BBOX[2]) / 2;
    const lonCenter = (BBOX[1] + BBOX[3]) / 2;
    const EARTH_R = 6378137;
    function metersPerDegLat(){ return (Math.PI/180) * EARTH_R; }
    function metersPerDegLon(lat){ return (Math.PI/180) * EARTH_R * Math.cos(lat * Math.PI/180); }

    const mPerDegLat = metersPerDegLat();
    const mPerDegLon = metersPerDegLon(latCenter);

    // scale factor to shrink real meters into comfortable scene units for mobile
    const SCALE = 0.06;

    function ll2xy(lat, lon){
      const dx = (lon - lonCenter) * mPerDegLon;
      const dz = (lat - latCenter) * mPerDegLat;
      return new THREE.Vector3(dx * SCALE, 0, -dz * SCALE);
    }

    // ---------------- player car ----------------
    const car = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.7,4.2), new THREE.MeshStandardMaterial({color:0xff5555, metalness:0.2, roughness:0.6}));
    body.position.y = 0.7; car.add(body);
    const wheelGeo = new THREE.CylinderGeometry(0.35,0.35,0.5,8);
    const wheelMat = new THREE.MeshStandardMaterial({color:0x111111});
    for(let i=0;i<4;i++){
      const w = new THREE.Mesh(wheelGeo, wheelMat);
      w.rotation.z = Math.PI/2; w.position.y = 0.25;
      w.position.x = (i%2===0)?-1:1;
      w.position.z = (i<2)?1.2:-1.2;
      car.add(w);
    }
    car.position.set(0, 0, 0);
    scene.add(car);

    // ---------------- groups, storage ----------------
    const roadsGroup = new THREE.Group(); scene.add(roadsGroup);
    const buildingsGroup = new THREE.Group(); scene.add(buildingsGroup);
    const roadPolylines = []; // {poly: [Vector3...], name, tags}
    const buildingCountRef = {count:0};

    // ---------------- Overpass fetch & parse ----------------
    function overpassQuery(bbox){
      const [s,w,n,e] = bbox;
      // We ask for ways (highway & building) in bbox and include nodes
      return `
        [out:json][timeout:30];
        (
          way["highway"](${s},${w},${n},${e});
          way["building"](${s},${w},${n},${e});
        );
        (._;>;);
        out body;
      `;
    }

    async function fetchOSM(){
      // POST to Overpass
      const q = overpassQuery(BBOX);
      const res = await fetch(OVERPASS_URL, {method:'POST', body: q});
      if(!res.ok) throw new Error('Overpass error: ' + res.status);
      return await res.json();
    }

    function parseOverpass(data){
      const nodes = new Map();
      const ways = [];
      for(const el of data.elements){
        if(el.type === 'node') nodes.set(el.id, el);
      }
      for(const el of data.elements){
        if(el.type === 'way'){
          ways.push({id: el.id, nodes: el.nodes, tags: el.tags || {}});
        }
      }
      return {nodes, ways};
    }

    // ---------------- build simple road geometry & store polylines ----------------
    function clearGroup(g){
      if(!g) return;
      while(g.children.length) {
        const c = g.children[0];
        c.geometry?.dispose?.();
        c.material?.dispose?.();
        g.remove(c);
      }
    }

    function buildRoads(nodes, ways){
      clearGroup(roadsGroup);
      roadPolylines.length = 0;
      // keep only a subset of highway types for demo & performance
      const keep = new Set(['motorway','trunk','primary','secondary','tertiary','residential','service','unclassified','living_street']);
      let segCount = 0, wayCount = 0;

      // Sort ways to prefer named streets first (helps user experience)
      const highways = ways.filter(w=>w.tags && w.tags.highway);
      highways.sort((a,b)=>{
        const an = !!a.tags.name, bn = !!b.tags.name;
        return (an === bn) ? 0 : (an ? -1 : 1);
      });

      const LIMIT_WAYS = 220; // safety cap
      for(let idx=0; idx<Math.min(highways.length, LIMIT_WAYS); idx++){
        const w = highways[idx];
        if(!keep.has(w.tags.highway) && w.tags.highway !== 'residential') continue;
        const pts = [];
        for(let nid of w.nodes){
          const n = nodes.get(nid);
          if(!n) continue;
          pts.push(ll2xy(n.lat, n.lon));
        }
        if(pts.length < 2) continue;
        // downsample every Nth node depending on length
        const step = Math.max(1, Math.floor(pts.length / 180));
        const simplified = pts.filter((p,i)=> i%step===0);
        // store polyline for collision/name lookup
        roadPolylines.push({poly: simplified.map(p=> new THREE.Vector3(p.x,0,p.z)), name: w.tags.name || null, tags: w.tags});

        // create narrow boxes between points
        for(let i=0;i<simplified.length-1;i++){
          const a = simplified[i], b = simplified[i+1];
          const seg = b.clone().sub(a);
          const len = seg.length();
          const mid = a.clone().add(b).multiplyScalar(0.5);
          const width = (w.tags.highway === 'motorway' || w.tags.highway === 'trunk') ? 3.2 : 1.8;
          const geom = new THREE.BoxGeometry(width, 0.02, Math.max(len,0.05));
          const mat = new THREE.MeshStandardMaterial({color:0x15161a, roughness:0.95});
          const m = new THREE.Mesh(geom, mat);
          m.position.copy(mid); m.position.y = 0.01;
          // rotate to align with segment
          m.lookAt(b); m.rotateX(Math.PI/2);
          roadsGroup.add(m);
          segCount++;
        }
        wayCount++;
      }
      return {segmentCount: segCount, wayCount: wayCount};
    }

    // ---------------- buildings (simple extruded boxes) ----------------
    function buildBuildings(nodes, ways){
      clearGroup(buildingsGroup);
      let bcount = 0;
      for(const w of ways){
        if(!w.tags || !w.tags.building) continue;
        const pts = [];
        for(const nid of w.nodes){
          const n = nodes.get(nid);
          if(!n) continue;
          pts.push(ll2xy(n.lat, n.lon));
        }
        if(pts.length < 3) continue;
        // approximate bounding box
        let minx=1e9,minz=1e9,maxx=-1e9,maxz=-1e9;
        for(const p of pts){ minx=Math.min(minx,p.x); maxx=Math.max(maxx,p.x); minz=Math.min(minz,p.z); maxz=Math.max(maxz,p.z); }
        const wth = Math.max(1.0,(maxx-minx));
        const lng = Math.max(1.0,(maxz-minz));
        const levels = w.tags['building:levels'] ? Math.max(1, +w.tags['building:levels']) : Math.floor(1 + Math.random()*3);
        const height = Math.max(2, levels) * 1.8;
        const g = new THREE.BoxGeometry(wth, height, lng);
        const mat = new THREE.MeshStandardMaterial({color:0x0e1418, roughness:0.95});
        const b = new THREE.Mesh(g, mat);
        b.position.set((minx+maxx)/2, height/2, (minz+maxz)/2);
        buildingsGroup.add(b);
        bcount++;
      }
      buildingCountRef.count = bcount;
      return bcount;
    }

    // ---------------- lamp posts (visual) ----------------
    function addLampAt(pos){
      const stick = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,2,6), new THREE.MeshStandardMaterial({color:0x0b0b0b}));
      stick.position.copy(pos).add(new THREE.Vector3(0,1,0));
      scene.add(stick);
      const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.08,8,8), new THREE.MeshBasicMaterial({color:0xfff8d9}));
      bulb.position.copy(pos).add(new THREE.Vector3(0,2,0));
      scene.add(bulb);
    }

    // ---------------- load OSM & build scene ----------------
    async function initMapData(){
      try{
        const raw = await fetchOSM();
        const {nodes, ways} = parseOverpass(raw);

        // Build roads + buildings
        const roadsInfo = buildRoads(nodes, ways);
        const bcount = buildBuildings(nodes, ways);

        // Add sparse lamps along some polylines for depth
        for(const rp of roadPolylines){
          const poly = rp.poly;
          for(let i=0;i<poly.length;i+=Math.max(2, Math.floor(poly.length/5))){
            addLampAt(poly[i]);
          }
        }

        // set HUD
        document.getElementById('tilesCount').textContent = roadPolylines.length;
        document.getElementById('statusTiles').style.display = 'inline-block';
        document.getElementById('info').textContent = `Modo real â€” calles: ${roadPolylines.length} vÃ­as Â· segmentos: ${roadsInfo.segmentCount} Â· edificios: ${bcount}`;
        document.getElementById('loading').style.display = 'none';

        // place car at mid of first polyline (if present)
        if(roadPolylines.length && roadPolylines[0].poly.length){
          const mid = roadPolylines[0].poly[Math.floor(roadPolylines[0].poly.length/2)];
          car.position.copy(mid);
        }
        return true;
      }catch(err){
        console.error('initMapData error', err);
        document.getElementById('loading').textContent = 'Error cargando mapa (Overpass). Modo demo activado.';
        // fallback: build a simple demo grid of roads to keep playability
        buildDemoGrid();
        document.getElementById('info').textContent = `Modo demo â€” calles sintÃ©ticas (fallback)`;
        document.getElementById('loading').style.display = 'none';
        return false;
      }
    }

    // fallback demo: small grid so user can play if Overpass fails
    function buildDemoGrid(){
      clearGroup(roadsGroup); clearGroup(buildingsGroup);
      roadPolylines.length = 0;
      const size = 40;
      const spacing = 6;
      for(let row=-2; row<=2; row++){
        const poly = [];
        for(let i=-size; i<=size; i+=spacing){
          poly.push(new THREE.Vector3(i,0,row*spacing));
        }
        roadPolylines.push({poly, name: `Demo R${row}`, tags:{}});
        // render as strips
        for(let i=0;i<poly.length-1;i++){
          const a=poly[i], b=poly[i+1];
          const len = b.clone().sub(a).length();
          const mid = a.clone().add(b).multiplyScalar(0.5);
          const geom = new THREE.BoxGeometry(2,0.02,len);
          const mat = new THREE.MeshStandardMaterial({color:0x15161a});
          const m = new THREE.Mesh(geom, mat);
          m.position.copy(mid); m.position.y = 0.01; m.lookAt(b); m.rotateX(Math.PI/2);
          roadsGroup.add(m);
        }
      }
      // place car at center
      car.position.set(0,0,0);
    }

    // ---------------- soft constraint to road (keeps car near roads) ----------------
    function constrainToRoad(pos){
      let best = {dist: 1e9, nearest: null, name: null};
      for(const rp of roadPolylines){
        const poly = rp.poly;
        for(let i=0;i<poly.length-1;i++){
          const a = poly[i], b = poly[i+1];
          const ap = pos.clone().sub(a);
          const ab = b.clone().sub(a);
          const abLenSq = ab.lengthSq();
          if(abLenSq === 0) continue;
          const t = Math.max(0, Math.min(1, ap.dot(ab)/abLenSq));
          const proj = a.clone().add(ab.multiplyScalar(t));
          const d = proj.distanceTo(pos);
          if(d < best.dist){
            best.dist = d; best.nearest = proj; best.name = rp.name || null;
          }
        }
      }
      if(!best.nearest) return {constrained:false};
      const maxLat = 1.9; // scene units lateral limit
      if(best.dist > maxLat){
        // pull toward nearest softly
        const dir = best.nearest.clone().sub(pos).multiplyScalar(0.26);
        pos.add(dir);
        return {constrained:true, name: best.name};
      }
      return {constrained:false, name: best.name};
    }

    // ---------------- satellite texture ----------------
    let satTexture = null, satEnabled = false;
    async function loadSatellite(){
      try{
        const z = 16;
        function lon2tile(lon,z){ return Math.floor((lon+180)/360*Math.pow(2,z)); }
        function lat2tile(lat,z){ return Math.floor((1-Math.log(Math.tan(lat*Math.PI/180)+1/Math.cos(lat*Math.PI/180))/Math.PI)/2 * Math.pow(2,z)); }
        const tx = lon2tile(lonCenter, z);
        const ty = lat2tile(latCenter, z);
        const url = ESRI_TILE.replace('{z}',z).replace('{x}',tx).replace('{y}',ty);
        const img = await new Promise((res,rej)=>{
          const i = new Image();
          i.crossOrigin = 'anonymous';
          i.onload = ()=> res(i);
          i.onerror = (e)=> rej(e);
          i.src = url;
        });
        const tex = new THREE.CanvasTexture(img);
        tex.encoding = THREE.sRGBEncoding;
        satTexture = tex;
        return true;
      }catch(e){
        console.warn('sat load failed', e);
        return false;
      }
    }

    function enableSatellite(on){
      if(on && satTexture){
        ground.material?.dispose?.();
        ground.material = new THREE.MeshBasicMaterial({map: satTexture});
        satEnabled = true;
        document.getElementById('btnToggleSat').textContent = 'SatÃ©lite: ON';
      } else {
        ground.material?.dispose?.();
        ground.material = groundMat;
        satEnabled = false;
        document.getElementById('btnToggleSat').textContent = 'SatÃ©lite: OFF';
      }
    }

    // ---------------- minimap (canvas) ----------------
    const minimap = document.getElementById('minimap');
    const mmCanvas = document.createElement('canvas');
    mmCanvas.width = mmCanvas.height = 256;
    minimap.innerHTML = ''; minimap.appendChild(mmCanvas);
    const mmCtx = mmCanvas.getContext('2d');

    function updateMinimap(){
      const scale = 0.38;
      mmCtx.clearRect(0,0,256,256);
      mmCtx.fillStyle = '#07101a'; mmCtx.fillRect(0,0,256,256);
      mmCtx.strokeStyle = '#bfe9ff'; mmCtx.lineWidth = 2;
      mmCtx.beginPath();
      for(const rp of roadPolylines){
        const poly = rp.poly;
        if(poly.length < 2) continue;
        for(let i=0;i<poly.length;i++){
          const p = poly[i];
          const x = 128 + p.x * scale;
          const y = 128 + p.z * scale;
          if(i===0) mmCtx.moveTo(x,y); else mmCtx.lineTo(x,y);
        }
      }
      mmCtx.stroke();
      // player marker
      const px = 128 + car.position.x * scale;
      const py = 128 + car.position.z * scale;
      mmCtx.fillStyle = '#ff6666'; mmCtx.beginPath(); mmCtx.arc(px,py,4,0,Math.PI*2); mmCtx.fill();
    }

    // ---------------- joystick & input ----------------
    const joy = document.getElementById('joy'), stickEl = document.getElementById('stick');
    let touchId = null, baseX = 0, baseY = 0;
    let stick = {x:0,y:0};
    function resetStick(){ stick = {x:0,y:0}; stickEl.style.transform = `translate(0px,0px)`; }

    joy.addEventListener('touchstart', e=>{ e.preventDefault(); const t=e.changedTouches[0]; touchId=t.identifier; baseX=t.clientX; baseY=t.clientY; }, {passive:false});
    joy.addEventListener('touchmove', e=>{ e.preventDefault(); for(const t of e.changedTouches){ if(t.identifier===touchId){ const dx=t.clientX-baseX, dy=t.clientY-baseY; const max=36; const nx=Math.max(-1,Math.min(1,dx/max)); const ny=Math.max(-1,Math.min(1,dy/max)); stick.x=nx; stick.y=-ny; stickEl.style.transform = `translate(${nx*28}px,${-ny*28}px)`; } } }, {passive:false});
    joy.addEventListener('touchend', e=>{ for(const t of e.changedTouches){ if(t.identifier===touchId){ touchId=null; resetStick(); } } }, {passive:false});
    // pointer for desktop
    let md=false;
    joy.addEventListener('pointerdown', e=>{ md=true; baseX=e.clientX; baseY=e.clientY; joy.setPointerCapture(e.pointerId); });
    joy.addEventListener('pointermove', e=>{ if(!md) return; const dx=e.clientX-baseX, dy=e.clientY-baseY; const max=36; const nx=Math.max(-1,Math.min(1,dx/max)); const ny=Math.max(-1,Math.min(1,dy/max)); stick.x=nx; stick.y=-ny; stickEl.style.transform=`translate(${nx*28}px,${-ny*28}px)`; });
    joy.addEventListener('pointerup', e=>{ md=false; resetStick(); });

    // fire button (no external links)
    const bullets = [];
    function spawnBullet(origin, dir){
      const g = new THREE.SphereGeometry(0.12,8,8);
      const m = new THREE.MeshStandardMaterial({emissive:0xffcc77, color:0x222222});
      const b = new THREE.Mesh(g,m);
      b.position.copy(origin); b.userData.dir = dir.clone(); b.userData.speed = 2.4;
      scene.add(b); bullets.push(b);
    }

    const fireBtn = document.getElementById('fire');
    fireBtn.addEventListener('touchstart', e=>{ e.preventDefault(); doFire(); }, {passive:false});
    fireBtn.addEventListener('mousedown', doFire);
    function doFire(){
      const dir = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion).normalize();
      const origin = car.position.clone().add(new THREE.Vector3(0,1,-2).applyQuaternion(car.quaternion));
      spawnBullet(origin, dir);
    }

    // ---------------- UI toggles ----------------
    let roadsVisible = true;
    document.getElementById('btnToggleRoads').addEventListener('click', ()=>{
      roadsVisible = !roadsVisible; roadsGroup.visible = roadsVisible;
      document.getElementById('btnToggleRoads').textContent = `Calles: ${roadsVisible ? 'ON' : 'OFF'}`;
    });

    let satBtn = document.getElementById('btnToggleSat');
    satBtn.addEventListener('click', async ()=>{
      if(!satTexture){ satBtn.textContent = 'SatÃ©lite: Cargando...'; await loadSatellite(); }
      enableSatellite(!satEnabled);
    });

    document.getElementById('btnRecenter').addEventListener('click', ()=>{
      car.position.set(0,0,0); car.rotation.set(0,0,0); camera.position.set(0,12,24);
    });

    // ---------------- HUD: nearest street name + info update ----------------
    let lastNearest = null;
    function updateHUDNearest(){
      // find nearest polyline & name
      let best = {dist:1e9, name:null};
      const p = car.position;
      for(const rp of roadPolylines){
        const poly = rp.poly;
        for(let i=0;i<poly.length-1;i++){
          const a=poly[i], b=poly[i+1];
          const ap = p.clone().sub(a); const ab = b.clone().sub(a);
          const t = Math.max(0, Math.min(1, ap.dot(ab)/ab.lengthSq()));
          const proj = a.clone().add(ab.multiplyScalar(t));
          const d = proj.distanceTo(p);
          if(d < best.dist){ best.dist = d; best.name = rp.name || null; }
        }
      }
      const infoEl = document.getElementById('info');
      const name = best.name || '(sin nombre)';
      if(lastNearest !== name){
        lastNearest = name;
      }
      // update info
      const tiles = roadPolylines.length;
      const segs = document.getElementById('tilesCount').dataset.segs || 'â€”';
      const bcount = buildingCountRef.count || 0;
      infoEl.textContent = `VÃ­a cercana: ${name} Â· Calles cargadas: ${tiles} Â· edificios: ${bcount}`;
    }

    // ---------------- animation loop ----------------
    const state = {forward:0, turn:0, speed:0, maxSpeed:0.9, rotSpeed:0.045};
    let last = performance.now(), frames = 0, fpsNow = 0, fpsLast = performance.now();

    function animate(){
      const now = performance.now();
      const dt = Math.min(50, now - last) / 16.666;
      last = now;

      // joystick -> state
      state.forward = Math.max(-1, Math.min(1, stick.y));
      state.turn = Math.max(-1, Math.min(1, stick.x));
      if(state.forward > 0.05) state.speed += 0.018 * state.forward * dt;
      else if(state.forward < -0.05) state.speed -= 0.03 * (-state.forward) * dt;
      else state.speed *= 0.96;
      state.speed = Math.max(-state.maxSpeed, Math.min(state.maxSpeed, state.speed));
      // rotation & movement
      car.rotation.y += -state.turn * state.rotSpeed * (0.9 + Math.abs(state.speed)) * dt;
      const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion);
      car.position.add(fwd.multiplyScalar(state.speed * dt * 0.82));

      // soft constrain
      const cons = constrainToRoad(car.position);
      if(cons && cons.name) {
        // can show name instantly if desired
      }

      // bullets update & cleanup
      for(let i=bullets.length-1;i>=0;i--){
        const b = bullets[i];
        b.position.add(b.userData.dir.clone().multiplyScalar(b.userData.speed * dt));
        if(b.position.length() > 800){ scene.remove(b); bullets.splice(i,1); }
      }

      // update camera smooth follow
      const desired = car.position.clone().add(new THREE.Vector3(0,4,10).applyQuaternion(car.quaternion));
      camera.position.lerp(desired, 0.12);
      camera.lookAt(car.position.clone().add(new THREE.Vector3(0,1.2,0)));

      // minimap + HUD
      updateMinimap();
      updateHUDNearest();

      renderer.render(scene, camera);

      // fps calc (update each 500ms)
      frames++;
      if(now - fpsLast >= 500){ fpsNow = Math.round((frames*1000)/(now-fpsLast)); frames = 0; fpsLast = now; document.getElementById('fps').textContent = `FPS: ${fpsNow}`; }

      requestAnimationFrame(animate);
    }

    // ---------------- initialization ----------------
    const ok = await initMapData();
    // preload sat but don't block
    loadSatellite().then(()=>{/* sat preloaded */}).catch(()=>{/* ignore */});
    requestAnimationFrame(animate);

    // window resize
    window.addEventListener('resize', ()=>{ renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); });

    // finally: expose some debug on status
    document.getElementById('tilesCount').textContent = roadPolylines.length;
    // done

  })();
  </script>
</body>
</html>
